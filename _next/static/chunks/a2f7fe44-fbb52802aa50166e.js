"use strict";
(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
    [51288], {
        6864: function(e, t, n) {
            let a, r, i, f, s, o, c, d, l, u, m, p;
            n.d(t, {
                B: function() {
                    return rX
                },
                H: function() {
                    return iw
                },
                J: function() {
                    return rs
                },
                K: function() {
                    return ro
                },
                L: function() {
                    return rU
                },
                W: function() {
                    return rV
                },
                aC: function() {
                    return rL
                },
                aD: function() {
                    return rN
                },
                aM: function() {
                    return tp
                },
                aN: function() {
                    return r8
                },
                aP: function() {
                    return ic
                },
                aQ: function() {
                    return id
                },
                aT: function() {
                    return rx
                },
                aW: function() {
                    return rF
                },
                aX: function() {
                    return rS
                },
                aY: function() {
                    return rT
                },
                aZ: function() {
                    return rB
                },
                a_: function() {
                    return il
                },
                ai: function() {
                    return ig
                },
                ak: function() {
                    return ib
                },
                b$: function() {
                    return iT
                },
                b6: function() {
                    return tS
                },
                b7: function() {
                    return tT
                },
                b9: function() {
                    return tu
                },
                bF: function() {
                    return t_
                },
                bH: function() {
                    return tD
                },
                bM: function() {
                    return tM
                },
                bN: function() {
                    return tW
                },
                bO: function() {
                    return tj
                },
                bT: function() {
                    return iS
                },
                bX: function() {
                    return iC
                },
                ba: function() {
                    return tm
                },
                bh: function() {
                    return tH
                },
                bk: function() {
                    return tJ
                },
                c$: function() {
                    return aA
                },
                c3: function() {
                    return iD
                },
                c7: function() {
                    return iM
                },
                cA: function() {
                    return tv
                },
                cB: function() {
                    return tw
                },
                cC: function() {
                    return tk
                },
                cD: function() {
                    return n9
                },
                cE: function() {
                    return n6
                },
                cF: function() {
                    return n7
                },
                cG: function() {
                    return ae
                },
                cH: function() {
                    return n4
                },
                cI: function() {
                    return an
                },
                cJ: function() {
                    return aK
                },
                cK: function() {
                    return aq
                },
                cL: function() {
                    return aa
                },
                cM: function() {
                    return as
                },
                cN: function() {
                    return al
                },
                cO: function() {
                    return ad
                },
                cP: function() {
                    return au
                },
                cQ: function() {
                    return ar
                },
                cR: function() {
                    return ak
                },
                cS: function() {
                    return aC
                },
                cT: function() {
                    return am
                },
                cU: function() {
                    return ap
                },
                cV: function() {
                    return aE
                },
                cW: function() {
                    return ab
                },
                cX: function() {
                    return ay
                },
                cY: function() {
                    return aw
                },
                cZ: function() {
                    return ai
                },
                c_: function() {
                    return ag
                },
                cb: function() {
                    return iG
                },
                cf: function() {
                    return iJ
                },
                cj: function() {
                    return iU
                },
                cp: function() {
                    return i0
                },
                cs: function() {
                    return ip
                },
                cw: function() {
                    return tz
                },
                cx: function() {
                    return tE
                },
                cy: function() {
                    return tb
                },
                cz: function() {
                    return tA
                },
                d1: function() {
                    return aG
                },
                d2: function() {
                    return aj
                },
                d3: function() {
                    return aJ
                },
                d4: function() {
                    return aU
                },
                d5: function() {
                    return nf
                },
                d6: function() {
                    return aT
                },
                d7: function() {
                    return ax
                },
                d8: function() {
                    return a_
                },
                d9: function() {
                    return nm
                },
                dB: function() {
                    return ty
                },
                dD: function() {
                    return i2
                },
                dE: function() {
                    return i5
                },
                dF: function() {
                    return i3
                },
                dG: function() {
                    return i$
                },
                dH: function() {
                    return aX
                },
                dI: function() {
                    return i6
                },
                dJ: function() {
                    return i1
                },
                dK: function() {
                    return i8
                },
                dL: function() {
                    return iv
                },
                da: function() {
                    return az
                },
                db: function() {
                    return aP
                },
                dc: function() {
                    return aO
                },
                dd: function() {
                    return aB
                },
                de: function() {
                    return aR
                },
                df: function() {
                    return aD
                },
                dg: function() {
                    return aI
                },
                dh: function() {
                    return aN
                },
                di: function() {
                    return aL
                },
                dr: function() {
                    return aV
                },
                ds: function() {
                    return ir
                },
                dt: function() {
                    return r6
                },
                du: function() {
                    return r0
                },
                dv: function() {
                    return rQ
                },
                dw: function() {
                    return r1
                },
                dx: function() {
                    return a0
                },
                dy: function() {
                    return a1
                },
                dz: function() {
                    return a2
                },
                n: function() {
                    return rI
                },
                o: function() {
                    return rM
                },
                s: function() {
                    return rW
                },
                t: function() {
                    return rj
                },
                w: function() {
                    return rH
                },
                x: function() {
                    return rG
                },
                y: function() {
                    return rK
                },
                z: function() {
                    return rq
                }
            });
            var g, h, b = n(40739),
                y = n(36173),
                w = n(46396),
                E = n(84062),
                k = n(32114),
                C = n(49022),
                A = n(89005),
                z = n(22594),
                v = n(12045),
                x = n(83077),
                F = n(28257),
                S = n(9784),
                T = n(43481),
                B = n(93850),
                O = n(99554),
                $ = n(40582),
                _ = n(87847),
                R = n(83531),
                D = n(88849),
                P = n(6352),
                L = n(75986),
                N = n(59772),
                I = n(71759);
            n(3149);
            var M = n(59811),
                W = n(66702),
                j = n.n(W),
                U = n(35550),
                V = n.n(U),
                H = n(70462),
                G = n(6328),
                K = n(34972),
                q = n(68096),
                J = n(6923),
                Z = n(52808),
                X = n(40185),
                Y = n(3407),
                Q = n(84144),
                ee = n(43451),
                et = n(29790),
                en = n(1426),
                ea = n(68496),
                er = n(46086),
                ei = n(98829),
                ef = n(78556),
                es = n(50546),
                eo = n(15941),
                ec = n(89393),
                ed = n(22608),
                el = n(32777),
                eu = n(44427),
                em = n(59057),
                ep = n(16865),
                eg = n(80608),
                eh = n(42444),
                eb = n(18295),
                ey = n(77404),
                ew = n(41675),
                eE = n(81351),
                ek = n(60283),
                eC = n(80761),
                eA = n(30014),
                ez = n(19454),
                ev = n(43756),
                ex = n(56858),
                eF = n(51225),
                eS = n(33041),
                eT = n(4464),
                eB = n(81575),
                eO = n(87117),
                e$ = n(85630),
                e_ = n(38669),
                eR = n(88386),
                eD = n(37137),
                eP = n(28155),
                eL = n(75088),
                eN = n(85510),
                eI = n(42008),
                eM = n(6494),
                eW = n(56318),
                ej = n(27546),
                eU = n(29955),
                eV = n(75036),
                eH = n(65110),
                eG = n(65298),
                eK = n(42714),
                eq = n(23066),
                eJ = n(46928),
                eZ = n(85781),
                eX = n(71278),
                eY = n(89741),
                eQ = n(6474),
                e0 = n(25566),
                e1 = n(9109).Buffer;

            function e2(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
                return void 0 !== e0 && e0.env[e] ? e0.env[e] : t
            }

            function e5(e) {
                return !!(e && e._isSigner)
            }

            function e6(e) {
                return !!(e && e._isProvider)
            }
            let e8 = {
                timeLimitMs: 10,
                sizeLimit: 200
            };
            class e3 extends b.c {
                constructor(e, t) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e8;
                    super(e, t), this._timeLimitMs = n.timeLimitMs || 10, this._sizeLimit = n.sizeLimit || 200, this._pendingBatchAggregator = null, this._pendingBatch = null
                }
                sendCurrentBatch(e) {
                    this._pendingBatchAggregator && clearTimeout(this._pendingBatchAggregator);
                    let t = this._pendingBatch || [];
                    this._pendingBatch = null, this._pendingBatchAggregator = null;
                    let n = t.map(e => e.request);
                    return this.emit("debug", {
                        action: "requestBatch",
                        request: y.deepCopy(e),
                        provider: this
                    }), w.fetchJson(this.connection, JSON.stringify(n)).then(e => {
                        this.emit("debug", {
                            action: "response",
                            request: n,
                            response: e,
                            provider: this
                        }), t.forEach((t, n) => {
                            let a = e[n];
                            if (a) {
                                if (a.error) {
                                    let e = Error(a.error.message);
                                    e.code = a.error.code, e.data = a.error.data, t.reject(e)
                                } else t.resolve(a.result)
                            } else t.reject(Error("No response for request"))
                        })
                    }, e => {
                        this.emit("debug", {
                            action: "response",
                            error: e,
                            request: n,
                            provider: this
                        }), t.forEach(t => {
                            t.reject(e)
                        })
                    })
                }
                send(e, t) {
                    let n = {
                        method: e,
                        params: t,
                        id: this._nextId++,
                        jsonrpc: "2.0"
                    };
                    null === this._pendingBatch && (this._pendingBatch = []);
                    let a = {
                            request: n,
                            resolve: null,
                            reject: null
                        },
                        r = new Promise((e, t) => {
                            a.resolve = e, a.reject = t
                        });
                    return this._pendingBatch.push(a), this._pendingBatch.length === this._sizeLimit && this.sendCurrentBatch(n), this._pendingBatchAggregator || (this._pendingBatchAggregator = setTimeout(() => {
                        this.sendCurrentBatch(n)
                    }, this._timeLimitMs)), r
                }
            }
            let e9 = N.z.object({
                    rpc: N.z.array(N.z.string().url()),
                    chainId: N.z.number(),
                    nativeCurrency: N.z.object({
                        name: N.z.string(),
                        symbol: N.z.string(),
                        decimals: N.z.number()
                    }),
                    slug: N.z.string()
                }),
                e4 = N.z.object({
                    supportedChains: N.z.array(e9).default(I.gL9),
                    clientId: N.z.string().optional(),
                    secretKey: N.z.string().optional(),
                    readonlySettings: N.z.object({
                        rpcUrl: N.z.string().url(),
                        chainId: N.z.number().optional()
                    }).optional(),
                    gasSettings: N.z.object({
                        maxPriceInGwei: N.z.number().min(1, "gas price cannot be less than 1").default(300),
                        speed: N.z.enum(["standard", "fast", "fastest"]).default("fastest")
                    }).default({
                        maxPriceInGwei: 300,
                        speed: "fastest"
                    }),
                    gasless: N.z.union([N.z.object({
                        openzeppelin: N.z.object({
                            relayerUrl: N.z.string().url(),
                            relayerForwarderAddress: N.z.string().optional(),
                            useEOAForwarder: N.z.boolean().default(!1),
                            domainName: N.z.string().default("GSNv2 Forwarder"),
                            domainVersion: N.z.string().default("0.0.1"),
                            domainSeparatorVersion: N.z.string().default("1")
                        }),
                        experimentalChainlessSupport: N.z.boolean().default(!1)
                    }), N.z.object({
                        biconomy: N.z.object({
                            apiId: N.z.string(),
                            apiKey: N.z.string(),
                            deadlineSeconds: N.z.number().min(1, "deadlineSeconds cannot be les than 1").default(3600)
                        })
                    }), N.z.object({
                        engine: N.z.object({
                            relayerUrl: N.z.string().url().transform(e => e.replace(/\/$/, "")),
                            relayerForwarderAddress: N.z.string().optional(),
                            domainName: N.z.string().default("GSNv2 Forwarder"),
                            domainVersion: N.z.string().default("0.0.1"),
                            domainSeparatorVersion: N.z.string().default("1")
                        }),
                        experimentalChainlessSupport: N.z.boolean().default(!1)
                    })]).optional(),
                    gatewayUrls: N.z.array(N.z.string()).optional(),
                    rpcBatchSettings: N.z.object({
                        sizeLimit: N.z.number().default(200),
                        timeLimit: N.z.number().default(10)
                    }).optional()
                }).default({
                    gasSettings: {
                        maxPriceInGwei: 300,
                        speed: "fastest"
                    }
                });
            var e7 = {
                name: "@thirdweb-dev/sdk",
                version: "4.0.85"
            };
            let te = [
                ["iOS", /iP(hone|od|ad)/],
                ["Android OS", /Android/],
                ["BlackBerry OS", /BlackBerry|BB10/],
                ["Windows Mobile", /IEMobile/],
                ["Amazon OS", /Kindle/],
                ["Windows 3.11", /Win16/],
                ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
                ["Windows 98", /(Windows 98)|(Win98)/],
                ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
                ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
                ["Windows Server 2003", /(Windows NT 5.2)/],
                ["Windows Vista", /(Windows NT 6.0)/],
                ["Windows 7", /(Windows NT 6.1)/],
                ["Windows 8", /(Windows NT 6.2)/],
                ["Windows 8.1", /(Windows NT 6.3)/],
                ["Windows 10", /(Windows NT 10.0)/],
                ["Windows ME", /Windows ME/],
                ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
                ["Open BSD", /OpenBSD/],
                ["Sun OS", /SunOS/],
                ["Chrome OS", /CrOS/],
                ["Linux", /(Linux)|(X11)/],
                ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
                ["QNX", /QNX/],
                ["BeOS", /BeOS/],
                ["OS/2", /OS\/2/]
            ];

            function tt() {
                return "undefined" != typeof navigator && "ReactNative" === navigator.product ? "" : function(e) {
                    for (let t = 0, n = te.length; t < n; t++) {
                        let n = te[t];
                        if (!n) continue;
                        let [a, r] = n;
                        if (r.exec(e)) return a
                    }
                    return null
                }(navigator.userAgent) || ""
            }

            function tn() {
                return "undefined" == typeof globalThis ? {
                    x_sdk_name: e7.name,
                    x_sdk_platform: ta(),
                    x_sdk_version: e7.version,
                    x_sdk_os: tt(),
                    app_bundle_id: void 0
                } : (void 0 === globalThis.X_SDK_NAME && (globalThis.X_SDK_NAME = e7.name, globalThis.X_SDK_PLATFORM = ta(), globalThis.X_SDK_VERSION = e7.version, globalThis.X_SDK_OS = tt(), globalThis.APP_BUNDLE_ID = void 0), {
                    x_sdk_name: globalThis.X_SDK_NAME,
                    x_sdk_platform: globalThis.X_SDK_PLATFORM,
                    x_sdk_version: globalThis.X_SDK_VERSION,
                    x_sdk_os: globalThis.X_SDK_OS,
                    app_bundle_id: globalThis.APP_BUNDLE_ID || ""
                })
            }

            function ta() {
                return "undefined" != typeof navigator && "ReactNative" === navigator.product ? "mobile" : "browser"
            }

            function tr(e, t) {
                let n;
                if ("string" == typeof e && function(e) {
                        let t = e.match(/^(ws|http)s?:/i);
                        if (t) switch (t[1].toLowerCase()) {
                            case "http":
                            case "https":
                            case "ws":
                            case "wss":
                                return !0
                        }
                        return !1
                    }(e)) return ts(e, t);
                let a = e4.parse(t);
                ti(e) && (a.supportedChains = [e, ...a.supportedChains.filter(t => t.chainId === e.chainId)]);
                let r = a.supportedChains.reduce((e, t) => (e[t.chainId] || (e[t.chainId] = t), e), {}),
                    i = "";
                try {
                    n = function(e, t) {
                        if (ti(e)) return e.chainId;
                        if ("number" == typeof e) return e; {
                            let n = t.supportedChains.reduce((e, t) => (e[t.slug] = t.chainId, e), {});
                            if (e in n) return n[e]
                        }
                        throw Error(`Cannot resolve chainId from: ${e} - please pass the chainId instead and specify it in the 'supportedChains' property of the SDK options.`)
                    }(e, a), i = (0, I.OZ$)(r[n], a.clientId)[0]
                } catch (e) {}
                if (i || (i = `https://${n||e}.rpc.thirdweb.com/${a.clientId||""}`), !i) throw Error(`No rpc url found for chain ${e}. Please provide a valid rpc url via the 'supportedChains' property of the sdk options.`);
                return ts(i, t, n)
            }

            function ti(e) {
                return "string" != typeof e && "number" != typeof e && !e5(e) && !e6(e)
            }
            let tf = new Map;

            function ts(e, t, n) {
                try {
                    var a;
                    let r = {},
                        i = "none";
                    if (a = e, new URL(a).hostname.endsWith(".thirdweb.com")) {
                        if (t ? .secretKey) throw Error("Cannot use secretKey in browser context");
                        if (t ? .clientId) {
                            let n = new URL(e);
                            n.pathname = t.clientId, r["x-client-id"] = t.clientId, e = n.toString(), i = "clientId"
                        }
                        "undefined" != typeof globalThis && "TW_AUTH_TOKEN" in globalThis && "string" == typeof globalThis.TW_AUTH_TOKEN && (r.authorization = `Bearer ${globalThis.TW_AUTH_TOKEN}`, i = "twAuthToken"), "undefined" != typeof globalThis && "TW_CLI_AUTH_TOKEN" in globalThis && "string" == typeof globalThis.TW_CLI_AUTH_TOKEN && (r["x-authorize-wallet"] = "true"),
                            function(e) {
                                let t = tn();
                                e["x-sdk-version"] = t.x_sdk_version, e["x-sdk-name"] = t.x_sdk_name, e["x-sdk-platform"] = t.x_sdk_platform, e["x-sdk-os"] = t.x_sdk_os
                            }(r);
                        let n = "undefined" != typeof globalThis && "APP_BUNDLE_ID" in globalThis ? globalThis.APP_BUNDLE_ID : void 0;
                        !e.includes("bundleId") && n && (e += n ? `?bundleId=${n}` : "")
                    }
                    let f = e.match(/^(ws|http)s?:/i);
                    if (f) switch (f[1].toLowerCase()) {
                        case "http":
                        case "https":
                            let s = `${e}-${n||-1}-${i}`,
                                o = tf.get(s);
                            if (o) return o;
                            let c = !1;
                            "undefined" != typeof globalThis && "TW_SKIP_FETCH_SETUP" in globalThis && "boolean" == typeof globalThis.TW_SKIP_FETCH_SETUP && (c = globalThis.TW_SKIP_FETCH_SETUP);
                            let d = n ? new e3({
                                url: e,
                                headers: r,
                                skipFetchSetup: c
                            }, n, t ? .rpcBatchSettings) : new E.I({
                                url: e,
                                headers: r,
                                skipFetchSetup: c
                            });
                            return tf.set(s, d), d;
                        case "ws":
                        case "wss":
                            return new k.q(e, n)
                    }
                } catch (e) {}
                return C.getDefaultProvider(e)
            }

            function to(e, t) {
                let n, a;
                if (e5(e) ? (n = e, e.provider && (a = e.provider)) : a = e6(e) ? e : tr(e, t), t ? .readonlySettings && (a = ts(t.readonlySettings.rpcUrl, t, t.readonlySettings.chainId)), !a) {
                    if (n) throw Error("No provider passed to the SDK! Please make sure that your signer is connected to a provider!");
                    throw Error("No provider found! Make sure to specify which network to connect to, or pass a signer or provider to the SDK!")
                }
                return [n, a]
            }
            let tc = new Map;
            async function td(e) {
                let t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                a || (a = to("ethereum")[1]), t = tc.has(e) ? tc.get(e) : a.resolveName(e).then(e => e ? {
                    address: e,
                    expirationTime: new Date(Date.now() + 3e5)
                } : {
                    address: null,
                    expirationTime: new Date(Date.now() + 3e4)
                });
                let r = await t;
                return r.expirationTime < new Date && (tc.delete(e), 0 === n && td(e, n + 1)), r.address
            }
            let tl = N.z.custom(e => "string" == typeof e && (e.endsWith(".eth") || e.endsWith(".cb.id"))).transform(async e => td(e)).refine(e => !!e && A.isAddress(e), {
                    message: "Provided value was not a valid ENS name"
                }),
                tu = N.z.custom(e => "string" == typeof e && A.isAddress(e), e => ({
                    message: `${e} is not a valid address`
                })),
                tm = N.z.union([tu, tl], {
                    invalid_type_error: "Provided value was not a valid address or ENS name"
                });
            async function tp(e) {
                return tm.parseAsync(e)
            }
            let tg = N.z.instanceof(File),
                th = N.z.union([tg, N.z.object({
                    data: N.z.union([tg, N.z.string()]),
                    name: N.z.string()
                })]),
                tb = N.z.union([th, N.z.string()]),
                ty = 1e4,
                tw = N.z.union([N.z.array(N.z.number()), N.z.string()]),
                tE = N.z.union([N.z.bigint(), N.z.custom(e => z.O$.isBigNumber(e)), N.z.custom(e => j().isBN(e))]).transform(e => j().isBN(e) ? new(j())(e).toString() : z.O$.from(e).toString()),
                tk = N.z.number().max(ty, "Cannot exceed 100%").min(0, "Cannot be below 0%"),
                tC = N.z.number().max(100, "Cannot exceed 100%").min(0, "Cannot be below 0%"),
                tA = N.z.union([N.z.string().regex(/^([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, "Invalid hex color"), N.z.string().regex(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, "Invalid hex color").transform(e => e.replace("#", "")), N.z.string().length(0)]),
                tz = N.z.union([N.z.string().regex(/^([0-9]+\.?[0-9]*|\.[0-9]+)$/, "Invalid amount"), N.z.number().min(0, "Amount cannot be negative")]).transform(e => "number" == typeof e ? e.toString() : e),
                tv = N.z.union([tz, N.z.literal("unlimited")]).default("unlimited"),
                tx = "0|[1-9]\\d*",
                tF = RegExp(`(${tx})\\.(${tx})\\.(${tx})`),
                tS = N.z.union([N.z.string(), N.z.number(), N.z.bigint(), N.z.custom(e => z.O$.isBigNumber(e))]).transform(e => z.O$.from(e)),
                tT = tS.transform(e => e.toString()),
                tB = N.z.union([N.z.bigint(), N.z.custom(e => z.O$.isBigNumber(e))]).transform(e => z.O$.from(e).toString()),
                tO = N.z.object({
                    name: N.z.string(),
                    description: N.z.string().optional(),
                    image: tb.optional(),
                    external_link: N.z.string().optional(),
                    app_uri: N.z.string().optional(),
                    social_urls: N.z.record(N.z.string()).optional(),
                    defaultAdmin: tm.optional()
                }).catchall(N.z.unknown()),
                t$ = tO.extend({
                    image: N.z.string().optional()
                }).catchall(N.z.unknown()),
                t_ = N.z.object({
                    seller_fee_basis_points: tk.default(0),
                    fee_recipient: tm.default(v.d)
                }),
                tR = N.z.object({
                    primary_sale_recipient: tm.default(v.d)
                }),
                tD = N.z.object({
                    platform_fee_basis_points: tk.default(0),
                    platform_fee_recipient: tm.default(v.d)
                }),
                tP = N.z.object({
                    trusted_forwarders: N.z.array(tm).default([])
                }),
                tL = N.z.object({
                    symbol: N.z.string().default("")
                }),
                tN = N.z.object({
                    merkle: N.z.record(N.z.string()).default({})
                }),
                tI = N.z.object({
                    address: tm,
                    maxClaimable: tv.default(0),
                    price: tv.optional(),
                    currencyAddress: tm.default(v.d).optional()
                }),
                tM = N.z.union([N.z.array(N.z.string()).transform(async e => await Promise.all(e.map(e => tI.parseAsync({
                    address: e
                })))), N.z.array(tI)]),
                tW = tI.extend({
                    proof: N.z.array(N.z.string())
                }),
                tj = N.z.object({
                    merkleRoot: N.z.string(),
                    claims: N.z.array(tW)
                }),
                tU = tO.catchall(N.z.union([tB, N.z.unknown()])).merge(t_.merge(tN).merge(tL).partial()).catchall(N.z.any()),
                tV = t$.merge(t_.merge(tN).merge(tL).partial()).catchall(N.z.any()),
                tH = {
                    deploy: tU.merge(tD.merge(tR).merge(tP).partial()),
                    output: tV,
                    input: tU
                },
                tG = N.z.object({
                    type: N.z.string(),
                    name: N.z.string().default("")
                }).catchall(N.z.any()),
                tK = tG.extend({
                    stateMutability: N.z.string().optional(),
                    components: N.z.array(tG).optional()
                }).catchall(N.z.any()),
                tq = N.z.object({
                    type: N.z.string(),
                    name: N.z.string().default(""),
                    inputs: N.z.array(tK).default([]),
                    outputs: N.z.array(tK).default([])
                }).catchall(N.z.any()),
                tJ = N.z.array(tq),
                tZ = N.z.union([N.z.literal("solc"), N.z.literal("zksolc")]),
                tX = N.z.object({
                    name: N.z.string(),
                    metadataUri: N.z.string(),
                    bytecodeUri: N.z.string(),
                    analytics: N.z.any().optional(),
                    compilers: N.z.record(tZ, N.z.array(N.z.object({
                        compilerVersion: N.z.string().optional(),
                        evmVersion: N.z.string().optional(),
                        metadataUri: N.z.string(),
                        bytecodeUri: N.z.string()
                    }))).optional()
                }).catchall(N.z.any()),
                tY = N.z.record(N.z.string(), N.z.string()),
                tQ = N.z.object({
                    factoryFunction: N.z.string(),
                    params: N.z.array(N.z.object({
                        name: N.z.string(),
                        type: N.z.string()
                    })).default([]),
                    customFactoryAddresses: tY
                }),
                t0 = N.z.object({
                    implementationAddresses: tY,
                    implementationInitializerFunction: N.z.string().default("initialize"),
                    customFactoryInput: tQ.optional(),
                    factoryAddresses: tY.optional()
                }),
                t1 = N.z.union([N.z.literal("standard"), N.z.literal("autoFactory"), N.z.literal("customFactory")]),
                t2 = N.z.union([N.z.literal("none"), N.z.literal("plugin"), N.z.literal("dynamic")]),
                t5 = N.z.object({
                    allNetworks: N.z.boolean().optional(),
                    networksEnabled: N.z.array(N.z.number()).default([])
                }),
                t6 = N.z.object({
                    version: N.z.string().refine(e => {
                        try {
                            return function(e) {
                                if (e.length > 256) throw Error("version is longer than 256 characters");
                                let t = e.trim().match(tF);
                                if (!t || t ? .length !== 4) throw Error(`${e} is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`);
                                let n = Number(t[1]),
                                    a = Number(t[2]),
                                    r = Number(t[3]);
                                [n, a, r].join(".")
                            }(e), !0
                        } catch (e) {
                            return !1
                        }
                    }, e => ({
                        message: `'${e}' is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`
                    })),
                    displayName: N.z.string().optional(),
                    description: N.z.string().optional(),
                    externalLinks: N.z.array(N.z.object({
                        name: N.z.string(),
                        url: N.z.string()
                    })).optional(),
                    readme: N.z.string().optional(),
                    license: N.z.string().optional(),
                    changelog: N.z.string().optional(),
                    tags: N.z.array(N.z.string()).optional(),
                    audit: tb.nullable().optional(),
                    logo: tb.nullable().optional(),
                    isDeployableViaFactory: N.z.boolean().optional(),
                    isDeployableViaProxy: N.z.boolean().optional(),
                    factoryDeploymentData: t0.optional(),
                    deployType: t1.optional(),
                    routerType: t2.optional(),
                    defaultExtensions: N.z.array(N.z.object({
                        extensionName: N.z.string(),
                        extensionVersion: N.z.string().default("latest"),
                        publisherAddress: tm
                    })).optional(),
                    networksForDeployment: t5.optional(),
                    constructorParams: N.z.record(N.z.string(), N.z.object({
                        displayName: N.z.string().optional(),
                        description: N.z.string().optional(),
                        defaultValue: N.z.string().optional(),
                        hidden: N.z.boolean().optional()
                    }).catchall(N.z.any())).optional(),
                    compositeAbi: tJ.optional()
                }).catchall(N.z.any()).extend({
                    audit: N.z.string().nullable().optional(),
                    logo: N.z.string().nullable().optional()
                }),
                t8 = tX.merge(t6).extend({
                    publisher: tm.optional()
                }),
                t3 = N.z.object({
                    id: N.z.string(),
                    timestamp: tT,
                    metadataUri: N.z.string()
                }),
                t9 = N.z.object({
                    title: N.z.string().optional(),
                    author: N.z.string().optional(),
                    details: N.z.string().optional(),
                    notice: N.z.string().optional()
                }),
                t4 = N.z.object({
                    name: N.z.string(),
                    abi: tJ,
                    metadata: N.z.record(N.z.string(), N.z.any()),
                    info: t9,
                    licenses: N.z.array(N.z.string().optional()).default([]).transform(e => e.filter(e => void 0 !== e)),
                    isPartialAbi: N.z.boolean().optional()
                }),
                t7 = tX.merge(t4).extend({
                    bytecode: N.z.string(),
                    fetchedMetadataUri: N.z.string(),
                    fetchedBytecodeUri: N.z.string()
                });
            async function ne(e, t) {
                let n = await (await t.download(e)).text();
                return t8.parse(JSON.parse(n))
            }
            async function nt(e, t) {
                let n = await t.downloadJSON(e, {
                    timeoutInSeconds: 2
                });
                if (!n || !n.output) throw Error(`Could not resolve metadata for contract at ${e}`);
                return nn(n)
            }

            function nn(e) {
                let t = tJ.parse(e.output.abi),
                    n = e.settings.compilationTarget,
                    a = Object.keys(n),
                    r = n[a[0]],
                    i = t9.parse({
                        title: e.output.devdoc.title,
                        author: e.output.devdoc.author,
                        details: e.output.devdoc.detail,
                        notice: e.output.userdoc.notice
                    }),
                    f = [...new Set(Object.entries(e.sources).map(e => {
                        let [, t] = e;
                        return t.license
                    }))];
                return {
                    name: r,
                    abi: t,
                    metadata: e,
                    info: i,
                    licenses: f,
                    isPartialAbi: e.isPartialAbi
                }
            }
            async function na(e, t) {
                return tX.parse(JSON.parse(await (await t.download(e)).text()))
            }
            async function nr(e, t, n) {
                let a, r;
                let i = await na(e, t);
                if (n && i.compilers) {
                    let e;
                    switch (n.compilerType) {
                        case "solc":
                            if (n.compilerVersion) e = i.compilers.solc ? .find(e => e.compilerVersion === n.compilerVersion && e.evmVersion === n.evmVersion);
                            else if (i.compilers.solc) {
                                let t = i.compilers.solc.length;
                                e = i.compilers.solc[t - 1]
                            }
                            break;
                        case "zksolc":
                            if (n.compilerVersion) e = i.compilers.zksolc ? .find(e => e.compilerVersion === n.compilerVersion && e.evmVersion === n.evmVersion);
                            else if (i.compilers.zksolc) {
                                let t = i.compilers.zksolc.length;
                                e = i.compilers.zksolc[t - 1]
                            }
                    }(0, M.Z)(e, "Compiler or EVM version not found"), a = e.bytecodeUri, r = e.metadataUri
                } else a = i.bytecodeUri, r = i.metadataUri;
                let [f, s] = await Promise.all([t.download(a), nt(r, t)]);
                return t7.parse({ ...i,
                    ...s,
                    bytecode: await f.text(),
                    fetchedMetadataUri: r,
                    fetchedBytecodeUri: a
                })
            }
            let ni = () => !0,
                nf = () => !ni();

            function ns(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Map;
                return {
                    put: function(n, a) {
                        if (t.size >= e) {
                            let e = t.keys().next().value;
                            t.delete(e)
                        }
                        t.set(n, a)
                    },
                    get: function(e) {
                        if (!t.has(e)) return;
                        let n = t.get(e);
                        return t.delete(e), t.set(e, n), n
                    },
                    has: function(e) {
                        return t.has(e)
                    },
                    maxEntries: e,
                    store: t
                }
            }
            let no = ns(20);
            async function nc(e, t, n) {
                let a;
                let r = n ? `${n.compilerType}_${n.compilerVersion||""}_${n.evmVersion||""}
  ` : "default",
                    i = `${r}_${e}`,
                    f = no.get(i);
                if (f) return f;
                let s = await nr(e, t, n);
                try {
                    a = await ne(e, t)
                } catch (e) {}
                let o = {
                    compilerMetadata: s,
                    extendedMetadata: a
                };
                return no.put(i, o), o
            }
            let nd = I.gL9,
                nl = "0xdd99b75f095d0c4d5112aCe938e4e6ed962fb024";
            async function nu(e, t) {
                let a, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "latest",
                    i = arguments.length > 3 ? arguments[3] : void 0,
                    f = arguments.length > 4 ? arguments[4] : void 0,
                    s = arguments.length > 5 ? arguments[5] : void 0,
                    o = nd.find(e => 137 === e.chainId) || I.mgq,
                    c = await tp(e),
                    d = (await n.e(32443).then(n.t.bind(n, 32443, 19))).default,
                    l = new x.CH(e2("contractPublisherAddress", "0xf5b896Ddb5146D5dA77efF4efBb3Eae36E300808"), d, tr(o, {
                        clientId: f,
                        secretKey: s
                    }));
                if (r && "latest" !== r) {
                    let e = (await l.getPublishedContractVersions(c, t)).map(e => t3.parse({
                            id: e.contractId,
                            timestamp: e.publishTimestamp,
                            metadataUri: e.publishMetadataUri
                        })),
                        n = (await Promise.all(e.map(e => nc(e.metadataUri, i)))).map((t, n) => ({
                            name: e[n].id,
                            publishedTimestamp: e[n].timestamp,
                            publishedMetadata: t
                        })).find(e => e.publishedMetadata.extendedMetadata ? .version === r);
                    (0, M.Z)(n, "Contract version not found"), a = e.find(e => e.timestamp === n.publishedTimestamp)
                } else {
                    let e = await l.getPublishedContract(c, t);
                    a = t3.parse({
                        id: e.contractId,
                        timestamp: e.publishTimestamp,
                        metadataUri: e.publishMetadataUri
                    })
                }
                if (!a) throw Error(`No published contract found for ${t} at version by '${nl}'`);
                return a
            }
            async function nm(e, t) {
                try {
                    let a = (await n.e(35487).then(n.t.bind(n, 35487, 19))).default,
                        r = new x.CH(e, a, t),
                        [i, f] = await Promise.all([r.contractType(), r.contractVersion()]);
                    return {
                        type: F.ZN(i).replace(/\x00/g, ""),
                        version: f
                    }
                } catch (e) {
                    return
                }
            }
            try {
                r = new TextDecoder
            } catch (e) {}
            let np = 0,
                ng = {},
                nh = {},
                nb = 0,
                ny = 0,
                nw = [],
                nE = [],
                nk = {
                    useRecords: !1,
                    mapsAsObjects: !0
                },
                nC = !1;
            class nA {
                constructor(e) {
                    if (e && ((e.keyMap || e._keyMap) && !e.useRecords && (e.useRecords = !1, e.mapsAsObjects = !0), !1 === e.useRecords && void 0 === e.mapsAsObjects && (e.mapsAsObjects = !0), e.getStructures && (e.getShared = e.getStructures), e.getShared && !e.structures && ((e.structures = []).uninitialized = !0), e.keyMap))
                        for (let [t, n] of (this.mapKey = new Map, Object.entries(e.keyMap))) this.mapKey.set(n, t);
                    Object.assign(this, e)
                }
                decodeKey(e) {
                    return this.keyMap && this.mapKey.get(e) || e
                }
                decode(e, t) {
                    if (i) return nH(() => (nG(), this ? this.decode(e, t) : nA.prototype.decode.call(nk, e, t)));
                    f = t > -1 ? t : e.length, np = 0, ny = 0, o = null, c = null, i = e;
                    try {
                        u = e.dataView || (e.dataView = new DataView(e.buffer, e.byteOffset, e.byteLength))
                    } catch (t) {
                        if (i = null, e instanceof Uint8Array) throw t;
                        throw Error("Source must be a Uint8Array or Buffer but was a " + (e && "object" == typeof e ? e.constructor.name : typeof e))
                    }
                    return this instanceof nA ? (nh = this, l = this.sharedValues && (this.pack ? Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues), this.structures ? s = this.structures : (!s || s.length > 0) && (s = [])) : (nh = nk, (!s || s.length > 0) && (s = []), l = null),
                        function() {
                            try {
                                let e = nz();
                                if (c) {
                                    if (np >= c.postBundlePosition) {
                                        let e = Error("Unexpected bundle position");
                                        throw e.incomplete = !0, e
                                    }
                                    np = c.postBundlePosition, c = null
                                }
                                if (np == f) s = null, i = null, d && (d = null);
                                else if (np > f) {
                                    let e = Error("Unexpected end of CBOR data");
                                    throw e.incomplete = !0, e
                                } else if (!nC) throw Error("Data read, but end of buffer not reached");
                                return e
                            } catch (e) {
                                throw nG(), (e instanceof RangeError || e.message.startsWith("Unexpected end of buffer")) && (e.incomplete = !0), e
                            }
                        }()
                }
            }

            function nz() {
                let e = i[np++],
                    t = e >> 5;
                if ((e &= 31) > 23) switch (e) {
                    case 24:
                        e = i[np++];
                        break;
                    case 25:
                        if (7 == t) return function() {
                            let e = i[np++],
                                t = i[np++],
                                n = (127 & e) >> 2;
                            if (31 === n) return t || 3 & e ? NaN : 128 & e ? -1 / 0 : 1 / 0;
                            if (0 === n) {
                                let n = ((3 & e) << 8 | t) / 16777216;
                                return 128 & e ? -n : n
                            }
                            return n_[3] = 128 & e | (n >> 1) + 56, n_[2] = (7 & e) << 5 | t >> 3, n_[1] = t << 5, n_[0] = 0, n$[0]
                        }();
                        e = u.getUint16(np), np += 2;
                        break;
                    case 26:
                        if (7 == t) {
                            let e = u.getFloat32(np);
                            if (nh.useFloat32 > 2) {
                                let t = nK[(127 & i[np]) << 1 | i[np + 1] >> 7];
                                return np += 4, (t * e + (e > 0 ? .5 : -.5) >> 0) / t
                            }
                            return np += 4, e
                        }
                        e = u.getUint32(np), np += 4;
                        break;
                    case 27:
                        if (7 == t) {
                            let e = u.getFloat64(np);
                            return np += 8, e
                        }
                        if (t > 1) {
                            if (u.getUint32(np) > 0) throw Error("JavaScript does not support arrays, maps, or strings with length over 4294967295");
                            e = u.getUint32(np + 4)
                        } else e = nh.int64AsNumber ? 4294967296 * u.getUint32(np) + u.getUint32(np + 4) : u.getBigUint64(np);
                        np += 8;
                        break;
                    case 31:
                        switch (t) {
                            case 2:
                            case 3:
                                throw Error("Indefinite length not supported for byte or text strings");
                            case 4:
                                let n = [],
                                    a, r = 0;
                                for (;
                                    (a = nz()) != ng;) n[r++] = a;
                                return 4 == t ? n : 3 == t ? n.join("") : e1.concat(n);
                            case 5:
                                let d;
                                if (nh.mapsAsObjects) {
                                    let e = {};
                                    if (nh.keyMap)
                                        for (;
                                            (d = nz()) != ng;) e[nF(nh.decodeKey(d))] = nz();
                                    else
                                        for (;
                                            (d = nz()) != ng;) e[nF(d)] = nz();
                                    return e
                                } {
                                    m && (nh.mapsAsObjects = !0, m = !1);
                                    let e = new Map;
                                    if (nh.keyMap)
                                        for (;
                                            (d = nz()) != ng;) e.set(nh.decodeKey(d), nz());
                                    else
                                        for (;
                                            (d = nz()) != ng;) e.set(d, nz());
                                    return e
                                }
                            case 7:
                                return ng;
                            default:
                                throw Error("Invalid major type for indefinite length " + t)
                        }
                    default:
                        throw Error("Unknown token " + e)
                }
                switch (t) {
                    case 0:
                        return e;
                    case 1:
                        return ~e;
                    case 2:
                        var p;
                        return p = e, nh.copyBuffers ? Uint8Array.prototype.slice.call(i, np, np += p) : i.subarray(np, np += p);
                    case 3:
                        if (ny >= np) return o.slice(np - nb, (np += e) - nb);
                        if (0 == ny && f < 140 && e < 32) {
                            let t = e < 16 ? nO(e) : function(e) {
                                let t = np,
                                    n = Array(e);
                                for (let a = 0; a < e; a++) {
                                    let e = i[np++];
                                    if ((128 & e) > 0) {
                                        np = t;
                                        return
                                    }
                                    n[a] = e
                                }
                                return nB.apply(String, n)
                            }(e);
                            if (null != t) return t
                        }
                        return nS(e);
                    case 4:
                        let g = Array(e);
                        for (let t = 0; t < e; t++) g[t] = nz();
                        return g;
                    case 5:
                        if (nh.mapsAsObjects) {
                            let t = {};
                            if (nh.keyMap)
                                for (let n = 0; n < e; n++) t[nF(nh.decodeKey(nz()))] = nz();
                            else
                                for (let n = 0; n < e; n++) t[nF(nz())] = nz();
                            return t
                        } {
                            m && (nh.mapsAsObjects = !0, m = !1);
                            let t = new Map;
                            if (nh.keyMap)
                                for (let n = 0; n < e; n++) t.set(nh.decodeKey(nz()), nz());
                            else
                                for (let n = 0; n < e; n++) t.set(nz(), nz());
                            return t
                        }
                    case 6:
                        if (e >= 57337) {
                            let t = s[8191 & e];
                            if (t) return t.read || (t.read = nx(t)), t.read();
                            if (e < 65536) {
                                if (57343 == e) return nD(nz());
                                if (57342 == e) {
                                    let e = nU(),
                                        t = nz();
                                    for (let n = 2; n < e; n++) nD([t++, nz()]);
                                    return nz()
                                }
                                if (57337 == e) return function() {
                                    let e = nU(),
                                        t = np + nz();
                                    for (let t = 2; t < e; t++) {
                                        let e = nU();
                                        np += e
                                    }
                                    let n = np;
                                    return np = t, (c = [nT(nU()), nT(nU())]).position0 = 0, c.position1 = 0, c.postBundlePosition = np, np = n, nz()
                                }();
                                if (nh.getShared && (nV(), t = s[8191 & e])) return t.read || (t.read = nx(t)), t.read()
                            }
                        }
                        let h = nw[e];
                        if (h) {
                            if (h.handlesRead) return h(nz);
                            return h(nz())
                        } {
                            let t = nz();
                            for (let n = 0; n < nE.length; n++) {
                                let a = nE[n](e, t);
                                if (void 0 !== a) return a
                            }
                            return new nR(t, e)
                        }
                    case 7:
                        switch (e) {
                            case 20:
                                return !1;
                            case 21:
                                return !0;
                            case 22:
                                return null;
                            case 23:
                                return;
                            default:
                                let b = (l || nI())[e];
                                if (void 0 !== b) return b;
                                throw Error("Unknown token " + e)
                        }
                    default:
                        if (isNaN(e)) {
                            let e = Error("Unexpected end of CBOR data");
                            throw e.incomplete = !0, e
                        }
                        throw Error("Unknown CBOR token " + e)
                }
            }
            let nv = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;

            function nx(e) {
                return e.slowReads = 0,
                    function() {
                        let e = i[np++];
                        if ((e &= 31) > 23) switch (e) {
                            case 24:
                                e = i[np++];
                                break;
                            case 25:
                                e = u.getUint16(np), np += 2;
                                break;
                            case 26:
                                e = u.getUint32(np), np += 4;
                                break;
                            default:
                                throw Error("Expected array header, but got " + i[np - 1])
                        }
                        let t = this.compiledReader;
                        for (; t;) {
                            if (t.propertyCount === e) return t(nz);
                            t = t.next
                        }
                        if (this.slowReads++ >= 3) {
                            let n = this.length == e ? this : this.slice(0, e);
                            return t = nh.keyMap ? Function("r", "return {" + n.map(e => nh.decodeKey(e)).map(e => nv.test(e) ? nF(e) + ":r()" : "[" + JSON.stringify(e) + "]:r()").join(",") + "}") : Function("r", "return {" + n.map(e => nv.test(e) ? nF(e) + ":r()" : "[" + JSON.stringify(e) + "]:r()").join(",") + "}"), this.compiledReader && (t.next = this.compiledReader), t.propertyCount = e, this.compiledReader = t, t(nz)
                        }
                        let n = {};
                        if (nh.keyMap)
                            for (let t = 0; t < e; t++) n[nF(nh.decodeKey(this[t]))] = nz();
                        else
                            for (let t = 0; t < e; t++) n[nF(this[t])] = nz();
                        return n
                    }
            }

            function nF(e) {
                return "__proto__" === e ? "__proto_" : e
            }
            let nS = nT;

            function nT(e) {
                let t;
                if (e < 16 && (t = nO(e))) return t;
                if (e > 64 && r) return r.decode(i.subarray(np, np += e));
                let n = np + e,
                    a = [];
                for (t = ""; np < n;) {
                    let e = i[np++];
                    if ((128 & e) == 0) a.push(e);
                    else if ((224 & e) == 192) {
                        let t = 63 & i[np++];
                        a.push((31 & e) << 6 | t)
                    } else if ((240 & e) == 224) {
                        let t = 63 & i[np++],
                            n = 63 & i[np++];
                        a.push((31 & e) << 12 | t << 6 | n)
                    } else if ((248 & e) == 240) {
                        let t = (7 & e) << 18 | (63 & i[np++]) << 12 | (63 & i[np++]) << 6 | 63 & i[np++];
                        t > 65535 && (t -= 65536, a.push(t >>> 10 & 1023 | 55296), t = 56320 | 1023 & t), a.push(t)
                    } else a.push(e);
                    a.length >= 4096 && (t += nB.apply(String, a), a.length = 0)
                }
                return a.length > 0 && (t += nB.apply(String, a)), t
            }
            let nB = String.fromCharCode;

            function nO(e) {
                if (e < 4) {
                    if (e < 2) {
                        if (0 === e) return ""; {
                            let e = i[np++];
                            if ((128 & e) > 1) {
                                np -= 1;
                                return
                            }
                            return nB(e)
                        }
                    } {
                        let t = i[np++],
                            n = i[np++];
                        if ((128 & t) > 0 || (128 & n) > 0) {
                            np -= 2;
                            return
                        }
                        if (e < 3) return nB(t, n);
                        let a = i[np++];
                        if ((128 & a) > 0) {
                            np -= 3;
                            return
                        }
                        return nB(t, n, a)
                    }
                } {
                    let t = i[np++],
                        n = i[np++],
                        a = i[np++],
                        r = i[np++];
                    if ((128 & t) > 0 || (128 & n) > 0 || (128 & a) > 0 || (128 & r) > 0) {
                        np -= 4;
                        return
                    }
                    if (e < 6) {
                        if (4 === e) return nB(t, n, a, r); {
                            let e = i[np++];
                            if ((128 & e) > 0) {
                                np -= 5;
                                return
                            }
                            return nB(t, n, a, r, e)
                        }
                    }
                    if (e < 8) {
                        let f = i[np++],
                            s = i[np++];
                        if ((128 & f) > 0 || (128 & s) > 0) {
                            np -= 6;
                            return
                        }
                        if (e < 7) return nB(t, n, a, r, f, s);
                        let o = i[np++];
                        if ((128 & o) > 0) {
                            np -= 7;
                            return
                        }
                        return nB(t, n, a, r, f, s, o)
                    } {
                        let f = i[np++],
                            s = i[np++],
                            o = i[np++],
                            c = i[np++];
                        if ((128 & f) > 0 || (128 & s) > 0 || (128 & o) > 0 || (128 & c) > 0) {
                            np -= 8;
                            return
                        }
                        if (e < 10) {
                            if (8 === e) return nB(t, n, a, r, f, s, o, c); {
                                let e = i[np++];
                                if ((128 & e) > 0) {
                                    np -= 9;
                                    return
                                }
                                return nB(t, n, a, r, f, s, o, c, e)
                            }
                        }
                        if (e < 12) {
                            let d = i[np++],
                                l = i[np++];
                            if ((128 & d) > 0 || (128 & l) > 0) {
                                np -= 10;
                                return
                            }
                            if (e < 11) return nB(t, n, a, r, f, s, o, c, d, l);
                            let u = i[np++];
                            if ((128 & u) > 0) {
                                np -= 11;
                                return
                            }
                            return nB(t, n, a, r, f, s, o, c, d, l, u)
                        } {
                            let d = i[np++],
                                l = i[np++],
                                u = i[np++],
                                m = i[np++];
                            if ((128 & d) > 0 || (128 & l) > 0 || (128 & u) > 0 || (128 & m) > 0) {
                                np -= 12;
                                return
                            }
                            if (e < 14) {
                                if (12 === e) return nB(t, n, a, r, f, s, o, c, d, l, u, m); {
                                    let e = i[np++];
                                    if ((128 & e) > 0) {
                                        np -= 13;
                                        return
                                    }
                                    return nB(t, n, a, r, f, s, o, c, d, l, u, m, e)
                                }
                            } {
                                let p = i[np++],
                                    g = i[np++];
                                if ((128 & p) > 0 || (128 & g) > 0) {
                                    np -= 14;
                                    return
                                }
                                if (e < 15) return nB(t, n, a, r, f, s, o, c, d, l, u, m, p, g);
                                let h = i[np++];
                                if ((128 & h) > 0) {
                                    np -= 15;
                                    return
                                }
                                return nB(t, n, a, r, f, s, o, c, d, l, u, m, p, g, h)
                            }
                        }
                    }
                }
            }
            let n$ = new Float32Array(1),
                n_ = new Uint8Array(n$.buffer, 0, 4);
            class nR {
                constructor(e, t) {
                    this.value = e, this.tag = t
                }
            }
            nw[0] = e => new Date(e), nw[1] = e => new Date(Math.round(1e3 * e)), nw[2] = e => {
                let t = BigInt(0);
                for (let n = 0, a = e.byteLength; n < a; n++) t = BigInt(e[n]) + t << BigInt(8);
                return t
            }, nw[3] = e => BigInt(-1) - nw[2](e), nw[4] = e => Number(e[1] + "e" + e[0]), nw[5] = e => e[1] * Math.exp(e[0] * Math.log(2));
            let nD = e => {
                let t = e[0] - 57344,
                    n = e[1],
                    a = s[t];
                a && a.isShared && ((s.restoreStructures || (s.restoreStructures = []))[t] = a), s[t] = n, n.read = nx(n);
                let r = {};
                if (nh.keyMap)
                    for (let t = 2, a = e.length; t < a; t++) r[nF(nh.decodeKey(n[t - 2]))] = e[t];
                else
                    for (let t = 2, a = e.length; t < a; t++) r[nF(n[t - 2])] = e[t];
                return r
            };
            nw[105] = nD, nw[14] = e => c ? c[0].slice(c.position0, c.position0 += e) : new nR(e, 14), nw[15] = e => c ? c[1].slice(c.position1, c.position1 += e) : new nR(e, 15);
            let nP = {
                Error,
                RegExp
            };
            nw[27] = e => (nP[e[0]] || Error)(e[1], e[2]);
            let nL = e => {
                if (132 != i[np++]) throw Error("Packed values structure must be followed by a 4 element array");
                let t = e();
                return (l = l ? t.concat(l.slice(t.length)) : t).prefixes = e(), l.suffixes = e(), e()
            };

            function nN(e, t) {
                return "string" == typeof e ? e + t : e instanceof Array ? e.concat(t) : Object.assign({}, e, t)
            }

            function nI() {
                if (!l) {
                    if (nh.getShared) nV();
                    else throw Error("No packed values available")
                }
                return l
            }
            nL.handlesRead = !0, nw[51] = nL, nw[6] = e => {
                if (!l) {
                    if (!nh.getShared) return new nR(e, 6);
                    nV()
                }
                if ("number" == typeof e) return l[16 + (e >= 0 ? 2 * e : -2 * e - 1)];
                throw Error("No support for non-integer packed references yet")
            }, nw[25] = e => stringRefs[e], nw[256] = e => {
                stringRefs = [];
                try {
                    return e()
                } finally {
                    stringRefs = null
                }
            }, nw[256].handlesRead = !0, nw[28] = e => {
                let t;
                d || ((d = new Map).id = 0);
                let n = d.id++,
                    a = {
                        target: t = i[np] >> 5 == 4 ? [] : {}
                    };
                d.set(n, a);
                let r = e();
                return a.used ? Object.assign(t, r) : (a.target = r, r)
            }, nw[28].handlesRead = !0, nw[29] = e => {
                let t = d.get(e);
                return t.used = !0, t.target
            }, nw[258] = e => new Set(e), (nw[259] = e => (nh.mapsAsObjects && (nh.mapsAsObjects = !1, m = !0), e())).handlesRead = !0, nE.push((e, t) => e >= 225 && e <= 255 ? nN(nI().prefixes[e - 224], t) : e >= 28704 && e <= 32767 ? nN(nI().prefixes[e - 28672], t) : e >= 1879052288 && e <= 2147483647 ? nN(nI().prefixes[e - 1879048192], t) : e >= 216 && e <= 223 ? nN(t, nI().suffixes[e - 216]) : e >= 27647 && e <= 28671 ? nN(t, nI().suffixes[e - 27639]) : e >= 1811940352 && e <= 1879048191 ? nN(t, nI().suffixes[e - 1811939328]) : 1399353956 == e ? {
                packedValues: l,
                structures: s.slice(0),
                version: t
            } : 55799 == e ? t : void 0);
            let nM = 1 == new Uint8Array(new Uint16Array([1]).buffer)[0],
                nW = [Uint8Array],
                nj = [64];
            for (let e = 0; e < nW.length; e++) ! function(e, t) {
                let n = "get" + e.name.slice(0, -5);
                "function" != typeof e && (e = null);
                let a = e.BYTES_PER_ELEMENT;
                for (let r = 0; r < 2; r++) {
                    if (!r && 1 == a) continue;
                    let i = 2 == a ? 1 : 4 == a ? 2 : 3;
                    nw[r ? t : t - 4] = 1 == a || r == nM ? n => {
                        if (!e) throw Error("Could not find typed array for code " + t);
                        return new e(Uint8Array.prototype.slice.call(n, 0).buffer)
                    } : a => {
                        if (!e) throw Error("Could not find typed array for code " + t);
                        let f = new DataView(a.buffer, a.byteOffset, a.byteLength),
                            s = a.length >> i,
                            o = new e(s),
                            c = f[n];
                        for (let e = 0; e < s; e++) o[e] = c.call(f, e << i, r);
                        return o
                    }
                }
            }(nW[e], nj[e]);

            function nU() {
                let e = 31 & i[np++];
                if (e > 23) switch (e) {
                    case 24:
                        e = i[np++];
                        break;
                    case 25:
                        e = u.getUint16(np), np += 2;
                        break;
                    case 26:
                        e = u.getUint32(np), np += 4
                }
                return e
            }

            function nV() {
                if (nh.getShared) {
                    let e = nH(() => (i = null, nh.getShared())) || {},
                        t = e.structures || [];
                    nh.sharedVersion = e.version, l = nh.sharedValues = e.packedValues, !0 === s ? nh.structures = s = t : s.splice.apply(s, [0, t.length].concat(t))
                }
            }

            function nH(e) {
                let t = f,
                    n = np,
                    a = nb,
                    r = ny,
                    l = o,
                    m = d,
                    p = c,
                    g = new Uint8Array(i.slice(0, f)),
                    h = s,
                    b = nh,
                    y = nC,
                    w = e();
                return f = t, np = n, nb = a, ny = r, o = l, d = m, c = p, i = g, nC = y, s = h, nh = b, u = new DataView(i.buffer, i.byteOffset, i.byteLength), w
            }

            function nG() {
                i = null, d = null, s = null
            }
            let nK = Array(147);
            for (let e = 0; e < 256; e++) nK[e] = Number("1e" + Math.floor(45.15 - .30103 * e));
            let nq = new nA({
                useRecords: !1
            }).decode;
            async function nJ(e, t) {
                let {
                    bytecode: n
                } = await nZ(e, t);
                return {
                    uri: function(e) {
                        let t = function(e) {
                                var t;
                                if ((e = e.toString(16)).startsWith("0x") || (e = `0x${e}`), !(("string" == typeof(t = e) || "number" == typeof t) && /^(-)?0x[0-9a-f]*$/i.test(t.toString()))) throw Error(`Given value "${e}" is not a valid hex string.`);
                                e = e.replace(/^0x/i, "");
                                let n = [];
                                for (let t = 0; t < e.length; t += 2) n.push(parseInt(e.slice(t, t + 2), 16));
                                return n
                            }(e),
                            n = 256 * t[t.length - 2] + t[t.length - 1],
                            a = nq(Uint8Array.from(t.slice(t.length - 2 - n, -2)));
                        if ("ipfs" in a && a.ipfs) try {
                            return `ipfs://${V().encode(a.ipfs)}`
                        } catch (e) {
                            console.warn("feature-detection ipfs cbor failed", e)
                        }
                    }(n),
                    bytecode: n
                }
            }
            async function nZ(e, t) {
                let [n, a] = await Promise.all([nX(e, t), nQ(e, t)]), r = function(e) {
                    if (e.startsWith("0x363d3d373d3d3d363d73")) {
                        let t = e.slice(22, 62);
                        return `0x${t}`
                    }
                    if (e.startsWith("0x36603057343d5230")) {
                        let t = e.slice(122, 162);
                        return `0x${t}`
                    }
                    if (e.startsWith("0x3d3d3d3d363d3d37363d73")) {
                        let t = e.slice(24, 64);
                        return `0x${t}`
                    }
                    if (e.startsWith("0x366000600037611000600036600073")) {
                        let t = e.slice(32, 72);
                        return `0x${t}`
                    }
                    if (e.startsWith("0x36600080376020600036600073")) {
                        let t = e.slice(28, 68);
                        return `0x${t}`
                    }
                    if (e.startsWith("0x365f5f375f5f365f73")) {
                        let t = e.slice(20, 60);
                        return `0x${t}`
                    }
                }(n);
                if (r) return {
                    address: r,
                    bytecode: await nX(r, t)
                };
                for (let n of (a && a !== v.d && (e = a), await Promise.all([nY(e, t), n0(e, t)])))
                    if (n && A.isAddress(n) && n !== v.d) try {
                        let e = await nX(n, t);
                        return {
                            address: n,
                            bytecode: e
                        }
                    } catch (e) {
                        if (e instanceof Error && !e.message.includes(`Contract at ${n} does not exist on chain`)) throw e
                    }
                return {
                    address: e,
                    bytecode: n
                }
            }
            async function nX(e, t) {
                try {
                    let n = await t.getCode(e);
                    if ("0x" === n) {
                        let n = await t.getNetwork();
                        throw Error(`Contract at ${e} does not exist on chain '${n.name}' (chainId: ${n.chainId})`)
                    }
                    return n
                } catch (t) {
                    throw Error(`Failed to get bytecode for address ${e}: ${t}`)
                }
            }
            async function nY(e, t) {
                try {
                    let n = await t.getStorageAt(e, z.O$.from("0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc"));
                    return `0x${n.slice(-40)}`
                } catch (e) {
                    return
                }
            }
            async function nQ(e, t) {
                try {
                    let n = await t.getStorageAt(e, z.O$.from("0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50"));
                    return `0x${n.slice(-40)}`
                } catch (e) {
                    return
                }
            }
            async function n0(e, t) {
                try {
                    let n = new x.CH(e, n1, t);
                    return await n.implementation()
                } catch (e) {
                    return
                }
            }
            let n1 = [{
                type: "function",
                name: "implementation",
                inputs: [],
                outputs: [{
                    type: "address",
                    name: "",
                    internalType: "address"
                }],
                stateMutability: "view"
            }];

            function n2(e, t) {
                let n = e.map(e => tJ.parse(e)).flat().filter(e => "constructor" !== e.type);
                t && n.push(...tJ.parse(t));
                let a = function(e, t) {
                    if (0 === e.length || 1 === e.length || !t) return e;
                    for (let n = 0; n < e.length; n++)
                        for (let a = n + 1; a < e.length; a++) t(e[n], e[a]) && (e.splice(a, 1), a--);
                    return e
                }(n, (e, t) => e.name === t.name && e.type === t.type && e.inputs.length === t.inputs.length);
                return tJ.parse(a)
            }
            let n5 = {
                    name: "ERC20ClaimConditionsV1",
                    namespace: "token.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc20dclaimable",
                        contracts: "erc20claimconditions"
                    },
                    abis: [Z, J],
                    features: {}
                },
                n6 = {
                    name: "ERC20ClaimConditionsV2",
                    namespace: "token.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc20dclaimable",
                        contracts: "erc20claimconditions"
                    },
                    abis: [Z, q],
                    features: {}
                },
                n8 = {
                    name: "ERC20ClaimPhasesV2",
                    namespace: "token.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc20dclaimable",
                        contracts: "erc20claimphases"
                    },
                    abis: [Z, G],
                    features: {}
                },
                n3 = {
                    name: "ERC20ClaimPhasesV1",
                    namespace: "token.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc20dclaimable",
                        contracts: "erc20claimphases"
                    },
                    abis: [K],
                    features: {}
                },
                n9 = {
                    name: "ERC20Burnable",
                    namespace: "token.burn",
                    docLinks: {
                        sdk: "sdk.erc20burnable",
                        contracts: "erc20burnable"
                    },
                    abis: [Z, H],
                    features: {}
                },
                n4 = {
                    name: "ERC20SignatureMintable",
                    namespace: "token.signature",
                    docLinks: {
                        sdk: "sdk.erc20signaturemintable",
                        contracts: "erc20signaturemint"
                    },
                    abis: [Z, ee],
                    features: {}
                },
                n7 = {
                    name: "ERC20BatchMintable",
                    namespace: "token.mint.batch",
                    docLinks: {
                        sdk: "sdk.erc20batchmintable",
                        contracts: "erc20batchmintable"
                    },
                    abis: [Z, Y, Q],
                    features: {}
                },
                ae = {
                    name: "ERC20Mintable",
                    namespace: "token.mint",
                    docLinks: {
                        sdk: "sdk.erc20mintable",
                        contracts: "erc20mintable"
                    },
                    abis: [Z, Y],
                    features: {
                        [n7.name]: n7
                    }
                },
                at = {
                    name: "ERC20Permit",
                    namespace: "token.permit",
                    docLinks: {
                        sdk: "sdk.erc20permit",
                        contracts: "erc20permit"
                    },
                    abis: [Z, X],
                    features: {}
                },
                an = {
                    name: "ERC20",
                    namespace: "token",
                    docLinks: {
                        sdk: "sdk.erc20",
                        contracts: "erc20"
                    },
                    abis: [Z, et],
                    features: {
                        [n9.name]: n9,
                        [ae.name]: ae,
                        [n5.name]: n5,
                        [n6.name]: n6,
                        [n3.name]: n3,
                        [n8.name]: n8,
                        [n4.name]: n4,
                        [at.name]: at
                    }
                },
                aa = {
                    name: "ERC721Burnable",
                    namespace: "nft.burn",
                    docLinks: {
                        sdk: "sdk.erc721burnable",
                        contracts: "erc721burnable"
                    },
                    abis: [ef, en],
                    features: {}
                },
                ar = {
                    name: "ERC721Revealable",
                    namespace: "nft.drop.revealer",
                    docLinks: {
                        sdk: "sdk.delayedreveal",
                        contracts: "erc721revealable"
                    },
                    abis: [ef, ed, er],
                    features: {}
                },
                ai = {
                    name: "ERC721TieredDrop",
                    namespace: "nft.tieredDrop",
                    docLinks: {
                        sdk: "sdk.erc721tiereddrop",
                        contracts: ""
                    },
                    abis: [ef, ep],
                    features: {}
                },
                af = {
                    name: "ERC721ClaimConditionsV1",
                    namespace: "nft.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc721claimable",
                        contracts: "erc721claimconditions"
                    },
                    abis: [ef, J],
                    features: {}
                },
                as = {
                    name: "ERC721ClaimConditionsV2",
                    namespace: "nft.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc721claimable",
                        contracts: "erc721claimconditions"
                    },
                    abis: [ef, q],
                    features: {}
                },
                ao = {
                    name: "ERC721ClaimPhasesV1",
                    namespace: "nft.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc721claimable",
                        contracts: "erc721claimphases"
                    },
                    abis: [ei],
                    features: {}
                },
                ac = {
                    name: "ERC721ClaimPhasesV2",
                    namespace: "nft.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc721claimable",
                        contracts: "erc721claimphases"
                    },
                    abis: [ef, G],
                    features: {}
                },
                ad = {
                    name: "ERC721ClaimCustom",
                    namespace: "nft.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc721claimable",
                        contracts: "erc721claimcustom"
                    },
                    abis: [ef, ea],
                    features: {}
                },
                al = {
                    name: "ERC721ClaimZora",
                    namespace: "nft.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc721claimable",
                        contracts: "erc721claimzora"
                    },
                    abis: [ef, eh],
                    features: {}
                },
                au = {
                    name: "ERC721LazyMintable",
                    namespace: "nft.drop",
                    docLinks: {
                        sdk: "sdk.erc721lazymintable",
                        contracts: "lazymint"
                    },
                    abis: [ef, ed],
                    features: {
                        [ar.name]: ar
                    }
                },
                am = {
                    name: "ERC721BatchMintable",
                    namespace: "nft.mint.batch",
                    docLinks: {
                        sdk: "sdk.erc721batchmintable",
                        contracts: "erc721batchmintable"
                    },
                    abis: [ef, el, Q],
                    features: {}
                },
                ap = {
                    name: "ERC721Mintable",
                    namespace: "nft.mint",
                    docLinks: {
                        sdk: "sdk.erc721mintable",
                        contracts: "erc721mintable"
                    },
                    abis: [ef, el],
                    features: {
                        [am.name]: am
                    }
                },
                ag = {
                    name: "ERC721SignatureMintV2",
                    namespace: "nft.signature",
                    docLinks: {
                        sdk: "sdk.erc721signaturemint",
                        contracts: "erc721signaturemint"
                    },
                    abis: [ef, eu],
                    features: {}
                },
                ah = {
                    name: "ERC721SignatureMintV1",
                    namespace: "nft.signature",
                    docLinks: {
                        sdk: "sdk.erc721signaturemint",
                        contracts: "erc721signaturemint"
                    },
                    abis: [em],
                    features: {}
                },
                ab = {
                    name: "ERC721Enumerable",
                    namespace: "nft.query.owned",
                    docLinks: {
                        sdk: "sdk.erc721enumerable",
                        contracts: "erc721enumerable"
                    },
                    abis: [ef, es],
                    features: {}
                },
                ay = {
                    name: "ERC721AQueryable",
                    namespace: "nft.query.owned",
                    docLinks: {
                        sdk: "",
                        contracts: ""
                    },
                    abis: [eo],
                    features: {}
                },
                aw = {
                    name: "ERC721Supply",
                    namespace: "nft.query",
                    docLinks: {
                        sdk: "sdk.erc721supply",
                        contracts: "erc721supply"
                    },
                    abis: [ef, ec],
                    features: {
                        [ab.name]: ab,
                        [ay.name]: ay
                    }
                },
                aE = {
                    name: "ERC721SharedMetadata",
                    namespace: "nft.sharedmetadata",
                    docLinks: {
                        sdk: "sdk.sharedmetadata",
                        contracts: "SharedMetadata"
                    },
                    abis: [ef, eg],
                    features: {}
                },
                ak = {
                    name: "ERC721LoyaltyCard",
                    namespace: "nft.loyaltyCard",
                    docLinks: {
                        sdk: "",
                        contracts: ""
                    },
                    abis: [eb],
                    features: {}
                },
                aC = {
                    name: "ERC721UpdatableMetadata",
                    namespace: "nft.metadata",
                    docLinks: {
                        sdk: "",
                        contracts: ""
                    },
                    abis: [ef, ey],
                    features: {}
                },
                aA = {
                    name: "ERC721",
                    namespace: "nft",
                    docLinks: {
                        sdk: "sdk.erc721",
                        contracts: "erc721"
                    },
                    abis: [ef, ew],
                    features: {
                        [aa.name]: aa,
                        [aw.name]: aw,
                        [ap.name]: ap,
                        [au.name]: au,
                        [ah.name]: ah,
                        [ag.name]: ag,
                        [ai.name]: ai,
                        [ad.name]: ad,
                        [al.name]: al,
                        [af.name]: af,
                        [as.name]: as,
                        [ao.name]: ao,
                        [ac.name]: ac,
                        [aE.name]: aE,
                        [ak.name]: ak,
                        [aC.name]: aC
                    }
                },
                az = {
                    name: "ERC1155Burnable",
                    namespace: "edition.burn",
                    docLinks: {
                        sdk: "sdk.erc1155burnable",
                        contracts: "erc1155burnable"
                    },
                    abis: [ex, eE],
                    features: {}
                },
                av = {
                    name: "ERC1155ClaimConditionsV1",
                    namespace: "edition.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc1155claimable",
                        contracts: "erc1155dropsinglephase"
                    },
                    abis: [ex, ev],
                    features: {}
                },
                ax = {
                    name: "ERC1155ClaimConditionsV2",
                    namespace: "edition.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc1155claimable",
                        contracts: "erc1155claimconditions"
                    },
                    abis: [ex, ez],
                    features: {}
                },
                aF = {
                    name: "ERC1155ClaimPhasesV2",
                    namespace: "edition.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc1155claimable",
                        contracts: "erc1155claimphases"
                    },
                    abis: [ex, eC],
                    features: {}
                },
                aS = {
                    name: "ERC1155ClaimPhasesV1",
                    namespace: "edition.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc1155claimable",
                        contracts: "erc1155claimphases"
                    },
                    abis: [eA],
                    features: {}
                },
                aT = {
                    name: "ERC1155ClaimCustom",
                    namespace: "edition.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc1155claimable",
                        contracts: "erc1155claimcustom"
                    },
                    abis: [ex, ek],
                    features: {}
                },
                aB = {
                    name: "ERC1155Revealable",
                    namespace: "edition.drop.revealer",
                    docLinks: {
                        sdk: "sdk.drop.delayedreveal",
                        contracts: "erc1155revealable"
                    },
                    abis: [ex, ed, er],
                    features: {}
                },
                aO = {
                    name: "ERC1155LazyMintableV2",
                    namespace: "edition.drop",
                    docLinks: {
                        sdk: "sdk.erc1155droppable",
                        contracts: "lazymint"
                    },
                    abis: [ex, ed],
                    features: {
                        [aB.name]: aB
                    }
                },
                a$ = {
                    name: "ERC1155LazyMintableV1",
                    namespace: "edition.drop",
                    docLinks: {
                        sdk: "sdk.erc1155droppable",
                        contracts: "lazymint"
                    },
                    abis: [eA],
                    features: {
                        [aS.name]: aS
                    }
                },
                a_ = {
                    name: "ERC1155SignatureMintable",
                    namespace: "edition.signature",
                    docLinks: {
                        sdk: "sdk.erc1155signaturemintable",
                        contracts: "erc1155signaturemint"
                    },
                    abis: [ex, eO],
                    features: {}
                },
                aR = {
                    name: "ERC1155BatchMintable",
                    namespace: "edition.mint.batch",
                    docLinks: {
                        sdk: "sdk.erc1155batchmintable",
                        contracts: "erc1155batchmintable"
                    },
                    abis: [ex, eB, Q],
                    features: {}
                },
                aD = {
                    name: "ERC1155Mintable",
                    namespace: "edition.mint",
                    docLinks: {
                        sdk: "sdk.erc1155mintable",
                        contracts: "erc1155mintable"
                    },
                    abis: [ex, eB],
                    features: {
                        [aR.name]: aR
                    }
                },
                aP = {
                    name: "ERC1155Enumerable",
                    namespace: "edition.query",
                    docLinks: {
                        sdk: "sdk.erc1155",
                        contracts: "erc1155enumerable"
                    },
                    abis: [ex, eT],
                    features: {}
                },
                aL = {
                    name: "ERC1155UpdatableMetadata",
                    namespace: "edition.metadata",
                    docLinks: {
                        sdk: "",
                        contracts: ""
                    },
                    abis: [ex, ey],
                    features: {}
                },
                aN = {
                    name: "ERC1155Supply",
                    namespace: "edition.supply",
                    docLinks: {
                        sdk: "",
                        contracts: ""
                    },
                    abis: [ex, eS],
                    features: {}
                },
                aI = {
                    name: "ERC1155",
                    namespace: "edition",
                    docLinks: {
                        sdk: "sdk.erc1155enumerable",
                        contracts: "erc1155"
                    },
                    abis: [ex, eF, [{
                        inputs: [],
                        name: "name",
                        outputs: [{
                            internalType: "string",
                            name: "",
                            type: "string"
                        }],
                        stateMutability: "view",
                        type: "function"
                    }, {
                        inputs: [],
                        name: "symbol",
                        outputs: [{
                            internalType: "string",
                            name: "",
                            type: "string"
                        }],
                        stateMutability: "view",
                        type: "function"
                    }]],
                    features: {
                        [aN.name]: aN,
                        [az.name]: az,
                        [aP.name]: aP,
                        [aD.name]: aD,
                        [a$.name]: a$,
                        [aO.name]: aO,
                        [aB.name]: aB,
                        [a_.name]: a_,
                        [aT.name]: aT,
                        [av.name]: av,
                        [ax.name]: ax,
                        [aF.name]: aF,
                        [aL.name]: aL
                    }
                },
                aM = [{
                    inputs: [],
                    name: "getAllPlugins",
                    outputs: [{
                        components: [{
                            internalType: "bytes4",
                            name: "functionSelector",
                            type: "bytes4"
                        }, {
                            internalType: "string",
                            name: "functionSignature",
                            type: "string"
                        }, {
                            internalType: "address",
                            name: "pluginAddress",
                            type: "address"
                        }],
                        internalType: "struct IPluginMap.Plugin[]",
                        name: "registered",
                        type: "tuple[]"
                    }],
                    stateMutability: "view",
                    type: "function"
                }],
                aW = [{
                    inputs: [],
                    name: "getAllExtensions",
                    outputs: [{
                        components: [{
                            components: [{
                                internalType: "string",
                                name: "name",
                                type: "string"
                            }, {
                                internalType: "string",
                                name: "metadataURI",
                                type: "string"
                            }, {
                                internalType: "address",
                                name: "implementation",
                                type: "address"
                            }],
                            internalType: "struct IExtension.ExtensionMetadata",
                            name: "metadata",
                            type: "tuple"
                        }, {
                            components: [{
                                internalType: "bytes4",
                                name: "functionSelector",
                                type: "bytes4"
                            }, {
                                internalType: "string",
                                name: "functionSignature",
                                type: "string"
                            }],
                            internalType: "struct IExtension.ExtensionFunction[]",
                            name: "functions",
                            type: "tuple[]"
                        }],
                        internalType: "struct IExtension.Extension[]",
                        name: "allExtensions",
                        type: "tuple[]"
                    }],
                    stateMutability: "view",
                    type: "function"
                }],
                aj = {
                    name: "Royalty",
                    namespace: "royalty",
                    docLinks: {
                        sdk: "sdk.contractroyalty",
                        contracts: "royalty"
                    },
                    abis: [eU],
                    features: {}
                },
                aU = {
                    name: "PrimarySale",
                    namespace: "sales",
                    docLinks: {
                        sdk: "sdk.contractprimarysale",
                        contracts: "primarysale"
                    },
                    abis: [ej],
                    features: {}
                },
                aV = {
                    name: "PlatformFee",
                    namespace: "platformFees",
                    docLinks: {
                        sdk: "sdk.platformfee",
                        contracts: "platformfee"
                    },
                    abis: [eW],
                    features: {}
                },
                aH = {
                    name: "PermissionsEnumerable",
                    namespace: "roles",
                    docLinks: {
                        sdk: "sdk.contractroles",
                        contracts: "permissionsenumerable"
                    },
                    abis: [eM],
                    features: {}
                },
                aG = {
                    name: "Permissions",
                    namespace: "roles",
                    docLinks: {
                        sdk: "sdk.contractroles",
                        contracts: "permissions"
                    },
                    abis: [eI],
                    features: {
                        [aH.name]: aH
                    }
                },
                aK = {
                    name: "ContractMetadata",
                    namespace: "metadata",
                    docLinks: {
                        sdk: "sdk.contractmetadata",
                        contracts: "contractmetadata"
                    },
                    abis: [eR],
                    features: {}
                },
                aq = {
                    name: "AppURI",
                    namespace: "appURI",
                    docLinks: {
                        sdk: "sdk.appURI",
                        contracts: ""
                    },
                    abis: [e_],
                    features: {}
                },
                aJ = {
                    name: "Ownable",
                    namespace: "owner",
                    docLinks: {
                        sdk: "sdk.owner",
                        contracts: "ownable"
                    },
                    abis: [eV],
                    features: {}
                },
                aZ = {
                    name: "Gasless",
                    namespace: "gasless",
                    docLinks: {
                        sdk: "sdk.gaslesstransaction",
                        contracts: "IERC2771Context"
                    },
                    abis: [e$],
                    features: {}
                },
                aX = {
                    name: "PackVRF",
                    namespace: "pack.vrf",
                    docLinks: {
                        sdk: "sdk.packvrf",
                        contracts: "IPackVRF"
                    },
                    abis: [eN],
                    features: {}
                },
                aY = {
                    name: "PluginRouter",
                    namespace: "plugin.router",
                    docLinks: {
                        sdk: "sdk.pluginrouter",
                        contracts: "PluginRouter"
                    },
                    abis: [aM],
                    features: {}
                },
                aQ = {
                    name: "DynamicContract",
                    namespace: "dynamic.contract",
                    docLinks: {
                        sdk: "",
                        contracts: "IExtensionsManager"
                    },
                    abis: [aW],
                    features: {}
                },
                a0 = {
                    name: "DirectListings",
                    namespace: "direct.listings",
                    docLinks: {
                        sdk: "",
                        contracts: "IDirectListings"
                    },
                    abis: [eD],
                    features: {}
                },
                a1 = {
                    name: "EnglishAuctions",
                    namespace: "english.auctions",
                    docLinks: {
                        sdk: "",
                        contracts: "IEnglishAuctions"
                    },
                    abis: [eP],
                    features: {}
                },
                a2 = {
                    name: "Offers",
                    namespace: "offers",
                    docLinks: {
                        sdk: "",
                        contracts: "IOffers"
                    },
                    abis: [eL],
                    features: {}
                },
                a5 = {
                    name: "AccountFactory",
                    namespace: "accountFactory",
                    docLinks: {
                        sdk: "sdk.accountFactory",
                        contracts: "IAccountFactory"
                    },
                    abis: [eq],
                    features: {}
                },
                a6 = {
                    name: "AccountPermissionsV1",
                    namespace: "accountPermissions",
                    docLinks: {
                        sdk: "sdk.account",
                        contracts: "IAccountPermissions"
                    },
                    abis: [eZ],
                    features: {}
                },
                a8 = {
                    name: "AccountPermissions",
                    namespace: "accountPermissions",
                    docLinks: {
                        sdk: "sdk.account",
                        contracts: "IAccountPermissions"
                    },
                    abis: [eJ],
                    features: {}
                },
                a3 = {
                    name: "Account",
                    namespace: "account",
                    docLinks: {
                        sdk: "sdk.account",
                        contracts: "IAccount"
                    },
                    abis: [eX],
                    features: {
                        [a8.name]: a8,
                        [a6.name]: a6
                    }
                },
                a9 = {
                    name: "AirdropERC20",
                    namespace: "airdrop20",
                    docLinks: {
                        sdk: "",
                        contracts: "IAirdropERC20"
                    },
                    abis: [eH],
                    features: {}
                },
                a4 = {
                    name: "AirdropERC721",
                    namespace: "airdrop721",
                    docLinks: {
                        sdk: "",
                        contracts: "IAirdropERC721"
                    },
                    abis: [eG],
                    features: {}
                },
                a7 = {
                    name: "AirdropERC1155",
                    namespace: "airdrop1155",
                    docLinks: {
                        sdk: "",
                        contracts: "IAirdropERC1155"
                    },
                    abis: [eK],
                    features: {}
                },
                re = {
                    name: "Fallback",
                    namespace: "fallback",
                    docLinks: {
                        sdk: "",
                        contracts: ""
                    },
                    abis: [
                        [{
                            stateMutability: "payable",
                            type: "fallback"
                        }]
                    ],
                    features: {}
                },
                rt = {
                    [an.name]: an,
                    [aA.name]: aA,
                    [aI.name]: aI,
                    [aj.name]: aj,
                    [aV.name]: aV,
                    [aU.name]: aU,
                    [aG.name]: aG,
                    [aK.name]: aK,
                    [aq.name]: aq,
                    [aJ.name]: aJ,
                    [aZ.name]: aZ,
                    [aX.name]: aX,
                    [aY.name]: aY,
                    [aQ.name]: aQ,
                    [a0.name]: a0,
                    [a1.name]: a1,
                    [a2.name]: a2,
                    [a9.name]: a9,
                    [a4.name]: a4,
                    [a7.name]: a7,
                    [a5.name]: a5,
                    [a3.name]: a3,
                    [ak.name]: ak,
                    [aC.name]: aC,
                    [re.name]: re
                };

            function rn(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                    n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                    a = e.type,
                    r = !1;
                return a.endsWith("[]") && (r = !0, a = a.slice(0, -2)), a.startsWith("bytes") && (a = "BytesLike"), (a.startsWith("uint") || a.startsWith("int")) && (a = t ? "BigNumber" : "BigNumberish"), a.startsWith("bool") && (a = "boolean"), "address" === a && (a = "string"), "tuple" === a && e.components && (a = `{ ${e.components.map(e=>rn(e,!1,!0)).join(", ")} }`), r && (a += "[]"), n && (a = `${e.name}: ${a}`), a
            }

            function ra(e, t) {
                let n = (e || []).filter(e => "function" === e.type),
                    a = [];
                for (let e of n) {
                    let n = function(e, t, n) {
                            return t ? .output ? .userdoc ? .[n] ? .[Object.keys(t ? .output ? .userdoc[n] || {}).find(t => t.includes(e || "unknown")) || ""] ? .notice || t ? .output ? .devdoc ? .[n] ? .[Object.keys(t ? .output ? .devdoc[n] || {}).find(t => t.includes(e || "unknown")) || ""] ? .details
                        }(e.name, t, "methods"),
                        r = e.inputs ? .map(e => `${e.name||"key"}: ${rn(e)}`) ? .join(", ") || "",
                        i = r ? `, [${r}]` : "",
                        f = e.outputs ? .map(e => rn(e, !0)) ? .join(", "),
                        s = f ? `: Promise<${f}>` : ": Promise<TransactionResult>",
                        o = `contract.call("${e.name}"${i})${s}`;
                    a.push({
                        inputs: e.inputs || [],
                        outputs: e.outputs || [],
                        name: e.name || "unknown",
                        signature: o,
                        stateMutability: e.stateMutability || "",
                        comment: n
                    })
                }
                return a
            }
            let rr = ns(10);

            function ri(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : rt,
                    n = JSON.stringify(e);
                if (rr.has(n)) return rr.get(n);
                let a = function e(t, n) {
                    let a = {};
                    for (let r in n) {
                        let i = n[r],
                            f = function(e, t) {
                                let n = ra(e),
                                    a = t.flatMap(e => ra(e));
                                return n.filter(e => void 0 !== a.find(t => t.name === e.name && t.inputs.length === e.inputs.length && t.inputs.every((t, n) => "tuple" === t.type || "tuple[]" === t.type ? t.type === e.inputs[n].type && t.components ? .every((t, a) => t.type === e.inputs[n].components ? .[a] ? .type) : t.type === e.inputs[n].type))).length === a.length
                            }(t, i.abis),
                            s = e(t, i.features);
                        a[r] = { ...i,
                            features: s,
                            enabled: f
                        }
                    }
                    return a
                }(e, t);
                return rr.put(n, a), a
            }
            let rf = ns(20);

            function rs(e, t) {
                return rf.get(`${e}-${t}`)
            }
            async function ro(e, t, n) {
                let a, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},
                    i = (await t.getNetwork()).chainId,
                    f = rs(e, i);
                if (f) return f;
                if (!(31337 === i || 1337 === i)) try {
                    let t = await fetch(`https://contract.thirdweb.com/metadata/${i}/${e}`, {
                        headers: { ... function() {
                                let e = tn();
                                return {
                                    "x-sdk-version": e.x_sdk_version,
                                    "x-sdk-os": e.x_sdk_os,
                                    "x-sdk-name": e.x_sdk_name,
                                    "x-sdk-platform": e.x_sdk_platform,
                                    ...e.app_bundle_id ? {
                                        "x-bundle-id": e.app_bundle_id
                                    } : {}
                                }
                            }()
                        }
                    });
                    if (t.ok) {
                        let e = await t.json();
                        a = nn(e)
                    }
                } catch (e) {}
                if (a || (a = await rc(e, i, t, n, r)), !a) throw Error(`Could not resolve contract. Try importing it by visiting: https://thirdweb.com/${i}/${e}`);
                if (a.isPartialAbi) console.warn(`Contract metadata could only be partially resolved, some contract functions might be unavailable. Try importing the contract by visiting: https://thirdweb.com/${i}/${e}`);
                else {
                    var s;
                    s = a, rf.put(`${e}-${i}`, s)
                }
                return a
            }
            async function rc(e, t, n, a) {
                let r, i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {},
                    [f, s] = await Promise.all([nJ(e, n).catch(() => void 0), rd(e, t, i).then(e => {
                        if (e) return {
                            uri: e,
                            bytecode: ""
                        }
                    }).catch(() => void 0)]),
                    o = f ? .bytecode,
                    c = s ? .uri || f ? .uri;
                if (!c && !o) throw Error(`Could not fetch bytecode for contract at ${e} on chain ${t}, double check that the address and chainId are correct.`);
                try {
                    r = await nt(c, a)
                } catch (e) {}
                if (!r && o) {
                    let e;
                    let t = ((e = function(e) {
                        let t = [];
                        return function e(t, n) {
                            if (t)
                                for (let a in t) {
                                    let r = t[a];
                                    r.enabled && n.push(r), e(r.features, n)
                                }
                        }(function e(t) {
                            let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : rt,
                                a = {};
                            for (let r in n) {
                                let i = n[r],
                                    f = function(e, t) {
                                        return [...new Set(t.map(e => new eY.Interface(e)).flatMap(e => Object.values(e.functions).map(t => Number(e.getSighash(t)).toString(16))))].every(t => e.includes(t))
                                    }(t, i.abis),
                                    s = e(t, i.features);
                                a[r] = { ...i,
                                    features: s,
                                    enabled: f
                                }
                            }
                            return a
                        }(e), t), t
                    }(o)).find(e => "ERC721" === e.name) && (e = e.filter(e => "ERC20" !== e.name)), n2(e.map(e => n2(e.abis))));
                    t && t.length > 0 && (r = {
                        name: "Unimported Contract",
                        abi: t,
                        metadata: {},
                        info: {},
                        licenses: [],
                        isPartialAbi: !0
                    })
                }
                return r
            }
            async function rd(e, t, a) {
                let r = (await n.e(66986).then(n.t.bind(n, 66986, 19))).default;
                if (!p) {
                    let e = a ? .supportedChains ? .find(e => 137 === e.chainId) || I.mgq;
                    p = new x.CH(e2("multiChainRegistryAddress", "0xcdAD8FA86e18538aC207872E8ff3536501431B73"), r, tr(e, a))
                }
                return await p.getMetadataUri(t, e)
            }
            let rl = ["eip-155", "eip155", "protected", "invalid chain id for signer", "chain id none", "chain_id mismatch", "recovered sender mismatch", "transaction hash mismatch", "chainid no support", "chainid (0)", "chainid(0)"],
                ru = [
                    ["account", "not found"],
                    ["wrong", "chainid"]
                ],
                rm = [1, 1 * 1e9, 100 * 1e9, 500 * 1e9, 1e3 * 1e9, 2500 * 1e9, 5e3 * 1e9, 7500 * 1e9, 1e13, 25e12, 5e13, 75e12, 1e14, 25e13, 5e14, 75e13, 1e15],
                rp = {
                    5001: {
                        name: "Mantle Testnet",
                        gasPrice: 1
                    },
                    71402: {
                        name: "Godwoken Mainnet",
                        gasPrice: 4e4 * 1e9
                    },
                    1351057110: {
                        name: "Chaos (SKALE Testnet)",
                        gasPrice: 1e5
                    },
                    361: {
                        name: "Theta Mainnet",
                        gasPrice: 4e3 * 1e9
                    },
                    365: {
                        name: "Theta Testnet",
                        gasPrice: 4e3 * 1e9
                    },
                    7700: {
                        name: "Canto",
                        gasPrice: 1e3 * 1e9
                    },
                    7701: {
                        name: "Canto Testnet",
                        gasPrice: 1e3 * 1e9
                    },
                    338: {
                        name: "Cronos Testnet",
                        gasPrice: 2e3 * 1e9
                    },
                    47: {
                        name: "Xpla Testnet",
                        gasPrice: 850 * 1e9
                    },
                    37: {
                        name: "Xpla Mainnet",
                        gasPrice: 5100 * 1e9
                    },
                    199: {
                        name: "BitTorrent Chain",
                        gasPrice: 3e5 * 1e9
                    },
                    88882: {
                        name: "Spicy Chain",
                        gasPrice: 2500 * 1e9,
                        gasLimit: 2e5
                    },
                    88888: {
                        name: "Chiliz Chain",
                        gasPrice: 2500 * 1e9,
                        gasLimit: 2e5
                    }
                };

            function rg(e) {
                return !!rl.some(t => e.includes(t)) || ru.some(t => t.some(t => e.includes(t)))
            }
            let rh = {
                v: 27,
                r: "0x2222222222222222222222222222222222222222222222222222222222222222",
                s: "0x2222222222222222222222222222222222222222222222222222222222222222"
            };
            async function rb(e, t) {
                let n = await t.getCode(e);
                return "0x" !== n && "0x0" !== n
            }
            async function ry(e) {
                try {
                    await e.sendTransaction("0xf8a58085174876e800830186a08080b853604580600e600039806000f350fe7fffffffffffffffafffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf31ba02222222222222222222222222222222222222222222222222222222222222222a02222222222222222222222222222222222222222222222222222222222222222")
                } catch (n) {
                    let e = n.toString().toLowerCase(),
                        t = JSON.stringify(n).toLowerCase();
                    if (rg(e) || rg(t)) return !0
                }
                return !1
            }

            function rw(e, t) {
                let n = S.joinSignature(rh),
                    a = t.gasPrice ? t.gasPrice : 100 * 1e9,
                    r = t.gasLimit ? t.gasLimit : 1e5,
                    i = function(e, t) {
                        let n = S.arrayify(T.keccak256(B.serialize(e)));
                        return {
                            signer: B.recoverAddress(n, t),
                            transaction: B.serialize(e, t)
                        }
                    }({
                        gasPrice: a,
                        gasLimit: r,
                        nonce: 0,
                        data: "0x604580600e600039806000f350fe7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf3",
                        chainId: e
                    }, n),
                    f = A.getContractAddress({
                        from: i.signer,
                        nonce: 0
                    });
                return { ...i,
                    deployment: f,
                    valueToSend: z.O$.from(a).mul(r)
                }
            }
            async function rE(e) {
                return (await rk(e)).deployment
            }
            async function rk(e) {
                let t = (await e.getNetwork()).chainId;
                if (rp[t]) {
                    let n = await ry(e) ? t : 0,
                        a = rp[t] ? .gasPrice,
                        r = rp[t] ? .gasLimit,
                        i = rw(n, {
                            gasPrice: a ? z.O$.from(a) : void 0,
                            gasLimit: r ? z.O$.from(r) : void 0
                        });
                    return await rb(i.deployment, e) && (i.transaction = ""), i
                }
                let n = [...rm.map(e => rw(t, {
                        gasPrice: z.O$.from(e)
                    })), ...rm.map(e => rw(0, {
                        gasPrice: z.O$.from(e)
                    }))],
                    a = await Promise.all(n.map(t => rb(t.deployment, e))),
                    r = n.findIndex(e => "0x4e59b44847b379578588920cA78FbF26c0B4956C" === e.deployment);
                if (r && a[r]) return { ...n[r],
                    transaction: ""
                };
                let i = a.findIndex(e => e);
                if (i && n[i]) return { ...n[i],
                    transaction: ""
                };
                let [f, s] = await Promise.all([ry(e), e.getGasPrice()]);
                return rw(f ? t : 0, {
                    gasPrice: function(e) {
                        let t = rm.find(t => z.O$.from(t).gte(e));
                        return t ? z.O$.from(t) : e
                    }(s)
                })
            }
            let rC = "0x60606040526040805190810160405280600d81526020017f57726170706564204574686572000000000000000000000000000000000000008152506000908051906020019061004f9291906100c8565b506040805190810160405280600481526020017f57455448000000000000000000000000000000000000000000000000000000008152506001908051906020019061009b9291906100c8565b506012600260006101000a81548160ff021916908360ff16021790555034156100c357600080fd5b61016d565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061010957805160ff1916838001178555610137565b82800160010185558215610137579182015b8281111561013657825182559160200191906001019061011b565b5b5090506101449190610148565b5090565b61016a91905b8082111561016657600081600090555060010161014e565b5090565b90565b610c348061017c6000396000f3006060604052600436106100af576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806306fdde03146100b9578063095ea7b31461014757806318160ddd146101a157806323b872dd146101ca5780632e1a7d4d14610243578063313ce5671461026657806370a082311461029557806395d89b41146102e2578063a9059cbb14610370578063d0e30db0146103ca578063dd62ed3e146103d4575b6100b7610440565b005b34156100c457600080fd5b6100cc6104dd565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561010c5780820151818401526020810190506100f1565b50505050905090810190601f1680156101395780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561015257600080fd5b610187600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190505061057b565b604051808215151515815260200191505060405180910390f35b34156101ac57600080fd5b6101b461066d565b6040518082815260200191505060405180910390f35b34156101d557600080fd5b610229600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190505061068c565b604051808215151515815260200191505060405180910390f35b341561024e57600080fd5b61026460048080359060200190919050506109d9565b005b341561027157600080fd5b610279610b05565b604051808260ff1660ff16815260200191505060405180910390f35b34156102a057600080fd5b6102cc600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610b18565b6040518082815260200191505060405180910390f35b34156102ed57600080fd5b6102f5610b30565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561033557808201518184015260208101905061031a565b50505050905090810190601f1680156103625780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561037b57600080fd5b6103b0600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091908035906020019091905050610bce565b604051808215151515815260200191505060405180910390f35b6103d2610440565b005b34156103df57600080fd5b61042a600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610be3565b6040518082815260200191505060405180910390f35b34600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055503373ffffffffffffffffffffffffffffffffffffffff167fe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c346040518082815260200191505060405180910390a2565b60008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156105735780601f1061054857610100808354040283529160200191610573565b820191906000526020600020905b81548152906001019060200180831161055657829003601f168201915b505050505081565b600081600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040518082815260200191505060405180910390a36001905092915050565b60003073ffffffffffffffffffffffffffffffffffffffff1631905090565b600081600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054101515156106dc57600080fd5b3373ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff16141580156107b457507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205414155b156108cf5781600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015151561084457600080fd5b81600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055505b81600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254039250508190555081600360008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a3600190509392505050565b80600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410151515610a2757600080fd5b80600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055503373ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f193505050501515610ab457600080fd5b3373ffffffffffffffffffffffffffffffffffffffff167f7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65826040518082815260200191505060405180910390a250565b600260009054906101000a900460ff1681565b60036020528060005260406000206000915090505481565b60018054600181600116156101000203166002900480601f016020809104026020016040519081016040528092919081815260200182805460018160011615610100020316600290048015610bc65780601f10610b9b57610100808354040283529160200191610bc6565b820191906000526020600020905b815481529060010190602001808311610ba957829003601f168201915b505050505081565b6000610bdb33848461068c565b905092915050565b60046020528160005260406000206020528060005260406000206000915091505054815600a165627a7a72305820deb4c2ccab3c2fdca32ab3f46728389c2fe2c165d5fafa07661e4e004f6c344a0029";

            function rA(e) {
                let t = e.startsWith("0x") ? e : `0x${e}`,
                    n = O.id(t),
                    a = `tw.${n}`;
                return O.id(a)
            }

            function rz(e, t, n) {
                let a = e.startsWith("0x") ? e : `0x${e}`,
                    r = n ? O.id(n) : rA(a);
                return $.pack(["bytes32", "bytes", "bytes"], [r, a, t])
            }

            function rv(e, t, n, a) {
                let r = e.startsWith("0x") ? e : `0x${e}`,
                    i = a ? O.id(a) : rA(r),
                    f = $.pack(["bytes", "bytes"], [r, t]),
                    s = $.pack(["bytes1", "address", "bytes32", "bytes32"], ["0xff", n, i, $.keccak256(["bytes"], [f])]),
                    o = $.keccak256(["bytes"], [s]);
                return `0x${o.slice(26)}`
            }
            let rx = ((g = {})[g.Mainnet = 1] = "Mainnet", g[g.Goerli = 5] = "Goerli", g[g.Polygon = 137] = "Polygon", g[g.Mumbai = 80001] = "Mumbai", g[g.Localhost = 1337] = "Localhost", g[g.Hardhat = 31337] = "Hardhat", g[g.Fantom = 250] = "Fantom", g[g.FantomTestnet = 4002] = "FantomTestnet", g[g.Avalanche = 43114] = "Avalanche", g[g.AvalancheFujiTestnet = 43113] = "AvalancheFujiTestnet", g[g.Optimism = 10] = "Optimism", g[g.OptimismGoerli = 420] = "OptimismGoerli", g[g.Arbitrum = 42161] = "Arbitrum", g[g.ArbitrumGoerli = 421613] = "ArbitrumGoerli", g[g.BinanceSmartChainMainnet = 56] = "BinanceSmartChainMainnet", g[g.BinanceSmartChainTestnet = 97] = "BinanceSmartChainTestnet", g),
                rF = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
                rS = {
                    [rx.Mainnet]: {
                        name: "Ether",
                        symbol: "ETH",
                        decimals: 18,
                        wrapped: {
                            address: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    [rx.Goerli]: {
                        name: "G\xf6rli Ether",
                        symbol: "GOR",
                        decimals: 18,
                        wrapped: {
                            address: "0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    11155111: {
                        name: "Sepolia Ether",
                        symbol: "SEP",
                        decimals: 18,
                        wrapped: {
                            address: "0x7b79995e5f793A07Bc00c21412e50Ecae098E7f9",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    [rx.Polygon]: {
                        name: "Matic",
                        symbol: "MATIC",
                        decimals: 18,
                        wrapped: {
                            address: "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270",
                            name: "Wrapped Matic",
                            symbol: "WMATIC"
                        }
                    },
                    [rx.Mumbai]: {
                        name: "Matic",
                        symbol: "MATIC",
                        decimals: 18,
                        wrapped: {
                            address: "0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889",
                            name: "Wrapped Matic",
                            symbol: "WMATIC"
                        }
                    },
                    [rx.Avalanche]: {
                        name: "Avalanche",
                        symbol: "AVAX",
                        decimals: 18,
                        wrapped: {
                            address: "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7",
                            name: "Wrapped AVAX",
                            symbol: "WAVAX"
                        }
                    },
                    [rx.AvalancheFujiTestnet]: {
                        name: "Avalanche",
                        symbol: "AVAX",
                        decimals: 18,
                        wrapped: {
                            address: "0xd00ae08403B9bbb9124bB305C09058E32C39A48c",
                            name: "Wrapped AVAX",
                            symbol: "WAVAX"
                        }
                    },
                    [rx.Fantom]: {
                        name: "Fantom",
                        symbol: "FTM",
                        decimals: 18,
                        wrapped: {
                            address: "0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83",
                            name: "Wrapped Fantom",
                            symbol: "WFTM"
                        }
                    },
                    [rx.FantomTestnet]: {
                        name: "Fantom",
                        symbol: "FTM",
                        decimals: 18,
                        wrapped: {
                            address: "0xf1277d1Ed8AD466beddF92ef448A132661956621",
                            name: "Wrapped Fantom",
                            symbol: "WFTM"
                        }
                    },
                    [rx.Arbitrum]: {
                        name: "Ether",
                        symbol: "ETH",
                        decimals: 18,
                        wrapped: {
                            address: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    [rx.ArbitrumGoerli]: {
                        name: "Arbitrum Goerli Ether",
                        symbol: "AGOR",
                        decimals: 18,
                        wrapped: {
                            address: "0xe39Ab88f8A4777030A534146A9Ca3B52bd5D43A3",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    [rx.Optimism]: {
                        name: "Ether",
                        symbol: "ETH",
                        decimals: 18,
                        wrapped: {
                            address: "0x4200000000000000000000000000000000000006",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    [rx.OptimismGoerli]: {
                        name: "Goerli Ether",
                        symbol: "ETH",
                        decimals: 18,
                        wrapped: {
                            address: "0x4200000000000000000000000000000000000006",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    [rx.BinanceSmartChainMainnet]: {
                        name: "Binance Chain Native Token",
                        symbol: "BNB",
                        decimals: 18,
                        wrapped: {
                            address: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
                            name: "Wrapped Binance Chain Token",
                            symbol: "WBNB"
                        }
                    },
                    [rx.BinanceSmartChainTestnet]: {
                        name: "Binance Chain Native Token",
                        symbol: "TBNB",
                        decimals: 18,
                        wrapped: {
                            address: "0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd",
                            name: "Wrapped Binance Chain Testnet Token",
                            symbol: "WBNB"
                        }
                    },
                    [rx.Hardhat]: {
                        name: "Ether",
                        symbol: "ETH",
                        decimals: 18,
                        wrapped: {
                            address: "0x5FbDB2315678afecb367f032d93F642f64180aa3",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    [rx.Localhost]: {
                        name: "Ether",
                        symbol: "ETH",
                        decimals: 18,
                        wrapped: {
                            address: "0x5FbDB2315678afecb367f032d93F642f64180aa3",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    84531: {
                        name: "Base Goerli Testnet",
                        symbol: "ETH",
                        decimals: 18,
                        wrapped: {
                            address: "0x4200000000000000000000000000000000000006",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    280: {
                        name: "zkSync Era Testnet",
                        symbol: "ETH",
                        decimals: 18,
                        wrapped: {
                            address: "0x5AEa5775959fBC2557Cc8789bC1bf90A239D9a91",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    }
                };

            function rT(e) {
                let t = nd.find(t => t.chainId === e);
                return t && t.nativeCurrency ? {
                    name: t.nativeCurrency.name,
                    symbol: t.nativeCurrency.symbol,
                    decimals: 18,
                    wrapped: {
                        address: v.d,
                        name: `Wrapped ${t.nativeCurrency.name}`,
                        symbol: `W${t.nativeCurrency.symbol}`
                    }
                } : rS[e] || {
                    name: "Ether",
                    symbol: "ETH",
                    decimals: 18,
                    wrapped: {
                        address: v.d,
                        name: "Wrapped Ether",
                        symbol: "WETH"
                    }
                }
            }
            let rB = {
                    [rx.Mainnet]: "0x514910771AF9Ca656af840dff83E8264EcF986CA",
                    [rx.Goerli]: "0x326C977E6efc84E512bB9C30f76E30c160eD06FB",
                    [rx.BinanceSmartChainMainnet]: "0x404460C6A5EdE2D891e8297795264fDe62ADBB75",
                    [rx.Polygon]: "0xb0897686c545045aFc77CF20eC7A532E3120E0F1",
                    [rx.Mumbai]: "0x326C977E6efc84E512bB9C30f76E30c160eD06FB",
                    [rx.Avalanche]: "0x5947BB275c521040051D82396192181b413227A3",
                    [rx.AvalancheFujiTestnet]: "0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846",
                    [rx.Fantom]: "0x6F43FF82CCA38001B6699a8AC47A2d0E66939407",
                    [rx.FantomTestnet]: "0xfaFedb041c0DD4fA2Dc0d87a6B0979Ee6FA7af5F"
                },
                rO = {
                    deploymentPresets: {}
                },
                r$ = {
                    [rx.Mainnet]: "0x0385603ab55642cb4dd5de3ae9e306809991804f",
                    [rx.Goerli]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
                    [rx.BinanceSmartChainMainnet]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
                    [rx.Polygon]: "0x28EdFcF0Be7E86b07493466e7631a213bDe8eEF2",
                    [rx.Mumbai]: "0x0a01E11887f727D1b1Cd81251eeEE9BEE4262D07",
                    [rx.Avalanche]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
                    [rx.Optimism]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
                    [rx.Arbitrum]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15"
                },
                r_ = "0x0000000000000000000000000000000000000000";
            async function rR(e, t, n, a, r, i, f) {
                let s = r && r.contractName,
                    o = r && r.version,
                    c = r && r.publisherAddress,
                    d = r && r.metadata;
                if ((0, M.Z)(s || d, "Require contract name or metadata"), s && rO.deploymentPresets[s]) return rO.deploymentPresets[s];
                if ("WETH9" === s) {
                    let n = rv(rC, [], a),
                        r = await rb(n, t),
                        i = "";
                    return r || (i = rz(rC, [])), {
                        name: s,
                        type: e,
                        transaction: {
                            predictedAddress: n,
                            to: a,
                            data: i
                        }
                    }
                }
                if (!d) {
                    (0, M.Z)(s, "Require contract name"), c || (c = nl);
                    let e = await nu(c, s, o, n, i, f);
                    d = (await nc(e.metadataUri, n)).compilerMetadata
                }
                let l = await rD(d, t, n, a, r ? .constructorParams, i, f),
                    u = rv(d.bytecode, l, a),
                    m = await rb(u, t),
                    p = "";
                return m || (p = rz(d.bytecode, l)), {
                    name: s,
                    type: e,
                    transaction: {
                        predictedAddress: u,
                        to: a,
                        data: p
                    },
                    encodedArgs: l
                }
            }
            async function rD(e, t, n, a, r, i, f) {
                let s = function(e) {
                        for (let t of tJ.parse(e || []))
                            if ("constructor" === t.type) return t.inputs || [];
                        return []
                    }(e.abi),
                    o = s.map(e => "tuple[]" === e.type || "tuple" === e.type ? _._R.from(e) : e.type),
                    c = await Promise.all(s.map(async s => {
                        if (r && r[s.name]) return r[s.name].type && (0, M.Z)(r[s.name].type === s.type, `Provided type ${r[s.name].type} doesn't match the actual type ${s.type} from Abi`), r[s.name].value;
                        if (s.name && s.name.includes("nativeTokenWrapper")) return await rP(t, n, a, i, f);
                        if (s.name && s.name.includes("trustedForwarder")) {
                            if ("Pack" === e.name) return r_;
                            let r = await rR("infra", t, n, a, {
                                contractName: "Forwarder"
                            }, i, f);
                            return rO.deploymentPresets.Forwarder || (rO.deploymentPresets.Forwarder = r), r.transaction.predictedAddress
                        }
                        if (s.name && s.name.includes("royaltyEngineAddress")) return r$[(await t.getNetwork()).chainId] || v.d;
                        if (s.name && s.name.includes("marketplaceV3Params")) {
                            let e = r$[(await t.getNetwork()).chainId] || v.d,
                                s = await rP(t, n, a, i, f);
                            return {
                                extensions: r ? r._extensions.value : [],
                                royaltyEngineAddress: e,
                                nativeTokenWrapper: s
                            }
                        }
                        throw Error("Can't resolve constructor arguments")
                    }));
                return R.$.encode(o, c)
            }
            async function rP(e, t, n, a, r) {
                let i = rT((await e.getNetwork()).chainId).wrapped.address;
                if (i === v.d) {
                    let f = await rR("infra", e, t, n, {
                        contractName: "WETH9"
                    }, a, r);
                    rO.deploymentPresets.WETH9 || (rO.deploymentPresets.WETH9 = f), i = f.transaction.predictedAddress
                }
                return i
            }
            async function rL(e, t, n, a, r) {
                return n && "" !== n || (n = await rE(e)), (await rR("infra", e, t, n, {
                    contractName: "ForwarderEOAOnly"
                }, a, r)).transaction.predictedAddress
            }
            async function rN(e, t, n, a, r) {
                return n && "" !== n || (n = await rE(e)), (await rR("infra", e, t, n, {
                    contractName: "Forwarder"
                }, a, r)).transaction.predictedAddress
            }
            class rI extends Error {
                constructor(e) {
                    super(e ? `Object with id ${e} NOT FOUND` : "NOT_FOUND")
                }
            }
            class rM extends Error {
                constructor(e, t) {
                    super(`MISSING ROLE: ${e} does not have the '${t}' role`)
                }
            }
            class rW extends Error {
                constructor(e) {
                    super(`DUPLICATE_LEAFS${e?` : ${e}`:""}`)
                }
            }
            class rj extends Error {
                constructor(e) {
                    super(`Auction already started with existing bid${e?`, id: ${e}`:""}`)
                }
            }
            class rU extends Error {
                constructor(e, t) {
                    super(`Could not find listing.${e?` marketplace address: ${e}`:""}${t?` listing id: ${t}`:""}`)
                }
            }
            class rV extends Error {
                constructor(e, t, n, a) {
                    super(`Incorrect listing type. Are you sure you're using the right method?.${e?` marketplace address: ${e}`:""}${t?` listing id: ${t}`:""}${a?` expected type: ${a}`:""}${n?` actual type: ${n}`:""}`)
                }
            }
            class rH extends Error {
                constructor(e, t) {
                    super(`Auction has not ended yet${e?`, id: ${e}`:""}${t?`, end time: ${t.toString()}`:""}`)
                }
            }
            class rG extends Error {
                constructor(e) {
                    super(`This functionality is not available because the contract does not implement the '${e.name}' Extension. Learn how to unlock this functionality at https://portal.thirdweb.com/contracts/build/extensions `)
                }
            }
            class rK extends Error {
                constructor(e, t) {
                    let n = `


╔═══════════════════╗
║ TRANSACTION ERROR ║
╚═══════════════════╝

`;
                    if (n += `Reason: ${e.reason}


╔═════════════════════════╗
║ TRANSACTION INFORMATION ║
╚═════════════════════════╝
` + rJ("from", e.from), e.to && (n += rJ("to", e.contractName ? `${e.to} (${e.contractName})` : e.to)), n += rJ("chain", `${e.network.name} (${e.network.chainId})`), e.rpcUrl) try {
                        let t = new URL(e.rpcUrl);
                        n += rJ("rpc", t.hostname)
                    } catch (e) {}
                    if (e.hash && (n += rJ("tx hash", e.hash)), e.value && e.value.gt(0) && (n += rJ("value", `${D.formatEther(e.value)} ${rS[e.network.chainId]?.symbol||""}`)), n += rJ("data", `${e.data}`), e.method && (n += rJ("method", e.method)), e.sources) {
                        let t = e.sources.find(t => t.source.includes(e.reason));
                        if (t) {
                            let a = t.source.split("\n").map((e, t) => `${t+1}  ${e}`),
                                r = a.findIndex(t => t.includes(e.reason));
                            a[r] += "   <-- REVERT";
                            let i = a.slice(r - 8, r + 4);
                            n += `


╔══════════════════════╗
║ SOLIDITY STACK TRACE ║
╚══════════════════════╝

File: ${t.filename.replace("node_modules/","")}

` + i.join("\n")
                        }
                    }
                    super(n += `


╔═════════════════════╗
║ DEBUGGING RESOURCES ║
╚═════════════════════╝

Need helping debugging? Visit our support site: https://thirdweb.com/support

`), this._reason = e.reason, this._info = e, this._raw = t
                }
                get reason() {
                    return this._reason
                }
                get raw() {
                    return this._raw
                }
                get info() {
                    return this._info
                }
            }

            function rq(e) {
                if (e.reason && !e.reason.includes("cannot estimate gas")) return e.reason;
                if (e.error) return e.error;
                let t = e;
                return ("object" == typeof e ? t = JSON.stringify(e) : "string" != typeof e && (t = e.toString()), t.length > 5e3) ? e.message || "" : rZ(/.*?"message":"([^"\\]*).*?/, t) || rZ(/.*?"reason":"([^"\\]*).*?/, t) || e.message || ""
            }

            function rJ(e, t) {
                if ("" === t) return t;
                let n = Array(10 - e.length).fill(" ").join("");
                return t = t.includes("\n") ? "\n\n  " + t.split("\n").join(`
  `) : `${n}${t}`, `
${e}:${t}`
            }

            function rZ(e, t) {
                let n = t.match(e) || [],
                    a = "";
                return n ? .length > 0 && (a += n[1]), a
            }

            function rX(e, t) {
                return !!e && (e && e.toString().includes(t) || e && e.message && e.message.toString().includes(t) || e && e.error && e.error.toString().includes(t))
            }
            async function rY(e, t) {
                return await Promise.all(Object.entries(e.metadata.sources).map(async e => {
                    let [n, a] = e, r = a.urls, i = r ? r.find(e => e.includes("ipfs")) : void 0;
                    if (!i) return {
                        filename: n,
                        source: a.content || "Could not find source for this contract"
                    }; {
                        let e = i.split("ipfs/")[1],
                            a = new Promise((e, t) => setTimeout(() => t("timeout"), 3e3));
                        return {
                            filename: n,
                            source: await Promise.race([(await t.download(`ipfs://${e}`)).text(), a])
                        }
                    }
                }))
            }
            let rQ = [{
                    name: "from",
                    type: "address"
                }, {
                    name: "to",
                    type: "address"
                }, {
                    name: "value",
                    type: "uint256"
                }, {
                    name: "gas",
                    type: "uint256"
                }, {
                    name: "nonce",
                    type: "uint256"
                }, {
                    name: "data",
                    type: "bytes"
                }],
                r0 = [{
                    name: "from",
                    type: "address"
                }, {
                    name: "to",
                    type: "address"
                }, {
                    name: "value",
                    type: "uint256"
                }, {
                    name: "gas",
                    type: "uint256"
                }, {
                    name: "nonce",
                    type: "uint256"
                }, {
                    name: "data",
                    type: "bytes"
                }, {
                    name: "chainid",
                    type: "uint256"
                }],
                r1 = [{
                    inputs: [{
                        internalType: "address",
                        name: "from",
                        type: "address"
                    }, {
                        internalType: "uint256",
                        name: "batchId",
                        type: "uint256"
                    }],
                    name: "getNonce",
                    outputs: [{
                        internalType: "uint256",
                        name: "",
                        type: "uint256"
                    }],
                    stateMutability: "view",
                    type: "function"
                }],
                r2 = {},
                r5 = {};
            async function r6(e, t, n) {
                let a = n.join("|"),
                    r = r5[a],
                    i = Date.now() - r >= 2e3;
                if (!(a in r2) || i) {
                    let r = await e.functions[t](...n);
                    Array.isArray(r) && r.length > 0 ? r2[a] = z.O$.from(r[0]) : r2[a] = z.O$.from(r), r5[a] = Date.now()
                }
                let f = r2[a];
                return r2[a] = z.O$.from(r2[a]).add(1), f
            }
            async function r8(e, t, n, a) {
                let r = e;
                e.originalSigner && (r = e.originalSigner);
                let i = r ? .provider;
                if (!i) throw Error("missing provider");
                let f = P.E.getPayload(t, n, a),
                    s = "",
                    o = (await r.getAddress()).toLowerCase();
                if (i ? .provider ? .isWalletConnect) s = await i.send("eth_signTypedData", [o, JSON.stringify(f)]);
                else try {
                    s = await r._signTypedData(t, n, a)
                } catch (e) {
                    if (e ? .message ? .includes("eth_signTypedData_v4")) s = await i.send("eth_signTypedData", [o, JSON.stringify(f)]);
                    else try {
                        await i.send("eth_signTypedData_v4", [o, JSON.stringify(f)])
                    } catch (e) {
                        throw e
                    }
                }
                return {
                    payload: f,
                    signature: S.joinSignature(S.splitSignature(s))
                }
            }
            let r3 = [{
                    inputs: [],
                    name: "name",
                    outputs: [{
                        internalType: "string",
                        name: "",
                        type: "string"
                    }],
                    stateMutability: "view",
                    type: "function"
                }],
                r9 = [{
                    constant: !0,
                    inputs: [],
                    name: "DOMAIN_SEPARATOR",
                    outputs: [{
                        internalType: "bytes32",
                        name: "",
                        type: "bytes32"
                    }],
                    payable: !1,
                    stateMutability: "view",
                    type: "function"
                }, {
                    inputs: [],
                    name: "getDomainSeperator",
                    outputs: [{
                        internalType: "bytes32",
                        name: "",
                        type: "bytes32"
                    }],
                    stateMutability: "view",
                    type: "function"
                }],
                r4 = [{
                    inputs: [{
                        internalType: "address",
                        name: "owner",
                        type: "address"
                    }],
                    name: "nonces",
                    outputs: [{
                        internalType: "uint256",
                        name: "",
                        type: "uint256"
                    }],
                    stateMutability: "view",
                    type: "function"
                }, {
                    inputs: [{
                        internalType: "address",
                        name: "user",
                        type: "address"
                    }],
                    name: "getNonce",
                    outputs: [{
                        internalType: "uint256",
                        name: "nonce",
                        type: "uint256"
                    }],
                    stateMutability: "view",
                    type: "function"
                }];
            async function r7(e, t) {
                let n = new x.CH(t, r4, e);
                try {
                    return await n.nonces(await e.getAddress())
                } catch (t) {
                    return await n.getNonce(await e.getAddress())
                }
            }
            async function ie(e, t) {
                let n = new x.CH(t, r9, e);
                try {
                    return await n.DOMAIN_SEPARATOR()
                } catch (e) {
                    try {
                        return await n.getDomainSeperator()
                    } catch (e) {
                        console.error("Error getting domain separator", e)
                    }
                }
            }
            async function it(e, t) {
                return new x.CH(t, r3, e).name()
            }
            async function ia(e, t) {
                let n = await ie(e, t.verifyingContract),
                    a = {
                        name: t.name,
                        version: t.version,
                        verifyingContract: t.verifyingContract,
                        salt: S.hexZeroPad(z.O$.from(t.chainId).toHexString(), 32)
                    };
                return P.E.hashDomain(a) === n ? a : t
            }
            async function ir(e, t, n, a, r, i, f, s) {
                let [o, c, d] = await Promise.all([it(e, t), e.getChainId(), r7(e, t)]), l = await ia(e, {
                    name: o,
                    version: s || "1",
                    chainId: c,
                    verifyingContract: t
                }), u = {
                    owner: n,
                    spender: a,
                    value: r,
                    nonce: f = f || d.toString(),
                    deadline: i = i || L.Bz
                }, {
                    signature: m
                } = await r8(e, l, {
                    Permit: [{
                        name: "owner",
                        type: "address"
                    }, {
                        name: "spender",
                        type: "address"
                    }, {
                        name: "value",
                        type: "uint256"
                    }, {
                        name: "nonce",
                        type: "uint256"
                    }, {
                        name: "deadline",
                        type: "uint256"
                    }]
                }, u);
                return {
                    message: u,
                    signature: m
                }
            }
            let ii = "0x7c487845f98938Bb955B1D5AD069d9a30e4131fd",
                is = "0x5DBC7B840baa9daBcBe9D2492E45D7244B54A2A0",
                io = "0xc82BbE41f2cF04e3a8efA18F7032BDD7f6d98a81",
                ic = {
                    [rx.Mainnet]: {
                        openzeppelinForwarder: io,
                        openzeppelinForwarderEOA: "0x76ce2CB1Ae48Fa067f4fb8c5f803111AE0B24BEA",
                        biconomyForwarder: "0x84a0856b038eaAd1cC7E297cF34A7e72685A8693",
                        twFactory: is,
                        twRegistry: ii,
                        twBYOCRegistry: r_
                    },
                    [rx.Goerli]: {
                        openzeppelinForwarder: "0x5001A14CA6163143316a7C614e30e6041033Ac20",
                        openzeppelinForwarderEOA: "0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2",
                        biconomyForwarder: "0xE041608922d06a4F26C0d4c27d8bCD01daf1f792",
                        twFactory: is,
                        twRegistry: ii,
                        twBYOCRegistry: "0xB1Bd9d7942A250BA2Dce27DD601F2ED4211A60C4"
                    },
                    [rx.Polygon]: {
                        openzeppelinForwarder: io,
                        openzeppelinForwarderEOA: "0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F",
                        biconomyForwarder: "0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8",
                        twFactory: is,
                        twRegistry: ii,
                        twBYOCRegistry: "0x308473Be900F4185A56587dE54bDFF5E8f7a6AE7"
                    },
                    [rx.Mumbai]: {
                        openzeppelinForwarder: io,
                        openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
                        biconomyForwarder: "0x9399BB24DBB5C4b782C70c2969F58716Ebbd6a3b",
                        twFactory: is,
                        twRegistry: ii,
                        twBYOCRegistry: "0x3F17972CB27506eb4a6a3D59659e0B57a43fd16C"
                    },
                    [rx.Avalanche]: {
                        openzeppelinForwarder: io,
                        openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
                        biconomyForwarder: "0x64CD353384109423a966dCd3Aa30D884C9b2E057",
                        twFactory: is,
                        twRegistry: ii,
                        twBYOCRegistry: r_
                    },
                    [rx.AvalancheFujiTestnet]: {
                        openzeppelinForwarder: io,
                        openzeppelinForwarderEOA: "0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2",
                        biconomyForwarder: "0x6271Ca63D30507f2Dcbf99B52787032506D75BBF",
                        twFactory: is,
                        twRegistry: ii,
                        twBYOCRegistry: "0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23"
                    },
                    [rx.Fantom]: {
                        openzeppelinForwarder: io,
                        openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
                        biconomyForwarder: "0x64CD353384109423a966dCd3Aa30D884C9b2E057",
                        twFactory: "0x97EA0Fcc552D5A8Fb5e9101316AAd0D62Ea0876B",
                        twRegistry: ii,
                        twBYOCRegistry: r_
                    },
                    [rx.FantomTestnet]: {
                        openzeppelinForwarder: io,
                        openzeppelinForwarderEOA: "0x42D3048b595B6e1c28a588d70366CcC2AA4dB47b",
                        biconomyForwarder: "0x69FB8Dca8067A5D38703b9e8b39cf2D51473E4b4",
                        twFactory: is,
                        twRegistry: ii,
                        twBYOCRegistry: "0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23"
                    },
                    [rx.Arbitrum]: {
                        openzeppelinForwarder: "0x4a8AC7f22DeD2CF923A51e4A1c67490bd8868add",
                        openzeppelinForwarderEOA: "0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F",
                        biconomyForwarder: "0xfe0fa3C06d03bDC7fb49c892BbB39113B534fB57",
                        twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
                        twRegistry: ii,
                        twBYOCRegistry: r_
                    },
                    [rx.ArbitrumGoerli]: {
                        openzeppelinForwarder: "0x8cbc8B5d71702032904750A66AEfE8B603eBC538",
                        openzeppelinForwarderEOA: "0x119704314Ef304EaAAE4b3c7C9ABd59272A28310",
                        biconomyForwarder: r_,
                        twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
                        twRegistry: ii,
                        twBYOCRegistry: r_
                    },
                    [rx.Optimism]: {
                        openzeppelinForwarder: "0xd85da690EF288A6976DE0E85Fb2Aad512eBAfbf7",
                        openzeppelinForwarderEOA: "0x7e80648EB2071E26937F9D42A513ccf4815fc702",
                        biconomyForwarder: "0xefba8a2a82ec1fb1273806174f5e28fbb917cf95",
                        twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
                        twRegistry: ii,
                        twBYOCRegistry: r_
                    },
                    [rx.OptimismGoerli]: {
                        openzeppelinForwarder: "0x8cbc8B5d71702032904750A66AEfE8B603eBC538",
                        openzeppelinForwarderEOA: "0x119704314Ef304EaAAE4b3c7C9ABd59272A28310",
                        biconomyForwarder: r_,
                        twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
                        twRegistry: ii,
                        twBYOCRegistry: r_
                    },
                    [rx.BinanceSmartChainMainnet]: {
                        openzeppelinForwarder: "0x7C4717039B89d5859c4Fbb85EDB19A6E2ce61171",
                        openzeppelinForwarderEOA: "0xE8dd2Ff0212F86d3197b4AfDC6dAC6ac47eb10aC",
                        biconomyForwarder: "0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8",
                        twBYOCRegistry: r_,
                        twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
                        twRegistry: ii
                    },
                    [rx.BinanceSmartChainTestnet]: {
                        openzeppelinForwarder: "0x44bE9D54B9C8b5e57a3325E8Ec9154640e7c6955",
                        openzeppelinForwarderEOA: "0x7e80648EB2071E26937F9D42A513ccf4815fc702",
                        biconomyForwarder: "0x61456BF1715C1415730076BB79ae118E806E74d2",
                        twBYOCRegistry: r_,
                        twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
                        twRegistry: ii
                    },
                    [rx.Hardhat]: {
                        openzeppelinForwarder: r_,
                        openzeppelinForwarderEOA: r_,
                        biconomyForwarder: r_,
                        twFactory: r_,
                        twRegistry: r_,
                        twBYOCRegistry: r_
                    },
                    [rx.Localhost]: {
                        openzeppelinForwarder: r_,
                        openzeppelinForwarderEOA: r_,
                        biconomyForwarder: r_,
                        twFactory: r_,
                        twRegistry: r_,
                        twBYOCRegistry: r_
                    }
                };

            function id(e, t) {
                return e === rx.Hardhat || e === rx.Localhost ? "twFactory" === t ? e2("factoryAddress") : "twRegistry" === t ? e2("registryAddress") : r_ : ic[e] ? .[t]
            }
            let il = ((h = {}).Transaction = "transaction", h.Signature = "signature", h),
                iu = N.z.object({
                    gasLimit: tT.optional(),
                    gasPrice: tT.optional(),
                    maxFeePerGas: tT.optional(),
                    maxPriorityFeePerGas: tT.optional(),
                    nonce: tT.optional(),
                    value: tT.optional(),
                    blockTag: N.z.union([N.z.string(), N.z.number()]).optional(),
                    from: tm.optional(),
                    type: N.z.number().optional()
                }).strict();
            class im extends eQ.Z {
                constructor(e, t) {
                    super();
                    try {
                        this.options = e4.parse(t)
                    } catch (e) {
                        console.error("invalid sdk options object passed, falling back to default options", e), this.options = e4.parse({})
                    }
                    let [n, a] = to(e, this.options);
                    this.network = e, this.signer = n, this.provider = a
                }
                updateSignerOrProvider(e) {
                    let [t, n] = to(e, this.options);
                    this.network = e, this.signer = t, this.provider = n
                }
                isReadOnly() {
                    return !e5(this.signer)
                }
                getSigner() {
                    return this.signer
                }
                getProvider() {
                    return this.provider
                }
                getSignerOrProvider() {
                    return this.getSigner() || this.getProvider()
                }
            }
            class ip extends im {
                isValidContract = !1;
                customOverrides = () => ({});
                constructor(e, t, n, a, r) {
                    super(e, a), this.abi = tJ.parse(n), this.address = t, this.writeContract = new x.CH(t, n, this.getSignerOrProvider()), this.readContract = this.writeContract.connect(this.getProvider()), this.storage = r, this.functions = ra(this.abi), this.extensions = ri(this.abi)
                }
                updateSignerOrProvider(e) {
                    super.updateSignerOrProvider(e), this.writeContract = this.writeContract.connect(this.getSignerOrProvider()), this.readContract = this.writeContract.connect(this.getProvider())
                }
                updateAbi(e) {
                    this.writeContract = new x.CH(this.address, e, this.getSignerOrProvider()), this.readContract = this.writeContract.connect(this.getProvider()), this.abi = tJ.parse(e), this.functions = ra(this.abi), this.extensions = ri(this.abi)
                }
                async getChainID() {
                    let e = this.getProvider(),
                        {
                            chainId: t
                        } = await e.getNetwork();
                    return t
                }
                async getSignerAddress() {
                    let e = this.getSigner();
                    if (!e) throw Error("This action requires a connected wallet to sign the transaction. Please pass a valid signer to the SDK.");
                    return await e.getAddress()
                }
                callStatic() {
                    return this.writeContract.callStatic
                }
                async getCallOverrides() {
                    return {}
                }
                emitTransactionEvent(e, t) {
                    this.emit(il.Transaction, {
                        status: e,
                        transactionHash: t
                    })
                }
                async multiCall(e) {
                    return this.sendTransaction("multicall", [e])
                }
                async estimateGas(e, t) {
                    return this.writeContract.estimateGas[e](...t)
                }
                async populateTransaction(e, t) {
                    return this.writeContract.populateTransaction[e](...t)
                }
                withTransactionOverride(e) {
                    this.customOverrides = e
                }
                async read(e, t) {
                    let n = this.functions.filter(t => t.name === e);
                    if (!n.length) throw Error(`Function "${e.toString()}" not found in contract. Check your dashboard for the list of functions available`);
                    let a = n.find(n => n.name === e && n.inputs.length === t.length);
                    if (!a) throw Error(`Function "${e.toString()}" requires ${n[0].inputs.length} arguments, but ${t.length} were provided.
Expected function signature: ${n[0].signature}`);
                    let r = `${e.toString()}(${a.inputs.map(e=>e.type).join()})`,
                        i = r in this.readContract.functions ? r : e;
                    if ("view" === a.stateMutability || "pure" === a.stateMutability) return await this.readContract[i.toString()](...t);
                    throw Error("Cannot call a write function with read()")
                }
                async call(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
                        n = arguments.length > 2 ? arguments[2] : void 0,
                        a = n ? await iu.parseAsync(n) : void 0,
                        r = ra(tJ.parse(this.abi)).filter(t => t.name === e);
                    if (!r.length) throw Error(`Function "${e}" not found in contract. Check your dashboard for the list of functions available`);
                    let i = r.find(n => n.name === e && n.inputs.length === t.length);
                    if (!i) throw Error(`Function "${e}" requires ${r[0].inputs.length} arguments, but ${t.length} were provided.
Expected function signature: ${r[0].signature}`);
                    let f = `${e}(${i.inputs.map(e=>e.type).join()})`,
                        s = f in this.readContract.functions ? f : e;
                    return "view" === i.stateMutability || "pure" === i.stateMutability ? a ? this.readContract[s](...t, a) : this.readContract[s](...t) : {
                        receipt: await this.sendTransaction(s, t, a)
                    }
                }
                async sendTransaction(e, t, n) {
                    if (n || (n = await this.getCallOverrides()), n = { ...n,
                            ...this.customOverrides()
                        }, this.customOverrides = () => ({}), this.options ? .gasless && ("openzeppelin" in this.options.gasless || "biconomy" in this.options.gasless || "engine" in this.options.gasless)) {
                        if ("multicall" === e && Array.isArray(t[0]) && t[0].length > 0) {
                            let e = await this.getSignerAddress();
                            t[0] = t[0].map(t => $.pack(["bytes", "address"], [t, e]))
                        }
                        let a = this.getProvider(),
                            r = await this.sendGaslessTransaction(e, t, n);
                        this.emitTransactionEvent("submitted", r);
                        let i = await a.waitForTransaction(r);
                        return this.emitTransactionEvent("completed", r), i
                    } {
                        let a;
                        if (!this.isValidContract) {
                            let e = await this.getProvider().getCode(this.address);
                            if (this.isValidContract = "0x" !== e, !this.isValidContract) throw Error("The address you're trying to send a transaction to is not a smart contract. Make sure you are on the correct network and the contract address is correct")
                        }
                        let r = await this.sendTransactionByFunction(e, t, n);
                        this.emitTransactionEvent("submitted", r.hash);
                        try {
                            a = await r.wait()
                        } catch (a) {
                            try {
                                await this.writeContract.callStatic[e](...t, ...n.value ? [{
                                    value: n.value
                                }] : [])
                            } catch (a) {
                                throw await this.formatError(a, e, t, n)
                            }
                            throw await this.formatError(a, e, t, n)
                        }
                        return this.emitTransactionEvent("completed", r.hash), a
                    }
                }
                async sendTransactionByFunction(e, t, n) {
                    let a = this.writeContract.functions[e];
                    if (!a) throw Error(`invalid function: "${e.toString()}"`);
                    if (!n.gasLimit) try {
                        n.gasLimit = await this.writeContract.estimateGas[e](...t, n)
                    } catch (a) {
                        try {
                            await this.writeContract.callStatic[e](...t, ...n.value ? [{
                                value: n.value
                            }] : [])
                        } catch (a) {
                            throw await this.formatError(a, e, t, n)
                        }
                    }
                    try {
                        return await a(...t, n)
                    } catch (a) {
                        throw await this.formatError(a, e, t, n)
                    }
                }
                async formatError(e, t, n, a) {
                    let r, i;
                    let f = this.getProvider(),
                        s = await f.getNetwork(),
                        o = await (a.from || this.getSignerAddress()),
                        c = this.address,
                        d = this.readContract.interface.encodeFunctionData(t, n),
                        l = z.O$.from(a.value || 0),
                        u = f.connection ? .url,
                        m = this.readContract.interface.getFunction(t),
                        p = n.map(e => JSON.stringify(e).length <= 80 ? JSON.stringify(e) : JSON.stringify(e, void 0, 2)),
                        g = p.join(", ").length <= 80 ? p.join(", ") : "\n" + p.map(e => "  " + e.split("\n").join("\n  ")).join(",\n") + "\n",
                        h = `${m.name}(${g})`,
                        b = e.transactionHash || e.transaction ? .hash || e.receipt ? .transactionHash,
                        y = rq(e);
                    try {
                        let e = await ro(this.address, this.getProvider(), this.storage, this.options);
                        e.name && (i = e.name), e.metadata.sources && (r = await rY(e, this.storage))
                    } catch (e) {}
                    return new rK({
                        reason: y,
                        from: o,
                        to: c,
                        method: h,
                        data: d,
                        network: s,
                        rpcUrl: u,
                        value: l,
                        hash: b,
                        contractName: i,
                        sources: r
                    }, e)
                }
                async sendGaslessTransaction(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
                        n = arguments.length > 2 ? arguments[2] : void 0,
                        a = this.getSigner();
                    (0, M.Z)(a, "Cannot execute gasless transaction without valid signer");
                    let r = await this.getChainID(),
                        i = await this.getSignerAddress(),
                        f = this.writeContract.address,
                        s = n ? .value || 0;
                    if (z.O$.from(s).gt(0)) throw Error("Cannot send native token value with gasless transaction");
                    let o = this.writeContract.interface.encodeFunctionData(e, t),
                        c = z.O$.from(0);
                    try {
                        c = (await this.readContract.estimateGas[e](...t)).mul(2)
                    } catch (e) {}
                    c.lt(1e5) && (c = z.O$.from(5e5)), n.gasLimit && z.O$.from(n.gasLimit).gt(c) && (c = z.O$.from(n.gasLimit));
                    let d = {
                        from: i,
                        to: f,
                        data: o,
                        chainId: r,
                        gasLimit: c,
                        functionName: e.toString(),
                        functionArgs: t,
                        callOverrides: n
                    };
                    return await this.defaultGaslessSendFunction(d)
                }
                async signTypedData(e, t, n, a) {
                    this.emit(il.Signature, {
                        status: "submitted",
                        message: a,
                        signature: ""
                    });
                    let {
                        signature: r
                    } = await r8(e, t, n, a);
                    return this.emit(il.Signature, {
                        status: "completed",
                        message: a,
                        signature: r
                    }), r
                }
                parseLogs(e, t) {
                    if (!t || 0 === t.length) return [];
                    let n = this.writeContract.interface.getEventTopic(e);
                    return t.filter(e => e.topics.indexOf(n) >= 0).map(e => this.writeContract.interface.parseLog(e))
                }
                async defaultGaslessSendFunction(e) {
                    return this.options.gasless && "biconomy" in this.options.gasless ? this.biconomySendFunction(e) : this.options.gasless && "openzeppelin" in this.options.gasless ? this.defenderSendFunction(e) : this.engineSendFunction(e)
                }
                async engineSendFunction(e) {
                    (0, M.Z)(this.options.gasless && "engine" in this.options.gasless, "calling engine gasless transaction without engine config in the SDK options");
                    let t = await this.enginePrepareRequest(e),
                        n = await fetch(this.options.gasless.engine.relayerUrl, { ...t,
                            headers: {
                                "Content-Type": "application/json"
                            }
                        }),
                        a = await n.json();
                    if (a.error) throw Error(a.error ? .message || JSON.stringify(a.error));
                    let r = a.result.queueId,
                        i = this.options.gasless.engine.relayerUrl.split("/relayer/")[0],
                        f = Date.now();
                    for (;;) {
                        let e = await fetch(`${i}/transaction/status/${r}`),
                            t = await e.json();
                        if (t.result.transactionHash) return t.result.transactionHash;
                        if (Date.now() - f > 3e4) throw Error("timeout");
                        await new Promise(e => setTimeout(e, 2e3))
                    }
                }
                async enginePrepareRequest(e) {
                    (0, M.Z)(this.options.gasless && "engine" in this.options.gasless, "calling engine gasless transaction without openzeppelin config in the SDK options");
                    let t = this.getSigner(),
                        a = this.getProvider(),
                        r = this.storage;
                    (0, M.Z)(t, "signer is not set");
                    try {
                        let {
                            abi: n
                        } = await ro(e.to, a, r), i = (await a.getNetwork()).chainId, f = new ip(t, e.to, n, {}, r);
                        if (n.find(e => "executeMetaTransaction" === e.name)) {
                            let n = {
                                    name: await f.call("name", []),
                                    version: "1",
                                    salt: "0x" + i.toString(16).padStart(64, "0"),
                                    verifyingContract: e.to
                                },
                                a = {
                                    nonce: await f.call("getNonce", [e.from]),
                                    from: e.from,
                                    functionSignature: e.data
                                },
                                {
                                    signature: r
                                } = await r8(t, n, {
                                    MetaTransaction: [{
                                        name: "nonce",
                                        type: "uint256"
                                    }, {
                                        name: "from",
                                        type: "address"
                                    }, {
                                        name: "functionSignature",
                                        type: "bytes"
                                    }]
                                }, a);
                            return {
                                method: "POST",
                                body: JSON.stringify({
                                    type: "execute-meta-transaction",
                                    request: {
                                        from: e.from,
                                        to: e.to,
                                        data: e.data
                                    },
                                    signature: r
                                })
                            }
                        }
                    } catch {}
                    if ("approve" === e.functionName && 2 === e.functionArgs.length) {
                        let n = e.functionArgs[0],
                            a = e.functionArgs[1],
                            {
                                message: r,
                                signature: i
                            } = await ir(t, e.to, e.from, n, a, this.options.gasless.engine.domainSeparatorVersion);
                        return {
                            method: "POST",
                            body: JSON.stringify({
                                type: "permit",
                                request: {
                                    to: e.to,
                                    owner: r.owner,
                                    spender: r.spender,
                                    value: z.O$.from(r.value).toString(),
                                    nonce: z.O$.from(r.nonce).toString(),
                                    deadline: z.O$.from(r.deadline).toString()
                                },
                                signature: i
                            })
                        }
                    } {
                        let i, f, s;
                        let o = this.options.gasless.engine.relayerForwarderAddress || ic[e.chainId] ? .openzeppelinForwarder || await rN(a, r),
                            c = (await n.e(49958).then(n.t.bind(n, 49958, 19))).default,
                            d = new x.CH(o, c, a),
                            l = await r6(d, "getNonce", [e.from]);
                        this.options.gasless.experimentalChainlessSupport ? (i = {
                            name: "GSNv2 Forwarder",
                            version: "0.0.1",
                            verifyingContract: o
                        }, f = {
                            ForwardRequest: r0
                        }, s = {
                            from: e.from,
                            to: e.to,
                            value: z.O$.from(0).toString(),
                            gas: z.O$.from(e.gasLimit).toString(),
                            nonce: z.O$.from(l).toString(),
                            data: e.data,
                            chainid: z.O$.from(e.chainId).toString()
                        }) : (i = {
                            name: this.options.gasless.engine.domainName,
                            version: this.options.gasless.engine.domainVersion,
                            chainId: e.chainId,
                            verifyingContract: o
                        }, f = {
                            ForwardRequest: rQ
                        }, s = {
                            from: e.from,
                            to: e.to,
                            value: z.O$.from(0).toString(),
                            gas: z.O$.from(e.gasLimit).toString(),
                            nonce: z.O$.from(l).toString(),
                            data: e.data
                        });
                        let {
                            signature: u
                        } = await r8(t, i, f, s);
                        return {
                            method: "POST",
                            body: JSON.stringify({
                                type: "forward",
                                request: s,
                                signature: u,
                                forwarderAddress: o
                            })
                        }
                    }
                }
                async biconomySendFunction(e) {
                    (0, M.Z)(this.options.gasless && "biconomy" in this.options.gasless, "calling biconomySendFunction without biconomy");
                    let t = this.getSigner(),
                        n = this.getProvider();
                    (0, M.Z)(t && n, "signer and provider must be set");
                    let a = new x.CH(id(e.chainId, "biconomyForwarder"), r1, n),
                        r = await r6(a, "getNonce", [e.from, 0]),
                        i = {
                            from: e.from,
                            to: e.to,
                            token: v.d,
                            txGas: e.gasLimit.toNumber(),
                            tokenGasPrice: "0",
                            batchId: 0,
                            batchNonce: r.toNumber(),
                            deadline: Math.floor(Date.now() / 1e3 + (this.options ? .gasless && "biconomy" in this.options.gasless && this.options.gasless.biconomy ? .deadlineSeconds || 3600)),
                            data: e.data
                        },
                        f = S.arrayify($.keccak256(["address", "address", "address", "uint256", "uint256", "uint256", "uint256", "uint256", "bytes32"], [i.from, i.to, i.token, i.txGas, i.tokenGasPrice, i.batchId, i.batchNonce, i.deadline, T.keccak256(i.data)]));
                    this.emit(il.Signature, {
                        status: "submitted",
                        message: f,
                        signature: ""
                    });
                    let s = await t.signMessage(f);
                    this.emit(il.Signature, {
                        status: "completed",
                        message: f,
                        signature: s
                    });
                    let o = await fetch("https://api.biconomy.io/api/v2/meta-tx/native", {
                        method: "POST",
                        body: JSON.stringify({
                            from: e.from,
                            apiId: this.options.gasless.biconomy.apiId,
                            params: [i, s],
                            to: e.to,
                            gasLimit: e.gasLimit.toHexString()
                        }),
                        headers: {
                            "x-api-key": this.options.gasless.biconomy.apiKey,
                            "Content-Type": "application/json;charset=utf-8"
                        }
                    });
                    if (o.ok) {
                        let e = await o.json();
                        if (!e.txHash) throw Error(`relay transaction failed: ${e.log}`);
                        return e.txHash
                    }
                    throw Error(`relay transaction failed with status: ${o.status} (${o.statusText})`)
                }
                async defenderSendFunction(e) {
                    let t, a, r, i;
                    (0, M.Z)(this.options.gasless && "openzeppelin" in this.options.gasless, "calling openzeppelin gasless transaction without openzeppelin config in the SDK options");
                    let f = this.getSigner(),
                        s = this.getProvider();
                    (0, M.Z)(f, "provider is not set"), (0, M.Z)(s, "provider is not set");
                    let o = (await n.e(49958).then(n.t.bind(n, 49958, 19))).default,
                        c = this.options.gasless.openzeppelin.relayerForwarderAddress || (this.options.gasless.openzeppelin.useEOAForwarder ? ic[e.chainId] ? .openzeppelinForwarderEOA || await rL(this.getProvider(), this.storage, "", this.options.clientId, this.options.secretKey) : ic[e.chainId] ? .openzeppelinForwarder || await rN(this.getProvider(), this.storage, "", this.options.clientId, this.options.secretKey)),
                        d = new x.CH(c, o, s),
                        l = await r6(d, "getNonce", [e.from]);
                    if (this.options.gasless.experimentalChainlessSupport ? (t = {
                            name: "GSNv2 Forwarder",
                            version: "0.0.1",
                            verifyingContract: c
                        }, a = {
                            ForwardRequest: r0
                        }, r = {
                            from: e.from,
                            to: e.to,
                            value: z.O$.from(0).toString(),
                            gas: z.O$.from(e.gasLimit).toString(),
                            nonce: z.O$.from(l).toString(),
                            data: e.data,
                            chainid: z.O$.from(e.chainId).toString()
                        }) : (t = {
                            name: this.options.gasless.openzeppelin.domainName,
                            version: this.options.gasless.openzeppelin.domainVersion,
                            chainId: e.chainId,
                            verifyingContract: c
                        }, a = {
                            ForwardRequest: rQ
                        }, r = {
                            from: e.from,
                            to: e.to,
                            value: z.O$.from(0).toString(),
                            gas: z.O$.from(e.gasLimit).toString(),
                            nonce: z.O$.from(l).toString(),
                            data: e.data
                        }), this.emit(il.Signature, {
                            status: "submitted",
                            message: r,
                            signature: ""
                        }), "approve" === e.functionName && 2 === e.functionArgs.length) {
                        let t = e.functionArgs[0],
                            n = e.functionArgs[1],
                            {
                                message: a,
                                signature: s
                            } = await ir(f, this.writeContract.address, e.from, t, n, this.options.gasless.openzeppelin.domainSeparatorVersion),
                            {
                                r: o,
                                s: c,
                                v: d
                            } = S.splitSignature(s);
                        r = {
                            to: this.address,
                            owner: a.owner,
                            spender: a.spender,
                            value: z.O$.from(a.value).toString(),
                            nonce: z.O$.from(a.nonce).toString(),
                            deadline: z.O$.from(a.deadline).toString(),
                            r: o,
                            s: c,
                            v: d
                        }, i = s
                    } else {
                        let {
                            signature: e
                        } = await r8(f, t, a, r);
                        i = e
                    }
                    let u = "forward";
                    r ? .owner && (u = "permit");
                    let m = JSON.stringify({
                        request: r,
                        signature: i,
                        forwarderAddress: c,
                        type: u
                    });
                    this.emit(il.Signature, {
                        status: "completed",
                        message: r,
                        signature: i
                    });
                    let p = await fetch(this.options.gasless.openzeppelin.relayerUrl, {
                        method: "POST",
                        body: m
                    });
                    if (p.ok) {
                        let e = await p.json();
                        if (!e.result) throw Error(`Relay transaction failed: ${e.message}`);
                        return JSON.parse(e.result).txHash
                    }
                    throw Error(`relay transaction failed with status: ${p.status} (${p.statusText})`)
                }
            }

            function ig(e, t, n) {
                return function e(t, n) {
                    let a = Object.keys(t);
                    if (!a.includes(n)) {
                        let r = !1;
                        for (let i of a)
                            if (r = e(t[i].features, n)) break;
                        return r
                    }
                    return t[n].enabled
                }(n, t)
            }
            async function ih(e, t, n) {
                return (await Promise.all(e.map(e => ro(e, t, n).catch(t => (console.error(`Failed to fetch plug-in for ${e}`, t), {
                    abi: []
                }))))).map(e => e.abi)
            }
            async function ib(e, t, n, a, r) {
                let i = [];
                try {
                    let f = ri(t),
                        s = ig(t, "PluginRouter", f),
                        o = ig(t, "DynamicContract", f),
                        c = ig(t, "Fallback", f);
                    if (o) {
                        let t = new ip(n, e, aW, a, r),
                            f = (await t.call("getAllExtensions")).map(e => e.metadata.implementation);
                        i = await ih(f, n, r)
                    } else if (s) {
                        let t = new ip(n, e, aM, a, r),
                            f = (await t.call("getAllPlugins")).map(e => e.pluginAddress),
                            s = Array.from(new Set(f));
                        i = await ih(s, n, r)
                    } else if (c) {
                        let t = new x.CH(e, ["function facets() external view returns (tuple(address,bytes4[])[])"], n),
                            a = (await t.facets()).map(e => e[0]);
                        i = await ih(a, n, r)
                    }
                } catch (e) {}
                return i.length > 0 ? n2([...i], t) : t
            }
            let iy = {
                admin: "",
                transfer: "TRANSFER_ROLE",
                minter: "MINTER_ROLE",
                pauser: "PAUSER_ROLE",
                lister: "LISTER_ROLE",
                asset: "ASSET_ROLE",
                unwrap: "UNWRAP_ROLE",
                factory: "FACTORY_ROLE",
                signer: "SIGNER_ROLE",
                metadata: "METADATA_ROLE",
                revoke: "REVOKE_ROLE",
                migration: "MIGRATION_ROLE"
            };

            function iw(e) {
                return "admin" === e ? S.hexZeroPad([0], 32) : O.id(iy[e])
            }
            Object.keys(iy);
            let iE = tO.merge(t_).merge(tN).merge(tL),
                ik = t$.merge(t_).merge(tN).merge(tL),
                iC = {
                    deploy: iE.merge(tD).merge(tR).merge(tP),
                    output: ik,
                    input: iE
                },
                iA = tO.merge(tN).merge(tL),
                iz = t$.merge(tN).merge(tL),
                iv = {
                    deploy: iA.merge(tD).merge(tR).merge(tP),
                    output: iz,
                    input: iA
                },
                ix = tO.merge(t_).merge(tN).merge(tL),
                iF = t$.merge(t_).merge(tN).merge(tL),
                iS = {
                    deploy: ix.merge(tD).merge(tR).merge(tP),
                    output: iF,
                    input: ix
                },
                iT = {
                    deploy: tO.merge(tD).merge(tP),
                    output: t$,
                    input: tO
                },
                iB = tO.merge(t_).merge(tL),
                iO = t$.merge(t_).merge(tL),
                i$ = {
                    deploy: iB.merge(tP),
                    output: iO,
                    input: iB
                },
                i_ = tO.merge(t_).merge(tL),
                iR = t$.merge(t_).merge(tL),
                iD = {
                    deploy: i_.merge(tD).merge(tP),
                    output: iR,
                    input: i_
                },
                iP = N.z.object({
                    address: tm,
                    sharesBps: tk.gt(0, "Shares must be greater than 0")
                }),
                iL = iP.extend({
                    address: tm,
                    sharesBps: tk
                }),
                iN = tO.extend({
                    recipients: N.z.array(iP).default([]).superRefine((e, t) => {
                        let n = {},
                            a = 0;
                        for (let r = 0; r < e.length; r++) {
                            let i = e[r];
                            n[i.address] && t.addIssue({
                                code: N.z.ZodIssueCode.custom,
                                message: "Duplicate address.",
                                path: [r, "address"]
                            }), n[i.address] = !0, (a += i.sharesBps) > 1e4 && t.addIssue({
                                code: N.z.ZodIssueCode.custom,
                                message: "Total shares cannot go over 100%.",
                                path: [r, "sharesBps"]
                            })
                        }
                        1e4 !== a && t.addIssue({
                            code: N.z.ZodIssueCode.custom,
                            message: `Total shares need to add up to 100%. Total shares are currently ${a/100}%`,
                            path: []
                        })
                    })
                }),
                iI = t$.extend({
                    recipients: N.z.array(iL)
                }),
                iM = {
                    deploy: iN.merge(iN).merge(tP),
                    output: iI,
                    input: iN
                },
                iW = tO.merge(t_).merge(tL),
                ij = t$.merge(t_).merge(tL),
                iU = {
                    deploy: iW.merge(tD).merge(tR).merge(tP),
                    output: ij,
                    input: iW
                },
                iV = tO.merge(tL),
                iH = t$.merge(tL),
                iG = {
                    deploy: iV.merge(tD).merge(tR).merge(tP),
                    output: iH,
                    input: iV
                },
                iK = tO.merge(t_).merge(tL),
                iq = t$.merge(t_).merge(tL),
                iJ = {
                    deploy: iK.merge(tD).merge(tR).merge(tP),
                    output: iq,
                    input: iK
                },
                iZ = N.z.object({
                    voting_delay_in_blocks: N.z.number().min(0).default(0),
                    voting_period_in_blocks: N.z.number().min(1).default(1),
                    voting_token_address: tm,
                    voting_quorum_fraction: tC.default(0),
                    proposal_token_threshold: tT.default(1)
                }),
                iX = iZ.extend({
                    proposal_token_threshold: tS
                }),
                iY = tO.merge(iZ),
                iQ = t$.merge(iX),
                i0 = {
                    deploy: iY.merge(tP),
                    output: iQ,
                    input: iY
                },
                i1 = ["admin"],
                i2 = ["admin", "minter", "transfer", "metadata"],
                i5 = ["admin", "lister", "asset"],
                i6 = ["admin", "minter", "asset", "transfer"],
                i8 = ["admin", "transfer"],
                i3 = ["admin", "transfer", "minter", "unwrap", "asset"]
        }
    }
]);