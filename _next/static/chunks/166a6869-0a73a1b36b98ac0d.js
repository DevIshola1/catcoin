"use strict";
(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
    [44429], {
        30781: function(e, t, n) {
            let a, r, i, f, s, o, c, d, l, u, m, p;
            n.d(t, {
                B: function() {
                    return ia
                },
                E: function() {
                    return fF
                },
                G: function() {
                    return i_
                },
                H: function() {
                    return i$
                },
                J: function() {
                    return rh
                },
                K: function() {
                    return ry
                },
                L: function() {
                    return r2
                },
                M: function() {
                    return fS
                },
                N: function() {
                    return fR
                },
                P: function() {
                    return fP
                },
                T: function() {
                    return fN
                },
                V: function() {
                    return fI
                },
                W: function() {
                    return r8
                },
                Y: function() {
                    return nf
                },
                a: function() {
                    return fT
                },
                a0: function() {
                    return ru
                },
                a1: function() {
                    return rV
                },
                a2: function() {
                    return rm
                },
                a4: function() {
                    return n6
                },
                a6: function() {
                    return n2
                },
                a8: function() {
                    return no
                },
                a9: function() {
                    return nc
                },
                aA: function() {
                    return rI
                },
                aB: function() {
                    return rX
                },
                aC: function() {
                    return rQ
                },
                aE: function() {
                    return rY
                },
                aF: function() {
                    return rq
                },
                aG: function() {
                    return rP
                },
                aH: function() {
                    return nh
                },
                aI: function() {
                    return ny
                },
                aJ: function() {
                    return np
                },
                aL: function() {
                    return tb
                },
                aM: function() {
                    return iu
                },
                aO: function() {
                    return iv
                },
                aP: function() {
                    return iz
                },
                aQ: function() {
                    return e5
                },
                aR: function() {
                    return ae
                },
                aS: function() {
                    return rM
                },
                aT: function() {
                    return ng
                },
                aV: function() {
                    return rW
                },
                aW: function() {
                    return rj
                },
                aX: function() {
                    return rU
                },
                aY: function() {
                    return rH
                },
                aZ: function() {
                    return ix
                },
                a_: function() {
                    return ti
                },
                aa: function() {
                    return ni
                },
                ab: function() {
                    return rp
                },
                ah: function() {
                    return iB
                },
                ai: function() {
                    return iO
                },
                aj: function() {
                    return at
                },
                ak: function() {
                    return iD
                },
                am: function() {
                    return tB
                },
                ao: function() {
                    return ir
                },
                ar: function() {
                    return rT
                },
                as: function() {
                    return rS
                },
                at: function() {
                    return rB
                },
                au: function() {
                    return rO
                },
                av: function() {
                    return rR
                },
                aw: function() {
                    return rD
                },
                ax: function() {
                    return r_
                },
                az: function() {
                    return rL
                },
                b: function() {
                    return fB
                },
                b1: function() {
                    return tf
                },
                b3: function() {
                    return tc
                },
                b5: function() {
                    return tO
                },
                b6: function() {
                    return tR
                },
                b8: function() {
                    return tm
                },
                b9: function() {
                    return tp
                },
                bB: function() {
                    return tP
                },
                bD: function() {
                    return t$
                },
                bE: function() {
                    return tN
                },
                bF: function() {
                    return tL
                },
                bG: function() {
                    return tI
                },
                bH: function() {
                    return tM
                },
                bK: function() {
                    return tU
                },
                bL: function() {
                    return tH
                },
                bM: function() {
                    return tV
                },
                bR: function() {
                    return iV
                },
                bV: function() {
                    return iI
                },
                bZ: function() {
                    return iG
                },
                bg: function() {
                    return tZ
                },
                bj: function() {
                    return tX
                },
                bt: function() {
                    return t4
                },
                bw: function() {
                    return ne
                },
                bx: function() {
                    return nt
                },
                c: function() {
                    return fO
                },
                c$: function() {
                    return a5
                },
                c1: function() {
                    return iX
                },
                c5: function() {
                    return i5
                },
                c9: function() {
                    return i7
                },
                cA: function() {
                    return tE
                },
                cB: function() {
                    return tA
                },
                cC: function() {
                    return af
                },
                cD: function() {
                    return aa
                },
                cE: function() {
                    return ao
                },
                cF: function() {
                    return ac
                },
                cG: function() {
                    return as
                },
                cH: function() {
                    return al
                },
                cI: function() {
                    return au
                },
                cJ: function() {
                    return ag
                },
                cK: function() {
                    return aE
                },
                cL: function() {
                    return aw
                },
                cM: function() {
                    return ak
                },
                cN: function() {
                    return am
                },
                cO: function() {
                    return aB
                },
                cP: function() {
                    return aO
                },
                cQ: function() {
                    return aA
                },
                cR: function() {
                    return aC
                },
                cS: function() {
                    return aS
                },
                cT: function() {
                    return ax
                },
                cU: function() {
                    return aF
                },
                cV: function() {
                    return aT
                },
                cW: function() {
                    return ap
                },
                cX: function() {
                    return av
                },
                cY: function() {
                    return aR
                },
                c_: function() {
                    return a6
                },
                cd: function() {
                    return fn
                },
                ch: function() {
                    return i3
                },
                cn: function() {
                    return fs
                },
                cp: function() {
                    return iT
                },
                cq: function() {
                    return iS
                },
                cr: function() {
                    return rb
                },
                cs: function() {
                    return rz
                },
                ct: function() {
                    return rZ
                },
                cu: function() {
                    return e6
                },
                cv: function() {
                    return tz
                },
                cw: function() {
                    return tk
                },
                cx: function() {
                    return ty
                },
                cy: function() {
                    return tv
                },
                cz: function() {
                    return tx
                },
                d: function() {
                    return fD
                },
                d0: function() {
                    return a1
                },
                d1: function() {
                    return aJ
                },
                d2: function() {
                    return a2
                },
                d3: function() {
                    return aX
                },
                d4: function() {
                    return nl
                },
                d5: function() {
                    return aL
                },
                d6: function() {
                    return a_
                },
                d7: function() {
                    return aj
                },
                d8: function() {
                    return nw
                },
                d9: function() {
                    return aD
                },
                dA: function() {
                    return fc
                },
                dB: function() {
                    return fd
                },
                dC: function() {
                    return fm
                },
                dD: function() {
                    return iY
                },
                dE: function() {
                    return a3
                },
                dF: function() {
                    return fl
                },
                dG: function() {
                    return fo
                },
                dH: function() {
                    return fu
                },
                dI: function() {
                    return ij
                },
                da: function() {
                    return aV
                },
                db: function() {
                    return aM
                },
                dc: function() {
                    return aI
                },
                dd: function() {
                    return aU
                },
                de: function() {
                    return aH
                },
                df: function() {
                    return aZ
                },
                dg: function() {
                    return aK
                },
                dh: function() {
                    return rr
                },
                di: function() {
                    return ri
                },
                dj: function() {
                    return rn
                },
                dk: function() {
                    return a4
                },
                dl: function() {
                    return rf
                },
                dm: function() {
                    return rs
                },
                dn: function() {
                    return ro
                },
                dp: function() {
                    return aQ
                },
                dq: function() {
                    return iE
                },
                dr: function() {
                    return il
                },
                ds: function() {
                    return ii
                },
                dt: function() {
                    return is
                },
                du: function() {
                    return io
                },
                dv: function() {
                    return a7
                },
                dw: function() {
                    return re
                },
                dx: function() {
                    return rt
                },
                dy: function() {
                    return rG
                },
                dz: function() {
                    return tw
                },
                e: function() {
                    return f_
                },
                f: function() {
                    return f$
                },
                g: function() {
                    return fL
                },
                h: function() {
                    return fW
                },
                i: function() {
                    return fj
                },
                j: function() {
                    return fV
                },
                k: function() {
                    return fG
                },
                n: function() {
                    return r0
                },
                o: function() {
                    return r1
                },
                s: function() {
                    return r6
                },
                t: function() {
                    return r5
                },
                w: function() {
                    return r3
                },
                x: function() {
                    return r9
                },
                y: function() {
                    return r4
                },
                z: function() {
                    return r7
                }
            });
            var b, g, h = n(40739),
                y = n(36173),
                w = n(46396),
                E = n(84062),
                k = n(32114),
                A = n(49022),
                C = n(89005),
                v = n(22594),
                z = n(12045),
                x = n(83077),
                F = n(28257),
                T = n(9784),
                S = n(43481),
                B = n(93850),
                O = n(99554),
                R = n(40582),
                D = n(87847),
                P = n(83531),
                _ = n(88849),
                $ = n(6352),
                N = n(75986),
                L = n(59772),
                I = n(42321);
            n(99292);
            var M = n(59811),
                W = n(55387),
                j = n.n(W),
                U = n(27219),
                H = n.n(U),
                V = n(83230),
                G = n(58478),
                K = n(90863),
                Z = n(4129),
                Y = n(56335),
                q = n(54497),
                J = n(38649),
                X = n(4470),
                Q = n(10205),
                ee = n(57101),
                et = n(61053),
                en = n(62281),
                ea = n(29691),
                er = n(28329),
                ei = n(99818),
                ef = n(32557),
                es = n(18125),
                eo = n(62984),
                ec = n(41730),
                ed = n(50021),
                el = n(4188),
                eu = n(1377),
                em = n(63393),
                ep = n(29293),
                eb = n(81570),
                eg = n(56535),
                eh = n(78694),
                ey = n(2093),
                ew = n(19115),
                eE = n(88049),
                ek = n(1728),
                eA = n(17845),
                eC = n(39046),
                ev = n(60805),
                ez = n(18128),
                ex = n(10506),
                eF = n(31617),
                eT = n(38925),
                eS = n(56011),
                eB = n(46929),
                eO = n(5053),
                eR = n(73496),
                eD = n(23194),
                eP = n(9748),
                e_ = n(96409),
                e$ = n(97463),
                eN = n(60027),
                eL = n(75581),
                eI = n(24857),
                eM = n(65313),
                eW = n(44662),
                ej = n(77438),
                eU = n(91671),
                eH = n(46083),
                eV = n(68133),
                eG = n(98730),
                eK = n(15560),
                eZ = n(92063),
                eY = n(26644),
                eq = n(5246),
                eJ = n(97258),
                eX = n(89741),
                eQ = n(60433),
                e0 = n(25566),
                e1 = n(9109).Buffer;

            function e6(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
                return void 0 !== e0 && e0.env[e] ? e0.env[e] : t
            }

            function e5() {
                return e6("contractPublisherAddress", "0xf5b896Ddb5146D5dA77efF4efBb3Eae36E300808")
            }

            function e2(e) {
                return !!(e && e._isSigner)
            }

            function e8(e) {
                return !!(e && e._isProvider)
            }
            let e3 = {
                timeLimitMs: 50,
                sizeLimit: 250
            };
            class e9 extends h.c {
                constructor(e, t) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e3;
                    super(e, t), this._timeLimitMs = n.timeLimitMs || 250, this._sizeLimit = n.sizeLimit || 50, this._pendingBatchAggregator = null, this._pendingBatch = null
                }
                sendCurrentBatch(e) {
                    this._pendingBatchAggregator && clearTimeout(this._pendingBatchAggregator);
                    let t = this._pendingBatch || [];
                    this._pendingBatch = null, this._pendingBatchAggregator = null;
                    let n = t.map(e => e.request);
                    return this.emit("debug", {
                        action: "requestBatch",
                        request: y.deepCopy(e),
                        provider: this
                    }), w.fetchJson(this.connection, JSON.stringify(n)).then(e => {
                        this.emit("debug", {
                            action: "response",
                            request: n,
                            response: e,
                            provider: this
                        }), t.forEach((t, n) => {
                            let a = e[n];
                            if (a) {
                                if (a.error) {
                                    let e = Error(a.error.message);
                                    e.code = a.error.code, e.data = a.error.data, t.reject(e)
                                } else t.resolve(a.result)
                            } else t.reject(Error("No response for request"))
                        })
                    }, e => {
                        this.emit("debug", {
                            action: "response",
                            error: e,
                            request: n,
                            provider: this
                        }), t.forEach(t => {
                            t.reject(e)
                        })
                    })
                }
                send(e, t) {
                    let n = {
                        method: e,
                        params: t,
                        id: this._nextId++,
                        jsonrpc: "2.0"
                    };
                    null === this._pendingBatch && (this._pendingBatch = []);
                    let a = {
                            request: n,
                            resolve: null,
                            reject: null
                        },
                        r = new Promise((e, t) => {
                            a.resolve = e, a.reject = t
                        });
                    return this._pendingBatch.push(a), this._pendingBatch.length === this._sizeLimit && this.sendCurrentBatch(n), this._pendingBatchAggregator || (this._pendingBatchAggregator = setTimeout(() => {
                        this.sendCurrentBatch(n)
                    }, this._timeLimitMs)), r
                }
            }
            let e4 = L.z.object({
                    rpc: L.z.array(L.z.string().url()),
                    chainId: L.z.number(),
                    nativeCurrency: L.z.object({
                        name: L.z.string(),
                        symbol: L.z.string(),
                        decimals: L.z.number()
                    }),
                    slug: L.z.string()
                }),
                e7 = L.z.object({
                    supportedChains: L.z.array(e4).default(I.gL9),
                    clientId: L.z.string().optional(),
                    secretKey: L.z.string().optional(),
                    readonlySettings: L.z.object({
                        rpcUrl: L.z.string().url(),
                        chainId: L.z.number().optional()
                    }).optional(),
                    gasSettings: L.z.object({
                        maxPriceInGwei: L.z.number().min(1, "gas price cannot be less than 1").default(300),
                        speed: L.z.enum(["standard", "fast", "fastest"]).default("fastest")
                    }).default({
                        maxPriceInGwei: 300,
                        speed: "fastest"
                    }),
                    gasless: L.z.union([L.z.object({
                        openzeppelin: L.z.object({
                            relayerUrl: L.z.string().url(),
                            relayerForwarderAddress: L.z.string().optional(),
                            useEOAForwarder: L.z.boolean().default(!1),
                            domainName: L.z.string().default("GSNv2 Forwarder"),
                            domainVersion: L.z.string().default("0.0.1")
                        }),
                        experimentalChainlessSupport: L.z.boolean().default(!1)
                    }), L.z.object({
                        biconomy: L.z.object({
                            apiId: L.z.string(),
                            apiKey: L.z.string(),
                            deadlineSeconds: L.z.number().min(1, "deadlineSeconds cannot be les than 1").default(3600)
                        })
                    }), L.z.object({
                        engine: L.z.object({
                            relayerUrl: L.z.string().url().transform(e => e.replace(/\/$/, ""))
                        })
                    })]).optional(),
                    gatewayUrls: L.z.array(L.z.string()).optional()
                }).default({
                    gasSettings: {
                        maxPriceInGwei: 300,
                        speed: "fastest"
                    }
                });
            var te = {
                name: "@thirdweb-dev/sdk",
                version: "4.0.31"
            };
            let tt = [
                ["iOS", /iP(hone|od|ad)/],
                ["Android OS", /Android/],
                ["BlackBerry OS", /BlackBerry|BB10/],
                ["Windows Mobile", /IEMobile/],
                ["Amazon OS", /Kindle/],
                ["Windows 3.11", /Win16/],
                ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
                ["Windows 98", /(Windows 98)|(Win98)/],
                ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
                ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
                ["Windows Server 2003", /(Windows NT 5.2)/],
                ["Windows Vista", /(Windows NT 6.0)/],
                ["Windows 7", /(Windows NT 6.1)/],
                ["Windows 8", /(Windows NT 6.2)/],
                ["Windows 8.1", /(Windows NT 6.3)/],
                ["Windows 10", /(Windows NT 10.0)/],
                ["Windows ME", /Windows ME/],
                ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
                ["Open BSD", /OpenBSD/],
                ["Sun OS", /SunOS/],
                ["Chrome OS", /CrOS/],
                ["Linux", /(Linux)|(X11)/],
                ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
                ["QNX", /QNX/],
                ["BeOS", /BeOS/],
                ["OS/2", /OS\/2/]
            ];

            function tn() {
                return "undefined" != typeof navigator && "ReactNative" === navigator.product ? "" : function(e) {
                    for (let t = 0, n = tt.length; t < n; t++) {
                        let n = tt[t];
                        if (!n) continue;
                        let [a, r] = n;
                        if (r.exec(e)) return a
                    }
                    return null
                }(navigator.userAgent) || ""
            }

            function ta() {
                return "undefined" == typeof globalThis ? {
                    x_sdk_name: te.name,
                    x_sdk_platform: tr(),
                    x_sdk_version: te.version,
                    x_sdk_os: tn(),
                    app_bundle_id: void 0
                } : (void 0 === globalThis.X_SDK_NAME && (globalThis.X_SDK_NAME = te.name, globalThis.X_SDK_PLATFORM = tr(), globalThis.X_SDK_VERSION = te.version, globalThis.X_SDK_OS = tn(), globalThis.APP_BUNDLE_ID = void 0), {
                    x_sdk_name: globalThis.X_SDK_NAME,
                    x_sdk_platform: globalThis.X_SDK_PLATFORM,
                    x_sdk_version: globalThis.X_SDK_VERSION,
                    x_sdk_os: globalThis.X_SDK_OS,
                    app_bundle_id: globalThis.APP_BUNDLE_ID || ""
                })
            }

            function tr() {
                return "undefined" != typeof navigator && "ReactNative" === navigator.product ? "mobile" : "browser"
            }

            function ti(e, t) {
                let n;
                if ("string" == typeof e && function(e) {
                        let t = e.match(/^(ws|http)s?:/i);
                        if (t) switch (t[1].toLowerCase()) {
                            case "http":
                            case "https":
                            case "ws":
                            case "wss":
                                return !0
                        }
                        return !1
                    }(e)) return to(e, t);
                let a = e7.parse(t);
                tf(e) && (a.supportedChains = [e, ...a.supportedChains.filter(t => t.chainId === e.chainId)]);
                let r = a.supportedChains.reduce((e, t) => (e[t.chainId] = t, e), {}),
                    i = "";
                try {
                    n = function(e, t) {
                        if (tf(e)) return e.chainId;
                        if ("number" == typeof e) return e; {
                            let n = t.supportedChains.reduce((e, t) => (e[t.slug] = t.chainId, e), {});
                            if (e in n) return n[e]
                        }
                        throw Error(`Cannot resolve chainId from: ${e} - please pass the chainId instead and specify it in the 'supportedChains' property of the SDK options.`)
                    }(e, a), i = (0, I.OZ$)(r[n], a.clientId)[0]
                } catch (e) {}
                if (i || (i = `https://${n||e}.rpc.thirdweb.com/${a.clientId||""}`), !i) throw Error(`No rpc url found for chain ${e}. Please provide a valid rpc url via the 'supportedChains' property of the sdk options.`);
                return to(i, t, n)
            }

            function tf(e) {
                return "string" != typeof e && "number" != typeof e && !e2(e) && !e8(e)
            }
            let ts = new Map;

            function to(e, t, n) {
                try {
                    var a;
                    let r = {},
                        i = "none";
                    if (a = e, new URL(a).hostname.endsWith(".thirdweb.com")) {
                        if (t ? .secretKey) throw Error("Cannot use secretKey in browser context");
                        if (t ? .clientId) {
                            let n = new URL(e);
                            n.pathname = t.clientId, r["x-client-id"] = t.clientId, e = n.toString(), i = "clientId"
                        }
                        "undefined" != typeof globalThis && "TW_AUTH_TOKEN" in globalThis && "string" == typeof globalThis.TW_AUTH_TOKEN && (r.authorization = `Bearer ${globalThis.TW_AUTH_TOKEN}`, i = "twAuthToken"), "undefined" != typeof globalThis && "TW_CLI_AUTH_TOKEN" in globalThis && "string" == typeof globalThis.TW_CLI_AUTH_TOKEN && (r["x-authorize-wallet"] = "true"),
                            function(e) {
                                let t = ta();
                                e["x-sdk-version"] = t.x_sdk_version, e["x-sdk-name"] = t.x_sdk_name, e["x-sdk-platform"] = t.x_sdk_platform, e["x-sdk-os"] = t.x_sdk_os
                            }(r);
                        let n = "undefined" != typeof globalThis && "APP_BUNDLE_ID" in globalThis ? globalThis.APP_BUNDLE_ID : void 0;
                        e.includes("bundleId") || (e += n ? `?bundleId=${n}` : "")
                    }
                    let f = e.match(/^(ws|http)s?:/i);
                    if (f) switch (f[1].toLowerCase()) {
                        case "http":
                        case "https":
                            let s = `${e}-${n||-1}-${i}`,
                                o = ts.get(s);
                            if (o) return o;
                            let c = !1;
                            "undefined" != typeof globalThis && "TW_SKIP_FETCH_SETUP" in globalThis && "boolean" == typeof globalThis.TW_SKIP_FETCH_SETUP && (c = globalThis.TW_SKIP_FETCH_SETUP);
                            let d = n ? new e9({
                                url: e,
                                headers: r,
                                skipFetchSetup: c
                            }, n) : new E.I({
                                url: e,
                                headers: r,
                                skipFetchSetup: c
                            });
                            return ts.set(s, d), d;
                        case "ws":
                        case "wss":
                            return new k.q(e, n)
                    }
                } catch (e) {}
                return A.getDefaultProvider(e)
            }

            function tc(e, t) {
                let n, a;
                if (e2(e) ? (n = e, e.provider && (a = e.provider)) : a = e8(e) ? e : ti(e, t), t ? .readonlySettings && (a = to(t.readonlySettings.rpcUrl, t, t.readonlySettings.chainId)), !a) {
                    if (n) throw Error("No provider passed to the SDK! Please make sure that your signer is connected to a provider!");
                    throw Error("No provider found! Make sure to specify which network to connect to, or pass a signer or provider to the SDK!")
                }
                return [n, a]
            }
            let td = new Map;
            async function tl(e) {
                let t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                a || (a = tc("ethereum")[1]), t = td.has(e) ? td.get(e) : a.resolveName(e).then(e => e ? {
                    address: e,
                    expirationTime: new Date(Date.now() + 3e5)
                } : {
                    address: null,
                    expirationTime: new Date(Date.now() + 3e4)
                });
                let r = await t;
                return r.expirationTime < new Date && (td.delete(e), 0 === n && tl(e, n + 1)), r.address
            }
            let tu = L.z.custom(e => "string" == typeof e && (e.endsWith(".eth") || e.endsWith(".cb.id"))).transform(async e => tl(e)).refine(e => !!e && C.isAddress(e), {
                    message: "Provided value was not a valid ENS name"
                }),
                tm = L.z.custom(e => "string" == typeof e && C.isAddress(e), e => ({
                    message: `${e} is not a valid address`
                })),
                tp = L.z.union([tm, tu], {
                    invalid_type_error: "Provided value was not a valid address or ENS name"
                });
            async function tb(e) {
                return tp.parseAsync(e)
            }
            let tg = L.z.instanceof(File),
                th = L.z.union([tg, L.z.object({
                    data: L.z.union([tg, L.z.string()]),
                    name: L.z.string()
                })]),
                ty = L.z.union([th, L.z.string()]),
                tw = 1e4,
                tE = L.z.union([L.z.array(L.z.number()), L.z.string()]),
                tk = L.z.union([L.z.bigint(), L.z.custom(e => v.O$.isBigNumber(e)), L.z.custom(e => j().isBN(e))]).transform(e => j().isBN(e) ? new(j())(e).toString() : v.O$.from(e).toString()),
                tA = L.z.number().max(tw, "Cannot exceed 100%").min(0, "Cannot be below 0%"),
                tC = L.z.number().max(100, "Cannot exceed 100%").min(0, "Cannot be below 0%"),
                tv = L.z.union([L.z.string().regex(/^([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, "Invalid hex color"), L.z.string().regex(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, "Invalid hex color").transform(e => e.replace("#", "")), L.z.string().length(0)]),
                tz = L.z.union([L.z.string().regex(/^([0-9]+\.?[0-9]*|\.[0-9]+)$/, "Invalid amount"), L.z.number().min(0, "Amount cannot be negative")]).transform(e => "number" == typeof e ? e.toString() : e),
                tx = L.z.union([tz, L.z.literal("unlimited")]).default("unlimited"),
                tF = "0|[1-9]\\d*",
                tT = RegExp(`(${tF})\\.(${tF})\\.(${tF})`);

            function tS(e) {
                if (e.length > 256) throw Error("version is longer than 256 characters");
                let t = e.trim().match(tT);
                if (!t || t ? .length !== 4) throw Error(`${e} is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`);
                let n = Number(t[1]),
                    a = Number(t[2]),
                    r = Number(t[3]),
                    i = [n, a, r].join(".");
                return {
                    major: n,
                    minor: a,
                    patch: r,
                    versionString: i
                }
            }

            function tB(e, t) {
                let n = tS(e),
                    a = tS(t);
                if (a.major > n.major) return !0;
                let r = a.major === n.major;
                if (r && a.minor > n.minor) return !0;
                let i = a.minor === n.minor;
                return r && i && a.patch > n.patch
            }
            let tO = L.z.union([L.z.string(), L.z.number(), L.z.bigint(), L.z.custom(e => v.O$.isBigNumber(e))]).transform(e => v.O$.from(e)),
                tR = tO.transform(e => e.toString()),
                tD = L.z.union([L.z.bigint(), L.z.custom(e => v.O$.isBigNumber(e))]).transform(e => v.O$.from(e).toString()),
                tP = L.z.object({
                    name: L.z.string(),
                    description: L.z.string().optional(),
                    image: ty.optional(),
                    external_link: L.z.string().optional(),
                    app_uri: L.z.string().optional(),
                    social_urls: L.z.record(L.z.string()).optional()
                }).catchall(L.z.unknown()),
                t_ = tP.extend({
                    image: L.z.string().optional()
                }).catchall(L.z.unknown()),
                t$ = L.z.object({
                    seller_fee_basis_points: tA.default(0),
                    fee_recipient: tp.default(z.d)
                }),
                tN = L.z.object({
                    primary_sale_recipient: tp.default(z.d)
                }),
                tL = L.z.object({
                    platform_fee_basis_points: tA.default(0),
                    platform_fee_recipient: tp.default(z.d)
                }),
                tI = L.z.object({
                    trusted_forwarders: L.z.array(tp).default([])
                }),
                tM = L.z.object({
                    symbol: L.z.string().default("")
                }),
                tW = L.z.object({
                    merkle: L.z.record(L.z.string()).default({})
                }),
                tj = L.z.object({
                    address: tp,
                    maxClaimable: tx.default(0),
                    price: tx.optional(),
                    currencyAddress: tp.default(z.d).optional()
                }),
                tU = L.z.union([L.z.array(L.z.string()).transform(async e => await Promise.all(e.map(e => tj.parseAsync({
                    address: e
                })))), L.z.array(tj)]),
                tH = tj.extend({
                    proof: L.z.array(L.z.string())
                }),
                tV = L.z.object({
                    merkleRoot: L.z.string(),
                    claims: L.z.array(tH)
                }),
                tG = tP.catchall(L.z.union([tD, L.z.unknown()])).merge(t$.merge(tW).merge(tM).partial()).catchall(L.z.any()),
                tK = t_.merge(t$.merge(tW).merge(tM).partial()).catchall(L.z.any()),
                tZ = {
                    deploy: tG.merge(tL.merge(tN).merge(tI).partial()),
                    output: tK,
                    input: tG
                },
                tY = L.z.object({
                    type: L.z.string(),
                    name: L.z.string().default("")
                }).catchall(L.z.any()),
                tq = tY.extend({
                    stateMutability: L.z.string().optional(),
                    components: L.z.array(tY).optional()
                }).catchall(L.z.any()),
                tJ = L.z.object({
                    type: L.z.string(),
                    name: L.z.string().default(""),
                    inputs: L.z.array(tq).default([]),
                    outputs: L.z.array(tq).default([])
                }).catchall(L.z.any()),
                tX = L.z.array(tJ),
                tQ = L.z.object({
                    name: L.z.string(),
                    metadataUri: L.z.string(),
                    bytecodeUri: L.z.string(),
                    analytics: L.z.any().optional()
                }).catchall(L.z.any()),
                t0 = L.z.record(L.z.string(), L.z.string()),
                t1 = L.z.object({
                    factoryFunction: L.z.string(),
                    params: L.z.array(L.z.object({
                        name: L.z.string(),
                        type: L.z.string()
                    })).default([]),
                    customFactoryAddresses: t0
                }),
                t6 = L.z.object({
                    implementationAddresses: t0,
                    implementationInitializerFunction: L.z.string().default("initialize"),
                    customFactoryInput: t1.optional(),
                    factoryAddresses: t0.optional()
                }),
                t5 = L.z.union([L.z.literal("standard"), L.z.literal("autoFactory"), L.z.literal("customFactory")]),
                t2 = L.z.union([L.z.literal("none"), L.z.literal("plugin"), L.z.literal("dynamic")]),
                t8 = L.z.object({
                    allNetworks: L.z.boolean().optional(),
                    networksEnabled: L.z.array(L.z.number()).default([])
                }),
                t3 = L.z.object({
                    version: L.z.string().refine(e => {
                        try {
                            return tS(e), !0
                        } catch (e) {
                            return !1
                        }
                    }, e => ({
                        message: `'${e}' is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`
                    })),
                    displayName: L.z.string().optional(),
                    description: L.z.string().optional(),
                    readme: L.z.string().optional(),
                    license: L.z.string().optional(),
                    changelog: L.z.string().optional(),
                    tags: L.z.array(L.z.string()).optional(),
                    audit: ty.nullable().optional(),
                    logo: ty.nullable().optional(),
                    isDeployableViaFactory: L.z.boolean().optional(),
                    isDeployableViaProxy: L.z.boolean().optional(),
                    factoryDeploymentData: t6.optional(),
                    deployType: t5.optional(),
                    routerType: t2.optional(),
                    defaultExtensions: L.z.array(L.z.object({
                        extensionName: L.z.string(),
                        extensionVersion: L.z.string().default("latest"),
                        publisherAddress: tp
                    })).optional(),
                    networksForDeployment: t8.optional(),
                    constructorParams: L.z.record(L.z.string(), L.z.object({
                        displayName: L.z.string().optional(),
                        description: L.z.string().optional(),
                        defaultValue: L.z.string().optional(),
                        hidden: L.z.boolean().optional()
                    }).catchall(L.z.any())).optional(),
                    compositeAbi: tX.optional()
                }).catchall(L.z.any()),
                t9 = t3.extend({
                    audit: L.z.string().nullable().optional(),
                    logo: L.z.string().nullable().optional()
                }),
                t4 = tQ.merge(t3).extend({
                    publisher: tp.optional()
                }),
                t7 = tQ.merge(t9).extend({
                    publisher: tp.optional()
                }),
                ne = L.z.object({
                    name: L.z.string().optional(),
                    bio: L.z.string().optional(),
                    avatar: ty.nullable().optional(),
                    website: L.z.string().optional(),
                    twitter: L.z.string().optional(),
                    telegram: L.z.string().optional(),
                    facebook: L.z.string().optional(),
                    github: L.z.string().optional(),
                    medium: L.z.string().optional(),
                    linkedin: L.z.string().optional(),
                    reddit: L.z.string().optional(),
                    discord: L.z.string().optional()
                }).extend({
                    avatar: L.z.string().nullable().optional()
                }),
                nt = L.z.object({
                    id: L.z.string(),
                    timestamp: tR,
                    metadataUri: L.z.string()
                }),
                nn = L.z.object({
                    title: L.z.string().optional(),
                    author: L.z.string().optional(),
                    details: L.z.string().optional(),
                    notice: L.z.string().optional()
                }),
                na = L.z.object({
                    name: L.z.string(),
                    abi: tX,
                    metadata: L.z.record(L.z.string(), L.z.any()),
                    info: nn,
                    licenses: L.z.array(L.z.string().optional()).default([]).transform(e => e.filter(e => void 0 !== e)),
                    isPartialAbi: L.z.boolean().optional()
                }),
                nr = tQ.merge(na).extend({
                    bytecode: L.z.string()
                });
            async function ni(e, t) {
                let n = await (await t.download(e)).text();
                return t7.parse(JSON.parse(n))
            }
            async function nf(e, t) {
                let n = await t.downloadJSON(e, {
                    timeoutInSeconds: 2
                });
                if (!n || !n.output) throw Error(`Could not resolve metadata for contract at ${e}`);
                return ns(n)
            }

            function ns(e) {
                let t = tX.parse(e.output.abi),
                    n = e.settings.compilationTarget,
                    a = Object.keys(n),
                    r = n[a[0]],
                    i = nn.parse({
                        title: e.output.devdoc.title,
                        author: e.output.devdoc.author,
                        details: e.output.devdoc.detail,
                        notice: e.output.userdoc.notice
                    }),
                    f = [...new Set(Object.entries(e.sources).map(e => {
                        let [, t] = e;
                        return t.license
                    }))];
                return {
                    name: r,
                    abi: t,
                    metadata: e,
                    info: i,
                    licenses: f,
                    isPartialAbi: e.isPartialAbi
                }
            }
            async function no(e, t) {
                return tQ.parse(JSON.parse(await (await t.download(e)).text()))
            }
            async function nc(e, t) {
                let n = await no(e, t),
                    a = await (await t.download(n.bytecodeUri)).text(),
                    r = await nf(n.metadataUri, t);
                return nr.parse({ ...n,
                    ...r,
                    bytecode: a
                })
            }
            let nd = () => !0,
                nl = () => !nd();

            function nu(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Map;
                return {
                    put: function(n, a) {
                        if (t.size >= e) {
                            let e = t.keys().next().value;
                            t.delete(e)
                        }
                        t.set(n, a)
                    },
                    get: function(e) {
                        if (!t.has(e)) return;
                        let n = t.get(e);
                        return t.delete(e), t.set(e, n), n
                    },
                    has: function(e) {
                        return t.has(e)
                    },
                    maxEntries: e,
                    store: t
                }
            }
            let nm = nu(20);
            async function np(e, t) {
                let n;
                let a = nm.get(e);
                if (a) return a;
                let r = await nc(e, t);
                try {
                    n = await ni(e, t)
                } catch (e) {}
                let i = {
                    compilerMetadata: r,
                    extendedMetadata: n
                };
                return nm.put(e, i), i
            }
            let nb = I.gL9;

            function ng(e) {
                nb = e && e.length > 0 ? e : I.gL9
            }
            let nh = "0xdd99b75f095d0c4d5112aCe938e4e6ed962fb024";
            async function ny(e, t) {
                let a, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "latest",
                    i = arguments.length > 3 ? arguments[3] : void 0,
                    f = arguments.length > 4 ? arguments[4] : void 0,
                    s = arguments.length > 5 ? arguments[5] : void 0,
                    o = nb.find(e => 137 === e.chainId) || I.mgq,
                    c = await tb(e),
                    d = (await Promise.resolve().then(n.t.bind(n, 46762, 19))).default,
                    l = new x.CH(e5(), d, ti(o, {
                        clientId: f,
                        secretKey: s
                    }));
                if (r && "latest" !== r) {
                    let e = (await l.getPublishedContractVersions(c, t)).map(e => nt.parse({
                            id: e.contractId,
                            timestamp: e.publishTimestamp,
                            metadataUri: e.publishMetadataUri
                        })),
                        n = (await Promise.all(e.map(e => np(e.metadataUri, i)))).map((t, n) => ({
                            name: e[n].id,
                            publishedTimestamp: e[n].timestamp,
                            publishedMetadata: t
                        })).find(e => e.publishedMetadata.extendedMetadata ? .version === r);
                    (0, M.Z)(n, "Contract version not found"), a = e.find(e => e.timestamp === n.publishedTimestamp)
                } else {
                    let e = await l.getPublishedContract(c, t);
                    a = nt.parse({
                        id: e.contractId,
                        timestamp: e.publishTimestamp,
                        metadataUri: e.publishMetadataUri
                    })
                }
                if (!a) throw Error(`No published contract found for ${t} at version by '${nh}'`);
                return a
            }
            async function nw(e, t) {
                try {
                    let a = (await n.e(74939).then(n.t.bind(n, 74939, 19))).default,
                        r = new x.CH(e, a, t),
                        [i, f] = await Promise.all([r.contractType(), r.contractVersion()]);
                    return {
                        type: F.ZN(i).replace(/\x00/g, ""),
                        version: f
                    }
                } catch (e) {
                    return
                }
            }
            try {
                r = new TextDecoder
            } catch (e) {}
            let nE = 0,
                nk = {},
                nA = {},
                nC = 0,
                nv = 0,
                nz = [],
                nx = [],
                nF = {
                    useRecords: !1,
                    mapsAsObjects: !0
                },
                nT = !1;
            class nS {
                constructor(e) {
                    if (e && ((e.keyMap || e._keyMap) && !e.useRecords && (e.useRecords = !1, e.mapsAsObjects = !0), !1 === e.useRecords && void 0 === e.mapsAsObjects && (e.mapsAsObjects = !0), e.getStructures && (e.getShared = e.getStructures), e.getShared && !e.structures && ((e.structures = []).uninitialized = !0), e.keyMap))
                        for (let [t, n] of (this.mapKey = new Map, Object.entries(e.keyMap))) this.mapKey.set(n, t);
                    Object.assign(this, e)
                }
                decodeKey(e) {
                    return this.keyMap && this.mapKey.get(e) || e
                }
                decode(e, t) {
                    if (i) return nJ(() => (nX(), this ? this.decode(e, t) : nS.prototype.decode.call(nF, e, t)));
                    f = t > -1 ? t : e.length, nE = 0, nv = 0, o = null, c = null, i = e;
                    try {
                        u = e.dataView || (e.dataView = new DataView(e.buffer, e.byteOffset, e.byteLength))
                    } catch (t) {
                        if (i = null, e instanceof Uint8Array) throw t;
                        throw Error("Source must be a Uint8Array or Buffer but was a " + (e && "object" == typeof e ? e.constructor.name : typeof e))
                    }
                    return this instanceof nS ? (nA = this, l = this.sharedValues && (this.pack ? Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues), this.structures ? s = this.structures : (!s || s.length > 0) && (s = [])) : (nA = nF, (!s || s.length > 0) && (s = []), l = null),
                        function() {
                            try {
                                let e = nB();
                                if (c) {
                                    if (nE >= c.postBundlePosition) {
                                        let e = Error("Unexpected bundle position");
                                        throw e.incomplete = !0, e
                                    }
                                    nE = c.postBundlePosition, c = null
                                }
                                if (nE == f) s = null, i = null, d && (d = null);
                                else if (nE > f) {
                                    let e = Error("Unexpected end of CBOR data");
                                    throw e.incomplete = !0, e
                                } else if (!nT) throw Error("Data read, but end of buffer not reached");
                                return e
                            } catch (e) {
                                throw nX(), (e instanceof RangeError || e.message.startsWith("Unexpected end of buffer")) && (e.incomplete = !0), e
                            }
                        }()
                }
            }

            function nB() {
                let e = i[nE++],
                    t = e >> 5;
                if ((e &= 31) > 23) switch (e) {
                    case 24:
                        e = i[nE++];
                        break;
                    case 25:
                        if (7 == t) return function() {
                            let e = i[nE++],
                                t = i[nE++],
                                n = (127 & e) >> 2;
                            if (31 === n) return t || 3 & e ? NaN : 128 & e ? -1 / 0 : 1 / 0;
                            if (0 === n) {
                                let n = ((3 & e) << 8 | t) / 16777216;
                                return 128 & e ? -n : n
                            }
                            return nI[3] = 128 & e | (n >> 1) + 56, nI[2] = (7 & e) << 5 | t >> 3, nI[1] = t << 5, nI[0] = 0, nL[0]
                        }();
                        e = u.getUint16(nE), nE += 2;
                        break;
                    case 26:
                        if (7 == t) {
                            let e = u.getFloat32(nE);
                            if (nA.useFloat32 > 2) {
                                let t = nQ[(127 & i[nE]) << 1 | i[nE + 1] >> 7];
                                return nE += 4, (t * e + (e > 0 ? .5 : -.5) >> 0) / t
                            }
                            return nE += 4, e
                        }
                        e = u.getUint32(nE), nE += 4;
                        break;
                    case 27:
                        if (7 == t) {
                            let e = u.getFloat64(nE);
                            return nE += 8, e
                        }
                        if (t > 1) {
                            if (u.getUint32(nE) > 0) throw Error("JavaScript does not support arrays, maps, or strings with length over 4294967295");
                            e = u.getUint32(nE + 4)
                        } else e = nA.int64AsNumber ? 4294967296 * u.getUint32(nE) + u.getUint32(nE + 4) : u.getBigUint64(nE);
                        nE += 8;
                        break;
                    case 31:
                        switch (t) {
                            case 2:
                            case 3:
                                throw Error("Indefinite length not supported for byte or text strings");
                            case 4:
                                let n = [],
                                    a, r = 0;
                                for (;
                                    (a = nB()) != nk;) n[r++] = a;
                                return 4 == t ? n : 3 == t ? n.join("") : e1.concat(n);
                            case 5:
                                let d;
                                if (nA.mapsAsObjects) {
                                    let e = {};
                                    if (nA.keyMap)
                                        for (;
                                            (d = nB()) != nk;) e[nD(nA.decodeKey(d))] = nB();
                                    else
                                        for (;
                                            (d = nB()) != nk;) e[nD(d)] = nB();
                                    return e
                                } {
                                    m && (nA.mapsAsObjects = !0, m = !1);
                                    let e = new Map;
                                    if (nA.keyMap)
                                        for (;
                                            (d = nB()) != nk;) e.set(nA.decodeKey(d), nB());
                                    else
                                        for (;
                                            (d = nB()) != nk;) e.set(d, nB());
                                    return e
                                }
                            case 7:
                                return nk;
                            default:
                                throw Error("Invalid major type for indefinite length " + t)
                        }
                    default:
                        throw Error("Unknown token " + e)
                }
                switch (t) {
                    case 0:
                        return e;
                    case 1:
                        return ~e;
                    case 2:
                        var p;
                        return p = e, nA.copyBuffers ? Uint8Array.prototype.slice.call(i, nE, nE += p) : i.subarray(nE, nE += p);
                    case 3:
                        if (nv >= nE) return o.slice(nE - nC, (nE += e) - nC);
                        if (0 == nv && f < 140 && e < 32) {
                            let t = e < 16 ? nN(e) : function(e) {
                                let t = nE,
                                    n = Array(e);
                                for (let a = 0; a < e; a++) {
                                    let e = i[nE++];
                                    if ((128 & e) > 0) {
                                        nE = t;
                                        return
                                    }
                                    n[a] = e
                                }
                                return n$.apply(String, n)
                            }(e);
                            if (null != t) return t
                        }
                        return nP(e);
                    case 4:
                        let b = Array(e);
                        for (let t = 0; t < e; t++) b[t] = nB();
                        return b;
                    case 5:
                        if (nA.mapsAsObjects) {
                            let t = {};
                            if (nA.keyMap)
                                for (let n = 0; n < e; n++) t[nD(nA.decodeKey(nB()))] = nB();
                            else
                                for (let n = 0; n < e; n++) t[nD(nB())] = nB();
                            return t
                        } {
                            m && (nA.mapsAsObjects = !0, m = !1);
                            let t = new Map;
                            if (nA.keyMap)
                                for (let n = 0; n < e; n++) t.set(nA.decodeKey(nB()), nB());
                            else
                                for (let n = 0; n < e; n++) t.set(nB(), nB());
                            return t
                        }
                    case 6:
                        if (e >= 57337) {
                            let t = s[8191 & e];
                            if (t) return t.read || (t.read = nR(t)), t.read();
                            if (e < 65536) {
                                if (57343 == e) return nW(nB());
                                if (57342 == e) {
                                    let e = nY(),
                                        t = nB();
                                    for (let n = 2; n < e; n++) nW([t++, nB()]);
                                    return nB()
                                }
                                if (57337 == e) return function() {
                                    let e = nY(),
                                        t = nE + nB();
                                    for (let t = 2; t < e; t++) {
                                        let e = nY();
                                        nE += e
                                    }
                                    let n = nE;
                                    return nE = t, (c = [n_(nY()), n_(nY())]).position0 = 0, c.position1 = 0, c.postBundlePosition = nE, nE = n, nB()
                                }();
                                if (nA.getShared && (nq(), t = s[8191 & e])) return t.read || (t.read = nR(t)), t.read()
                            }
                        }
                        let g = nz[e];
                        if (g) {
                            if (g.handlesRead) return g(nB);
                            return g(nB())
                        } {
                            let t = nB();
                            for (let n = 0; n < nx.length; n++) {
                                let a = nx[n](e, t);
                                if (void 0 !== a) return a
                            }
                            return new nM(t, e)
                        }
                    case 7:
                        switch (e) {
                            case 20:
                                return !1;
                            case 21:
                                return !0;
                            case 22:
                                return null;
                            case 23:
                                return;
                            default:
                                let h = (l || nV())[e];
                                if (void 0 !== h) return h;
                                throw Error("Unknown token " + e)
                        }
                    default:
                        if (isNaN(e)) {
                            let e = Error("Unexpected end of CBOR data");
                            throw e.incomplete = !0, e
                        }
                        throw Error("Unknown CBOR token " + e)
                }
            }
            let nO = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;

            function nR(e) {
                return e.slowReads = 0,
                    function() {
                        let e = i[nE++];
                        if ((e &= 31) > 23) switch (e) {
                            case 24:
                                e = i[nE++];
                                break;
                            case 25:
                                e = u.getUint16(nE), nE += 2;
                                break;
                            case 26:
                                e = u.getUint32(nE), nE += 4;
                                break;
                            default:
                                throw Error("Expected array header, but got " + i[nE - 1])
                        }
                        let t = this.compiledReader;
                        for (; t;) {
                            if (t.propertyCount === e) return t(nB);
                            t = t.next
                        }
                        if (this.slowReads++ >= 3) {
                            let n = this.length == e ? this : this.slice(0, e);
                            return t = nA.keyMap ? Function("r", "return {" + n.map(e => nA.decodeKey(e)).map(e => nO.test(e) ? nD(e) + ":r()" : "[" + JSON.stringify(e) + "]:r()").join(",") + "}") : Function("r", "return {" + n.map(e => nO.test(e) ? nD(e) + ":r()" : "[" + JSON.stringify(e) + "]:r()").join(",") + "}"), this.compiledReader && (t.next = this.compiledReader), t.propertyCount = e, this.compiledReader = t, t(nB)
                        }
                        let n = {};
                        if (nA.keyMap)
                            for (let t = 0; t < e; t++) n[nD(nA.decodeKey(this[t]))] = nB();
                        else
                            for (let t = 0; t < e; t++) n[nD(this[t])] = nB();
                        return n
                    }
            }

            function nD(e) {
                return "__proto__" === e ? "__proto_" : e
            }
            let nP = n_;

            function n_(e) {
                let t;
                if (e < 16 && (t = nN(e))) return t;
                if (e > 64 && r) return r.decode(i.subarray(nE, nE += e));
                let n = nE + e,
                    a = [];
                for (t = ""; nE < n;) {
                    let e = i[nE++];
                    if ((128 & e) == 0) a.push(e);
                    else if ((224 & e) == 192) {
                        let t = 63 & i[nE++];
                        a.push((31 & e) << 6 | t)
                    } else if ((240 & e) == 224) {
                        let t = 63 & i[nE++],
                            n = 63 & i[nE++];
                        a.push((31 & e) << 12 | t << 6 | n)
                    } else if ((248 & e) == 240) {
                        let t = (7 & e) << 18 | (63 & i[nE++]) << 12 | (63 & i[nE++]) << 6 | 63 & i[nE++];
                        t > 65535 && (t -= 65536, a.push(t >>> 10 & 1023 | 55296), t = 56320 | 1023 & t), a.push(t)
                    } else a.push(e);
                    a.length >= 4096 && (t += n$.apply(String, a), a.length = 0)
                }
                return a.length > 0 && (t += n$.apply(String, a)), t
            }
            let n$ = String.fromCharCode;

            function nN(e) {
                if (e < 4) {
                    if (e < 2) {
                        if (0 === e) return ""; {
                            let e = i[nE++];
                            if ((128 & e) > 1) {
                                nE -= 1;
                                return
                            }
                            return n$(e)
                        }
                    } {
                        let t = i[nE++],
                            n = i[nE++];
                        if ((128 & t) > 0 || (128 & n) > 0) {
                            nE -= 2;
                            return
                        }
                        if (e < 3) return n$(t, n);
                        let a = i[nE++];
                        if ((128 & a) > 0) {
                            nE -= 3;
                            return
                        }
                        return n$(t, n, a)
                    }
                } {
                    let t = i[nE++],
                        n = i[nE++],
                        a = i[nE++],
                        r = i[nE++];
                    if ((128 & t) > 0 || (128 & n) > 0 || (128 & a) > 0 || (128 & r) > 0) {
                        nE -= 4;
                        return
                    }
                    if (e < 6) {
                        if (4 === e) return n$(t, n, a, r); {
                            let e = i[nE++];
                            if ((128 & e) > 0) {
                                nE -= 5;
                                return
                            }
                            return n$(t, n, a, r, e)
                        }
                    }
                    if (e < 8) {
                        let f = i[nE++],
                            s = i[nE++];
                        if ((128 & f) > 0 || (128 & s) > 0) {
                            nE -= 6;
                            return
                        }
                        if (e < 7) return n$(t, n, a, r, f, s);
                        let o = i[nE++];
                        if ((128 & o) > 0) {
                            nE -= 7;
                            return
                        }
                        return n$(t, n, a, r, f, s, o)
                    } {
                        let f = i[nE++],
                            s = i[nE++],
                            o = i[nE++],
                            c = i[nE++];
                        if ((128 & f) > 0 || (128 & s) > 0 || (128 & o) > 0 || (128 & c) > 0) {
                            nE -= 8;
                            return
                        }
                        if (e < 10) {
                            if (8 === e) return n$(t, n, a, r, f, s, o, c); {
                                let e = i[nE++];
                                if ((128 & e) > 0) {
                                    nE -= 9;
                                    return
                                }
                                return n$(t, n, a, r, f, s, o, c, e)
                            }
                        }
                        if (e < 12) {
                            let d = i[nE++],
                                l = i[nE++];
                            if ((128 & d) > 0 || (128 & l) > 0) {
                                nE -= 10;
                                return
                            }
                            if (e < 11) return n$(t, n, a, r, f, s, o, c, d, l);
                            let u = i[nE++];
                            if ((128 & u) > 0) {
                                nE -= 11;
                                return
                            }
                            return n$(t, n, a, r, f, s, o, c, d, l, u)
                        } {
                            let d = i[nE++],
                                l = i[nE++],
                                u = i[nE++],
                                m = i[nE++];
                            if ((128 & d) > 0 || (128 & l) > 0 || (128 & u) > 0 || (128 & m) > 0) {
                                nE -= 12;
                                return
                            }
                            if (e < 14) {
                                if (12 === e) return n$(t, n, a, r, f, s, o, c, d, l, u, m); {
                                    let e = i[nE++];
                                    if ((128 & e) > 0) {
                                        nE -= 13;
                                        return
                                    }
                                    return n$(t, n, a, r, f, s, o, c, d, l, u, m, e)
                                }
                            } {
                                let p = i[nE++],
                                    b = i[nE++];
                                if ((128 & p) > 0 || (128 & b) > 0) {
                                    nE -= 14;
                                    return
                                }
                                if (e < 15) return n$(t, n, a, r, f, s, o, c, d, l, u, m, p, b);
                                let g = i[nE++];
                                if ((128 & g) > 0) {
                                    nE -= 15;
                                    return
                                }
                                return n$(t, n, a, r, f, s, o, c, d, l, u, m, p, b, g)
                            }
                        }
                    }
                }
            }
            let nL = new Float32Array(1),
                nI = new Uint8Array(nL.buffer, 0, 4);
            class nM {
                constructor(e, t) {
                    this.value = e, this.tag = t
                }
            }
            nz[0] = e => new Date(e), nz[1] = e => new Date(Math.round(1e3 * e)), nz[2] = e => {
                let t = BigInt(0);
                for (let n = 0, a = e.byteLength; n < a; n++) t = BigInt(e[n]) + t << BigInt(8);
                return t
            }, nz[3] = e => BigInt(-1) - nz[2](e), nz[4] = e => Number(e[1] + "e" + e[0]), nz[5] = e => e[1] * Math.exp(e[0] * Math.log(2));
            let nW = e => {
                let t = e[0] - 57344,
                    n = e[1],
                    a = s[t];
                a && a.isShared && ((s.restoreStructures || (s.restoreStructures = []))[t] = a), s[t] = n, n.read = nR(n);
                let r = {};
                if (nA.keyMap)
                    for (let t = 2, a = e.length; t < a; t++) r[nD(nA.decodeKey(n[t - 2]))] = e[t];
                else
                    for (let t = 2, a = e.length; t < a; t++) r[nD(n[t - 2])] = e[t];
                return r
            };
            nz[105] = nW, nz[14] = e => c ? c[0].slice(c.position0, c.position0 += e) : new nM(e, 14), nz[15] = e => c ? c[1].slice(c.position1, c.position1 += e) : new nM(e, 15);
            let nj = {
                Error,
                RegExp
            };
            nz[27] = e => (nj[e[0]] || Error)(e[1], e[2]);
            let nU = e => {
                if (132 != i[nE++]) throw Error("Packed values structure must be followed by a 4 element array");
                let t = e();
                return (l = l ? t.concat(l.slice(t.length)) : t).prefixes = e(), l.suffixes = e(), e()
            };

            function nH(e, t) {
                return "string" == typeof e ? e + t : e instanceof Array ? e.concat(t) : Object.assign({}, e, t)
            }

            function nV() {
                if (!l) {
                    if (nA.getShared) nq();
                    else throw Error("No packed values available")
                }
                return l
            }
            nU.handlesRead = !0, nz[51] = nU, nz[6] = e => {
                if (!l) {
                    if (!nA.getShared) return new nM(e, 6);
                    nq()
                }
                if ("number" == typeof e) return l[16 + (e >= 0 ? 2 * e : -2 * e - 1)];
                throw Error("No support for non-integer packed references yet")
            }, nz[25] = e => stringRefs[e], nz[256] = e => {
                stringRefs = [];
                try {
                    return e()
                } finally {
                    stringRefs = null
                }
            }, nz[256].handlesRead = !0, nz[28] = e => {
                let t;
                d || ((d = new Map).id = 0);
                let n = d.id++,
                    a = {
                        target: t = i[nE] >> 5 == 4 ? [] : {}
                    };
                d.set(n, a);
                let r = e();
                return a.used ? Object.assign(t, r) : (a.target = r, r)
            }, nz[28].handlesRead = !0, nz[29] = e => {
                let t = d.get(e);
                return t.used = !0, t.target
            }, nz[258] = e => new Set(e), (nz[259] = e => (nA.mapsAsObjects && (nA.mapsAsObjects = !1, m = !0), e())).handlesRead = !0, nx.push((e, t) => e >= 225 && e <= 255 ? nH(nV().prefixes[e - 224], t) : e >= 28704 && e <= 32767 ? nH(nV().prefixes[e - 28672], t) : e >= 1879052288 && e <= 2147483647 ? nH(nV().prefixes[e - 1879048192], t) : e >= 216 && e <= 223 ? nH(t, nV().suffixes[e - 216]) : e >= 27647 && e <= 28671 ? nH(t, nV().suffixes[e - 27639]) : e >= 1811940352 && e <= 1879048191 ? nH(t, nV().suffixes[e - 1811939328]) : 1399353956 == e ? {
                packedValues: l,
                structures: s.slice(0),
                version: t
            } : 55799 == e ? t : void 0);
            let nG = 1 == new Uint8Array(new Uint16Array([1]).buffer)[0],
                nK = [Uint8Array],
                nZ = [64];
            for (let e = 0; e < nK.length; e++) ! function(e, t) {
                let n = "get" + e.name.slice(0, -5);
                "function" != typeof e && (e = null);
                let a = e.BYTES_PER_ELEMENT;
                for (let r = 0; r < 2; r++) {
                    if (!r && 1 == a) continue;
                    let i = 2 == a ? 1 : 4 == a ? 2 : 3;
                    nz[r ? t : t - 4] = 1 == a || r == nG ? n => {
                        if (!e) throw Error("Could not find typed array for code " + t);
                        return new e(Uint8Array.prototype.slice.call(n, 0).buffer)
                    } : a => {
                        if (!e) throw Error("Could not find typed array for code " + t);
                        let f = new DataView(a.buffer, a.byteOffset, a.byteLength),
                            s = a.length >> i,
                            o = new e(s),
                            c = f[n];
                        for (let e = 0; e < s; e++) o[e] = c.call(f, e << i, r);
                        return o
                    }
                }
            }(nK[e], nZ[e]);

            function nY() {
                let e = 31 & i[nE++];
                if (e > 23) switch (e) {
                    case 24:
                        e = i[nE++];
                        break;
                    case 25:
                        e = u.getUint16(nE), nE += 2;
                        break;
                    case 26:
                        e = u.getUint32(nE), nE += 4
                }
                return e
            }

            function nq() {
                if (nA.getShared) {
                    let e = nJ(() => (i = null, nA.getShared())) || {},
                        t = e.structures || [];
                    nA.sharedVersion = e.version, l = nA.sharedValues = e.packedValues, !0 === s ? nA.structures = s = t : s.splice.apply(s, [0, t.length].concat(t))
                }
            }

            function nJ(e) {
                let t = f,
                    n = nE,
                    a = nC,
                    r = nv,
                    l = o,
                    m = d,
                    p = c,
                    b = new Uint8Array(i.slice(0, f)),
                    g = s,
                    h = nA,
                    y = nT,
                    w = e();
                return f = t, nE = n, nC = a, nv = r, o = l, d = m, c = p, i = b, nT = y, s = g, nA = h, u = new DataView(i.buffer, i.byteOffset, i.byteLength), w
            }

            function nX() {
                i = null, d = null, s = null
            }
            let nQ = Array(147);
            for (let e = 0; e < 256; e++) nQ[e] = Number("1e" + Math.floor(45.15 - .30103 * e));
            let n0 = new nS({
                useRecords: !1
            }).decode;

            function n1(e) {
                let t = function(e) {
                        var t;
                        if ((e = e.toString(16)).startsWith("0x") || (e = `0x${e}`), !(("string" == typeof(t = e) || "number" == typeof t) && /^(-)?0x[0-9a-f]*$/i.test(t.toString()))) throw Error(`Given value "${e}" is not a valid hex string.`);
                        e = e.replace(/^0x/i, "");
                        let n = [];
                        for (let t = 0; t < e.length; t += 2) n.push(parseInt(e.slice(t, t + 2), 16));
                        return n
                    }(e),
                    n = 256 * t[t.length - 2] + t[t.length - 1],
                    a = n0(Uint8Array.from(t.slice(t.length - 2 - n, -2)));
                if ("ipfs" in a && a.ipfs) try {
                    return `ipfs://${H().encode(a.ipfs)}`
                } catch (e) {
                    console.warn("feature-detection ipfs cbor failed", e)
                }
            }
            async function n6(e, t) {
                let {
                    bytecode: n
                } = await n2(e, t);
                return n1(n)
            }
            async function n5(e, t) {
                let {
                    bytecode: n
                } = await n2(e, t);
                return {
                    uri: n1(n),
                    bytecode: n
                }
            }
            async function n2(e, t) {
                let [n, a] = await Promise.all([n8(e, t), n9(e, t)]), r = function(e) {
                    if (e.startsWith("0x363d3d373d3d3d363d73")) {
                        let t = e.slice(22, 62);
                        return `0x${t}`
                    }
                    if (e.startsWith("0x36603057343d5230")) {
                        let t = e.slice(122, 162);
                        return `0x${t}`
                    }
                    if (e.startsWith("0x3d3d3d3d363d3d37363d73")) {
                        let t = e.slice(24, 64);
                        return `0x${t}`
                    }
                    if (e.startsWith("0x366000600037611000600036600073")) {
                        let t = e.slice(32, 72);
                        return `0x${t}`
                    }
                }(n);
                if (r) return {
                    address: r,
                    bytecode: await n8(r, t)
                };
                for (let n of (a && a !== z.d && (e = a), await Promise.all([n3(e, t), n4(e, t)])))
                    if (n && C.isAddress(n) && n !== z.d) return {
                        address: n,
                        bytecode: await n8(n, t)
                    };
                return {
                    address: e,
                    bytecode: n
                }
            }
            async function n8(e, t) {
                try {
                    let n = await t.getCode(e);
                    if ("0x" === n) {
                        let n = await t.getNetwork();
                        throw Error(`Contract at ${e} does not exist on chain '${n.name}' (chainId: ${n.chainId})`)
                    }
                    return n
                } catch (t) {
                    throw Error(`Failed to get bytecode for address ${e}: ${t}`)
                }
            }
            async function n3(e, t) {
                try {
                    let n = await t.getStorageAt(e, v.O$.from("0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc"));
                    return `0x${n.slice(-40)}`
                } catch (e) {
                    return
                }
            }
            async function n9(e, t) {
                try {
                    let n = await t.getStorageAt(e, v.O$.from("0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50"));
                    return `0x${n.slice(-40)}`
                } catch (e) {
                    return
                }
            }
            async function n4(e, t) {
                try {
                    let n = new x.CH(e, n7, t);
                    return await n.implementation()
                } catch (e) {
                    return
                }
            }
            let n7 = [{
                type: "function",
                name: "implementation",
                inputs: [],
                outputs: [{
                    type: "address",
                    name: "",
                    internalType: "address"
                }],
                stateMutability: "view"
            }];

            function ae() {
                return e6("multiChainRegistryAddress", "0xcdAD8FA86e18538aC207872E8ff3536501431B73")
            }

            function at(e, t) {
                let n = e.map(e => tX.parse(e)).flat().filter(e => "constructor" !== e.type);
                t && n.push(...tX.parse(t));
                let a = function(e, t) {
                    if (0 === e.length || 1 === e.length || !t) return e;
                    for (let n = 0; n < e.length; n++)
                        for (let a = n + 1; a < e.length; a++) t(e[n], e[a]) && e.splice(a, 1);
                    return e
                }(n, (e, t) => e.name === t.name && e.type === t.type && e.inputs.length === t.inputs.length);
                return tX.parse(a)
            }
            let an = {
                    name: "ERC20ClaimConditionsV1",
                    namespace: "token.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc20dclaimable",
                        contracts: "erc20claimconditions"
                    },
                    abis: [q, Y],
                    features: {}
                },
                aa = {
                    name: "ERC20ClaimConditionsV2",
                    namespace: "token.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc20dclaimable",
                        contracts: "erc20claimconditions"
                    },
                    abis: [q, Z],
                    features: {}
                },
                ar = {
                    name: "ERC20ClaimPhasesV2",
                    namespace: "token.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc20dclaimable",
                        contracts: "erc20claimphases"
                    },
                    abis: [q, G],
                    features: {}
                },
                ai = {
                    name: "ERC20ClaimPhasesV1",
                    namespace: "token.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc20dclaimable",
                        contracts: "erc20claimphases"
                    },
                    abis: [K],
                    features: {}
                },
                af = {
                    name: "ERC20Burnable",
                    namespace: "token.burn",
                    docLinks: {
                        sdk: "sdk.erc20burnable",
                        contracts: "erc20burnable"
                    },
                    abis: [q, V],
                    features: {}
                },
                as = {
                    name: "ERC20SignatureMintable",
                    namespace: "token.signature",
                    docLinks: {
                        sdk: "sdk.erc20signaturemintable",
                        contracts: "erc20signaturemint"
                    },
                    abis: [q, ee],
                    features: {}
                },
                ao = {
                    name: "ERC20BatchMintable",
                    namespace: "token.mint.batch",
                    docLinks: {
                        sdk: "sdk.erc20batchmintable",
                        contracts: "erc20batchmintable"
                    },
                    abis: [q, X, Q],
                    features: {}
                },
                ac = {
                    name: "ERC20Mintable",
                    namespace: "token.mint",
                    docLinks: {
                        sdk: "sdk.erc20mintable",
                        contracts: "erc20mintable"
                    },
                    abis: [q, X],
                    features: {
                        [ao.name]: ao
                    }
                },
                ad = {
                    name: "ERC20Permit",
                    namespace: "token.permit",
                    docLinks: {
                        sdk: "sdk.erc20permit",
                        contracts: "erc20permit"
                    },
                    abis: [q, J],
                    features: {}
                },
                al = {
                    name: "ERC20",
                    namespace: "token",
                    docLinks: {
                        sdk: "sdk.erc20",
                        contracts: "erc20"
                    },
                    abis: [q, et],
                    features: {
                        [af.name]: af,
                        [ac.name]: ac,
                        [an.name]: an,
                        [aa.name]: aa,
                        [ai.name]: ai,
                        [ar.name]: ar,
                        [as.name]: as,
                        [ad.name]: ad
                    }
                },
                au = {
                    name: "ERC721Burnable",
                    namespace: "nft.burn",
                    docLinks: {
                        sdk: "sdk.erc721burnable",
                        contracts: "erc721burnable"
                    },
                    abis: [ef, en],
                    features: {}
                },
                am = {
                    name: "ERC721Revealable",
                    namespace: "nft.drop.revealer",
                    docLinks: {
                        sdk: "sdk.delayedreveal",
                        contracts: "erc721revealable"
                    },
                    abis: [ef, ed, er],
                    features: {}
                },
                ap = {
                    name: "ERC721TieredDrop",
                    namespace: "nft.tieredDrop",
                    docLinks: {
                        sdk: "sdk.erc721tiereddrop",
                        contracts: ""
                    },
                    abis: [ef, ep],
                    features: {}
                },
                ab = {
                    name: "ERC721ClaimConditionsV1",
                    namespace: "nft.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc721claimable",
                        contracts: "erc721claimconditions"
                    },
                    abis: [ef, Y],
                    features: {}
                },
                ag = {
                    name: "ERC721ClaimConditionsV2",
                    namespace: "nft.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc721claimable",
                        contracts: "erc721claimconditions"
                    },
                    abis: [ef, Z],
                    features: {}
                },
                ah = {
                    name: "ERC721ClaimPhasesV1",
                    namespace: "nft.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc721claimable",
                        contracts: "erc721claimphases"
                    },
                    abis: [ei],
                    features: {}
                },
                ay = {
                    name: "ERC721ClaimPhasesV2",
                    namespace: "nft.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc721claimable",
                        contracts: "erc721claimphases"
                    },
                    abis: [ef, G],
                    features: {}
                },
                aw = {
                    name: "ERC721ClaimCustom",
                    namespace: "nft.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc721claimable",
                        contracts: "erc721claimcustom"
                    },
                    abis: [ef, ea],
                    features: {}
                },
                aE = {
                    name: "ERC721ClaimZora",
                    namespace: "nft.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc721claimable",
                        contracts: "erc721claimzora"
                    },
                    abis: [ef, eg],
                    features: {}
                },
                ak = {
                    name: "ERC721LazyMintable",
                    namespace: "nft.drop",
                    docLinks: {
                        sdk: "sdk.erc721lazymintable",
                        contracts: "lazymint"
                    },
                    abis: [ef, ed],
                    features: {
                        [am.name]: am
                    }
                },
                aA = {
                    name: "ERC721BatchMintable",
                    namespace: "nft.mint.batch",
                    docLinks: {
                        sdk: "sdk.erc721batchmintable",
                        contracts: "erc721batchmintable"
                    },
                    abis: [ef, el, Q],
                    features: {}
                },
                aC = {
                    name: "ERC721Mintable",
                    namespace: "nft.mint",
                    docLinks: {
                        sdk: "sdk.erc721mintable",
                        contracts: "erc721mintable"
                    },
                    abis: [ef, el],
                    features: {
                        [aA.name]: aA
                    }
                },
                av = {
                    name: "ERC721SignatureMintV2",
                    namespace: "nft.signature",
                    docLinks: {
                        sdk: "sdk.erc721signaturemint",
                        contracts: "erc721signaturemint"
                    },
                    abis: [ef, eu],
                    features: {}
                },
                az = {
                    name: "ERC721SignatureMintV1",
                    namespace: "nft.signature",
                    docLinks: {
                        sdk: "sdk.erc721signaturemint",
                        contracts: "erc721signaturemint"
                    },
                    abis: [em],
                    features: {}
                },
                ax = {
                    name: "ERC721Enumerable",
                    namespace: "nft.query.owned",
                    docLinks: {
                        sdk: "sdk.erc721enumerable",
                        contracts: "erc721enumerable"
                    },
                    abis: [ef, es],
                    features: {}
                },
                aF = {
                    name: "ERC721AQueryable",
                    namespace: "nft.query.owned",
                    docLinks: {
                        sdk: "",
                        contracts: ""
                    },
                    abis: [eo],
                    features: {}
                },
                aT = {
                    name: "ERC721Supply",
                    namespace: "nft.query",
                    docLinks: {
                        sdk: "sdk.erc721supply",
                        contracts: "erc721supply"
                    },
                    abis: [ef, ec],
                    features: {
                        [ax.name]: ax,
                        [aF.name]: aF
                    }
                },
                aS = {
                    name: "ERC721SharedMetadata",
                    namespace: "nft.sharedmetadata",
                    docLinks: {
                        sdk: "sdk.sharedmetadata",
                        contracts: "SharedMetadata"
                    },
                    abis: [ef, eb],
                    features: {}
                },
                aB = {
                    name: "ERC721LoyaltyCard",
                    namespace: "nft.loyaltyCard",
                    docLinks: {
                        sdk: "",
                        contracts: ""
                    },
                    abis: [eh],
                    features: {}
                },
                aO = {
                    name: "ERC721UpdatableMetadata",
                    namespace: "nft.metadata",
                    docLinks: {
                        sdk: "",
                        contracts: ""
                    },
                    abis: [ef, ey],
                    features: {}
                },
                aR = {
                    name: "ERC721",
                    namespace: "nft",
                    docLinks: {
                        sdk: "sdk.erc721",
                        contracts: "erc721"
                    },
                    abis: [ef, ew],
                    features: {
                        [au.name]: au,
                        [aT.name]: aT,
                        [aC.name]: aC,
                        [ak.name]: ak,
                        [az.name]: az,
                        [av.name]: av,
                        [ap.name]: ap,
                        [aw.name]: aw,
                        [aE.name]: aE,
                        [ab.name]: ab,
                        [ag.name]: ag,
                        [ah.name]: ah,
                        [ay.name]: ay,
                        [aS.name]: aS,
                        [aB.name]: aB,
                        [aO.name]: aO
                    }
                },
                aD = {
                    name: "ERC1155Burnable",
                    namespace: "edition.burn",
                    docLinks: {
                        sdk: "sdk.erc1155burnable",
                        contracts: "erc1155burnable"
                    },
                    abis: [ex, eE],
                    features: {}
                },
                aP = {
                    name: "ERC1155ClaimConditionsV1",
                    namespace: "edition.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc1155claimable",
                        contracts: "erc1155dropsinglephase"
                    },
                    abis: [ex, ez],
                    features: {}
                },
                a_ = {
                    name: "ERC1155ClaimConditionsV2",
                    namespace: "edition.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc1155claimable",
                        contracts: "erc1155claimconditions"
                    },
                    abis: [ex, ev],
                    features: {}
                },
                a$ = {
                    name: "ERC1155ClaimPhasesV2",
                    namespace: "edition.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc1155claimable",
                        contracts: "erc1155claimphases"
                    },
                    abis: [ex, eA],
                    features: {}
                },
                aN = {
                    name: "ERC1155ClaimPhasesV1",
                    namespace: "edition.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc1155claimable",
                        contracts: "erc1155claimphases"
                    },
                    abis: [eC],
                    features: {}
                },
                aL = {
                    name: "ERC1155ClaimCustom",
                    namespace: "edition.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc1155claimable",
                        contracts: "erc1155claimcustom"
                    },
                    abis: [ex, ek],
                    features: {}
                },
                aI = {
                    name: "ERC1155Revealable",
                    namespace: "edition.drop.revealer",
                    docLinks: {
                        sdk: "sdk.drop.delayedreveal",
                        contracts: "erc1155revealable"
                    },
                    abis: [ex, ed, er],
                    features: {}
                },
                aM = {
                    name: "ERC1155LazyMintableV2",
                    namespace: "edition.drop",
                    docLinks: {
                        sdk: "sdk.erc1155droppable",
                        contracts: "lazymint"
                    },
                    abis: [ex, ed],
                    features: {
                        [aI.name]: aI
                    }
                },
                aW = {
                    name: "ERC1155LazyMintableV1",
                    namespace: "edition.drop",
                    docLinks: {
                        sdk: "sdk.erc1155droppable",
                        contracts: "lazymint"
                    },
                    abis: [eC],
                    features: {
                        [aN.name]: aN
                    }
                },
                aj = {
                    name: "ERC1155SignatureMintable",
                    namespace: "edition.signature",
                    docLinks: {
                        sdk: "sdk.erc1155signaturemintable",
                        contracts: "erc1155signaturemint"
                    },
                    abis: [ex, eO],
                    features: {}
                },
                aU = {
                    name: "ERC1155BatchMintable",
                    namespace: "edition.mint.batch",
                    docLinks: {
                        sdk: "sdk.erc1155batchmintable",
                        contracts: "erc1155batchmintable"
                    },
                    abis: [ex, eB, Q],
                    features: {}
                },
                aH = {
                    name: "ERC1155Mintable",
                    namespace: "edition.mint",
                    docLinks: {
                        sdk: "sdk.erc1155mintable",
                        contracts: "erc1155mintable"
                    },
                    abis: [ex, eB],
                    features: {
                        [aU.name]: aU
                    }
                },
                aV = {
                    name: "ERC1155Enumerable",
                    namespace: "edition.query",
                    docLinks: {
                        sdk: "sdk.erc1155",
                        contracts: "erc1155enumerable"
                    },
                    abis: [ex, eS],
                    features: {}
                },
                aG = {
                    name: "ERC1155UpdatableMetadata",
                    namespace: "edition.metadata",
                    docLinks: {
                        sdk: "",
                        contracts: ""
                    },
                    abis: [ex, ey],
                    features: {}
                },
                aK = {
                    name: "ERC1155Supply",
                    namespace: "edition.supply",
                    docLinks: {
                        sdk: "",
                        contracts: ""
                    },
                    abis: [ex, eT],
                    features: {}
                },
                aZ = {
                    name: "ERC1155",
                    namespace: "edition",
                    docLinks: {
                        sdk: "sdk.erc1155enumerable",
                        contracts: "erc1155"
                    },
                    abis: [ex, eF, [{
                        inputs: [],
                        name: "name",
                        outputs: [{
                            internalType: "string",
                            name: "",
                            type: "string"
                        }],
                        stateMutability: "view",
                        type: "function"
                    }, {
                        inputs: [],
                        name: "symbol",
                        outputs: [{
                            internalType: "string",
                            name: "",
                            type: "string"
                        }],
                        stateMutability: "view",
                        type: "function"
                    }]],
                    features: {
                        [aK.name]: aK,
                        [aD.name]: aD,
                        [aV.name]: aV,
                        [aH.name]: aH,
                        [aW.name]: aW,
                        [aM.name]: aM,
                        [aI.name]: aI,
                        [aj.name]: aj,
                        [aL.name]: aL,
                        [aP.name]: aP,
                        [a_.name]: a_,
                        [a$.name]: a$,
                        [aG.name]: aG
                    }
                },
                aY = [{
                    inputs: [],
                    name: "getAllPlugins",
                    outputs: [{
                        components: [{
                            internalType: "bytes4",
                            name: "functionSelector",
                            type: "bytes4"
                        }, {
                            internalType: "string",
                            name: "functionSignature",
                            type: "string"
                        }, {
                            internalType: "address",
                            name: "pluginAddress",
                            type: "address"
                        }],
                        internalType: "struct IPluginMap.Plugin[]",
                        name: "registered",
                        type: "tuple[]"
                    }],
                    stateMutability: "view",
                    type: "function"
                }],
                aq = [{
                    inputs: [],
                    name: "getAllExtensions",
                    outputs: [{
                        components: [{
                            components: [{
                                internalType: "string",
                                name: "name",
                                type: "string"
                            }, {
                                internalType: "string",
                                name: "metadataURI",
                                type: "string"
                            }, {
                                internalType: "address",
                                name: "implementation",
                                type: "address"
                            }],
                            internalType: "struct IExtension.ExtensionMetadata",
                            name: "metadata",
                            type: "tuple"
                        }, {
                            components: [{
                                internalType: "bytes4",
                                name: "functionSelector",
                                type: "bytes4"
                            }, {
                                internalType: "string",
                                name: "functionSignature",
                                type: "string"
                            }],
                            internalType: "struct IExtension.ExtensionFunction[]",
                            name: "functions",
                            type: "tuple[]"
                        }],
                        internalType: "struct IExtension.Extension[]",
                        name: "allExtensions",
                        type: "tuple[]"
                    }],
                    stateMutability: "view",
                    type: "function"
                }],
                aJ = {
                    name: "Royalty",
                    namespace: "royalty",
                    docLinks: {
                        sdk: "sdk.contractroyalty",
                        contracts: "royalty"
                    },
                    abis: [eU],
                    features: {}
                },
                aX = {
                    name: "PrimarySale",
                    namespace: "sales",
                    docLinks: {
                        sdk: "sdk.contractprimarysale",
                        contracts: "primarysale"
                    },
                    abis: [ej],
                    features: {}
                },
                aQ = {
                    name: "PlatformFee",
                    namespace: "platformFees",
                    docLinks: {
                        sdk: "sdk.platformfee",
                        contracts: "platformfee"
                    },
                    abis: [eW],
                    features: {}
                },
                a0 = {
                    name: "PermissionsEnumerable",
                    namespace: "roles",
                    docLinks: {
                        sdk: "sdk.contractroles",
                        contracts: "permissionsenumerable"
                    },
                    abis: [eM],
                    features: {}
                },
                a1 = {
                    name: "Permissions",
                    namespace: "roles",
                    docLinks: {
                        sdk: "sdk.contractroles",
                        contracts: "permissions"
                    },
                    abis: [eI],
                    features: {
                        [a0.name]: a0
                    }
                },
                a6 = {
                    name: "ContractMetadata",
                    namespace: "metadata",
                    docLinks: {
                        sdk: "sdk.contractmetadata",
                        contracts: "contractmetadata"
                    },
                    abis: [eP],
                    features: {}
                },
                a5 = {
                    name: "AppURI",
                    namespace: "appURI",
                    docLinks: {
                        sdk: "sdk.appURI",
                        contracts: ""
                    },
                    abis: [eD],
                    features: {}
                },
                a2 = {
                    name: "Ownable",
                    namespace: "owner",
                    docLinks: {
                        sdk: "sdk.owner",
                        contracts: "ownable"
                    },
                    abis: [eH],
                    features: {}
                },
                a8 = {
                    name: "Gasless",
                    namespace: "gasless",
                    docLinks: {
                        sdk: "sdk.gaslesstransaction",
                        contracts: "IERC2771Context"
                    },
                    abis: [eR],
                    features: {}
                },
                a3 = {
                    name: "PackVRF",
                    namespace: "pack.vrf",
                    docLinks: {
                        sdk: "sdk.packvrf",
                        contracts: "IPackVRF"
                    },
                    abis: [eL],
                    features: {}
                },
                a9 = {
                    name: "PluginRouter",
                    namespace: "plugin.router",
                    docLinks: {
                        sdk: "sdk.pluginrouter",
                        contracts: "PluginRouter"
                    },
                    abis: [aY],
                    features: {}
                },
                a4 = {
                    name: "DynamicContract",
                    namespace: "dynamic.contract",
                    docLinks: {
                        sdk: "",
                        contracts: "IExtensionsManager"
                    },
                    abis: [aq],
                    features: {}
                },
                a7 = {
                    name: "DirectListings",
                    namespace: "direct.listings",
                    docLinks: {
                        sdk: "",
                        contracts: "IDirectListings"
                    },
                    abis: [e_],
                    features: {}
                },
                re = {
                    name: "EnglishAuctions",
                    namespace: "english.auctions",
                    docLinks: {
                        sdk: "",
                        contracts: "IEnglishAuctions"
                    },
                    abis: [e$],
                    features: {}
                },
                rt = {
                    name: "Offers",
                    namespace: "offers",
                    docLinks: {
                        sdk: "",
                        contracts: "IOffers"
                    },
                    abis: [eN],
                    features: {}
                },
                rn = {
                    name: "AccountFactory",
                    namespace: "accountFactory",
                    docLinks: {
                        sdk: "sdk.accountFactory",
                        contracts: "IAccountFactory"
                    },
                    abis: [eZ],
                    features: {}
                },
                ra = {
                    name: "AccountPermissionsV1",
                    namespace: "accountPermissions",
                    docLinks: {
                        sdk: "sdk.account",
                        contracts: "IAccountPermissions"
                    },
                    abis: [eq],
                    features: {}
                },
                rr = {
                    name: "AccountPermissions",
                    namespace: "accountPermissions",
                    docLinks: {
                        sdk: "sdk.account",
                        contracts: "IAccountPermissions"
                    },
                    abis: [eY],
                    features: {}
                },
                ri = {
                    name: "Account",
                    namespace: "account",
                    docLinks: {
                        sdk: "sdk.account",
                        contracts: "IAccount"
                    },
                    abis: [eJ],
                    features: {
                        [rr.name]: rr,
                        [ra.name]: ra
                    }
                },
                rf = {
                    name: "AirdropERC20",
                    namespace: "airdrop20",
                    docLinks: {
                        sdk: "",
                        contracts: "IAirdropERC20"
                    },
                    abis: [eV],
                    features: {}
                },
                rs = {
                    name: "AirdropERC721",
                    namespace: "airdrop721",
                    docLinks: {
                        sdk: "",
                        contracts: "IAirdropERC721"
                    },
                    abis: [eG],
                    features: {}
                },
                ro = {
                    name: "AirdropERC1155",
                    namespace: "airdrop1155",
                    docLinks: {
                        sdk: "",
                        contracts: "IAirdropERC1155"
                    },
                    abis: [eK],
                    features: {}
                },
                rc = {
                    name: "Fallback",
                    namespace: "fallback",
                    docLinks: {
                        sdk: "",
                        contracts: ""
                    },
                    abis: [
                        [{
                            stateMutability: "payable",
                            type: "fallback"
                        }]
                    ],
                    features: {}
                },
                rd = {
                    [al.name]: al,
                    [aR.name]: aR,
                    [aZ.name]: aZ,
                    [aJ.name]: aJ,
                    [aQ.name]: aQ,
                    [aX.name]: aX,
                    [a1.name]: a1,
                    [a6.name]: a6,
                    [a5.name]: a5,
                    [a2.name]: a2,
                    [a8.name]: a8,
                    [a3.name]: a3,
                    [a9.name]: a9,
                    [a4.name]: a4,
                    [a7.name]: a7,
                    [re.name]: re,
                    [rt.name]: rt,
                    [rf.name]: rf,
                    [rs.name]: rs,
                    [ro.name]: ro,
                    [rn.name]: rn,
                    [ri.name]: ri,
                    [aB.name]: aB,
                    [aO.name]: aO,
                    [rc.name]: rc
                };

            function rl(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                    n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                    a = e.type,
                    r = !1;
                return a.endsWith("[]") && (r = !0, a = a.slice(0, -2)), a.startsWith("bytes") && (a = "BytesLike"), (a.startsWith("uint") || a.startsWith("int")) && (a = t ? "BigNumber" : "BigNumberish"), a.startsWith("bool") && (a = "boolean"), "address" === a && (a = "string"), "tuple" === a && e.components && (a = `{ ${e.components.map(e=>rl(e,!1,!0)).join(", ")} }`), r && (a += "[]"), n && (a = `${e.name}: ${a}`), a
            }

            function ru(e, t, n) {
                return t ? .output ? .userdoc ? .[n] ? .[Object.keys(t ? .output ? .userdoc[n] || {}).find(t => t.includes(e || "unknown")) || ""] ? .notice || t ? .output ? .devdoc ? .[n] ? .[Object.keys(t ? .output ? .devdoc[n] || {}).find(t => t.includes(e || "unknown")) || ""] ? .details
            }

            function rm(e, t) {
                let n = (e || []).filter(e => "function" === e.type),
                    a = [];
                for (let e of n) {
                    let n = ru(e.name, t, "methods"),
                        r = e.inputs ? .map(e => `${e.name||"key"}: ${rl(e)}`) ? .join(", ") || "",
                        i = r ? `, [${r}]` : "",
                        f = e.outputs ? .map(e => rl(e, !0)) ? .join(", "),
                        s = f ? `: Promise<${f}>` : ": Promise<TransactionResult>",
                        o = `contract.call("${e.name}"${i})${s}`;
                    a.push({
                        inputs: e.inputs || [],
                        outputs: e.outputs || [],
                        name: e.name || "unknown",
                        signature: o,
                        stateMutability: e.stateMutability || "",
                        comment: n
                    })
                }
                return a
            }

            function rp(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : rd,
                    n = {};
                for (let a in t) {
                    let r = t[a],
                        i = function(e, t) {
                            let n = rm(e),
                                a = t.flatMap(e => rm(e));
                            return n.filter(e => void 0 !== a.find(t => t.name === e.name && t.inputs.length === e.inputs.length && t.inputs.every((t, n) => "tuple" === t.type || "tuple[]" === t.type ? t.type === e.inputs[n].type && t.components ? .every((t, a) => t.type === e.inputs[n].components ? .[a] ? .type) : t.type === e.inputs[n].type))).length === a.length
                        }(e, r.abis),
                        f = rp(e, r.features);
                    n[a] = { ...r,
                        features: f,
                        enabled: i
                    }
                }
                return n
            }

            function rb(e, t) {
                if (e)
                    for (let n in e) {
                        let a = e[n];
                        a.enabled && t.push(a), rb(a.features, t)
                    }
            }
            let rg = nu(20);

            function rh(e, t) {
                return rg.get(`${e}-${t}`)
            }
            async function ry(e, t, n) {
                let a, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},
                    i = (await t.getNetwork()).chainId,
                    f = rh(e, i);
                if (f) return f;
                if (!(31337 === i || 1337 === i)) try {
                    let t = await fetch(`https://contract.thirdweb.com/metadata/${i}/${e}`, {
                        headers: { ... function() {
                                let e = ta();
                                return {
                                    "x-sdk-version": e.x_sdk_version,
                                    "x-sdk-os": e.x_sdk_os,
                                    "x-sdk-name": e.x_sdk_name,
                                    "x-sdk-platform": e.x_sdk_platform,
                                    "x-bundle-id": e.app_bundle_id
                                }
                            }()
                        }
                    });
                    if (t.ok) {
                        let e = await t.json();
                        a = ns(e)
                    }
                } catch (e) {}
                if (a || (a = await rw(e, i, t, n, r)), !a) throw Error(`Could not resolve contract. Try importing it by visiting: https://thirdweb.com/${i}/${e}`);
                if (a.isPartialAbi) console.warn(`Contract metadata could only be partially resolved, some contract functions might be unavailable. Try importing the contract by visiting: https://thirdweb.com/${i}/${e}`);
                else {
                    var s;
                    s = a, rg.put(`${e}-${i}`, s)
                }
                return a
            }
            async function rw(e, t, n, a) {
                let r, i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {},
                    [f, s] = await Promise.all([n5(e, n).catch(() => void 0), rE(e, t, i).then(e => {
                        if (e) return {
                            uri: e,
                            bytecode: ""
                        }
                    }).catch(() => void 0)]),
                    o = f ? .bytecode,
                    c = s ? .uri || f ? .uri;
                if (!c && !o) throw Error(`Could not fetch bytecode for contract at ${e} on chain ${t}, double check that the address and chainId are correct.`);
                try {
                    r = await nf(c, a)
                } catch (e) {}
                if (!r && o) {
                    let e;
                    let t = ((e = function(e) {
                        let t = [];
                        return rb(function e(t) {
                            let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : rd,
                                a = {};
                            for (let r in n) {
                                let i = n[r],
                                    f = function(e, t) {
                                        return [...new Set(t.map(e => new eX.Interface(e)).flatMap(e => Object.values(e.functions).map(t => Number(e.getSighash(t)).toString(16))))].every(t => e.includes(t))
                                    }(t, i.abis),
                                    s = e(t, i.features);
                                a[r] = { ...i,
                                    features: s,
                                    enabled: f
                                }
                            }
                            return a
                        }(e), t), t
                    }(o)).find(e => "ERC721" === e.name) && (e = e.filter(e => "ERC20" !== e.name)), at(e.map(e => at(e.abis))));
                    t && t.length > 0 && (r = {
                        name: "Unimported Contract",
                        abi: t,
                        metadata: {},
                        info: {},
                        licenses: [],
                        isPartialAbi: !0
                    })
                }
                return r
            }
            async function rE(e, t, a) {
                let r = (await Promise.resolve().then(n.t.bind(n, 30707, 19))).default;
                if (!p) {
                    let e = a ? .supportedChains ? .find(e => 137 === e.chainId) || I.mgq;
                    p = new x.CH(ae(), r, ti(e, a))
                }
                return await p.getMetadataUri(t, e)
            }
            async function rk(e, t, n) {
                try {
                    let a = await ry(e, t, n);
                    if (a && a.abi) return a.abi
                } catch (e) {}
            }
            async function rA(e, t) {
                let {
                    extendedMetadata: n
                } = await np(e, t);
                return n ? .compositeAbi || []
            }
            let rC = ["eip-155", "eip155", "protected", "invalid chain id for signer", "chain id none", "chain_id mismatch", "recovered sender mismatch", "transaction hash mismatch", "chainid no support", "chainid (0)", "chainid(0)"],
                rv = [
                    ["account", "not found"],
                    ["wrong", "chainid"]
                ],
                rz = {
                    5001: {
                        name: "Mantle Testnet",
                        gasPrice: 1
                    },
                    71402: {
                        name: "Godwoken Mainnet",
                        gasPrice: 4e4 * 1e9
                    },
                    1351057110: {
                        name: "Chaos (SKALE Testnet)",
                        gasPrice: 1e5
                    },
                    361: {
                        name: "Theta Mainnet",
                        gasPrice: 4e3 * 1e9
                    },
                    365: {
                        name: "Theta Testnet",
                        gasPrice: 4e3 * 1e9
                    },
                    7700: {
                        name: "Canto",
                        gasPrice: 1e3 * 1e9
                    },
                    7701: {
                        name: "Canto Testnet",
                        gasPrice: 1e3 * 1e9
                    },
                    338: {
                        name: "Cronos Testnet",
                        gasPrice: 2e3 * 1e9
                    },
                    199: {
                        name: "BitTorrent Chain",
                        gasPrice: 3e5 * 1e9
                    },
                    88882: {
                        name: "Spicy Chain",
                        gasPrice: 2500 * 1e9,
                        gasLimit: 2e5
                    },
                    88888: {
                        name: "Chiliz Chain",
                        gasPrice: 2500 * 1e9,
                        gasLimit: 2e5
                    }
                };

            function rx(e) {
                let t = rC.findIndex(t => e.includes(t)),
                    n = rv.findIndex(t => {
                        let n = !0;
                        return t.forEach(t => {
                            n && = e.includes(t)
                        }), n
                    });
                return -1 !== t || -1 !== n
            }
            let rF = {
                    v: 27,
                    r: "0x2222222222222222222222222222222222222222222222222222222222222222",
                    s: "0x2222222222222222222222222222222222222222222222222222222222222222"
                },
                rT = "0x4e59b44847b379578588920cA78FbF26c0B4956C",
                rS = 5e6,
                rB = "0x60806040526040516107f33803806107f383398101604081905261002291610359565b805160005b818110156100c157828181518110610041576100416104c9565b6020026020010151600001516001600160a01b03163b600014156100af576100ad838281518110610074576100746104c9565b602002602001015160200151848381518110610092576100926104c9565b6020026020010151604001516100c960201b6100091760201c565b505b806100b9816104df565b915050610027565b505050610557565b606061011183836040518060400160405280601e81526020017f416464726573733a206c6f772d6c6576656c2063616c6c206661696c6564000081525061011860201b60201c565b9392505050565b6060610127848460008561012f565b949350505050565b6060824710156101955760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084015b60405180910390fd5b6001600160a01b0385163b6101ec5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015260640161018c565b600080866001600160a01b031685876040516102089190610508565b60006040518083038185875af1925050503d8060008114610245576040519150601f19603f3d011682016040523d82523d6000602084013e61024a565b606091505b50909250905061025b828286610266565b979650505050505050565b60608315610275575081610111565b8251156102855782518084602001fd5b8160405162461bcd60e51b815260040161018c9190610524565b634e487b7160e01b600052604160045260246000fd5b604051606081016001600160401b03811182821017156102d7576102d761029f565b60405290565b604051601f8201601f191681016001600160401b03811182821017156103055761030561029f565b604052919050565b80516001600160a01b038116811461032457600080fd5b919050565b60005b8381101561034457818101518382015260200161032c565b83811115610353576000848401525b50505050565b6000602080838503121561036c57600080fd5b82516001600160401b038082111561038357600080fd5b818501915085601f83011261039757600080fd5b8151818111156103a9576103a961029f565b8060051b6103b88582016102dd565b91825283810185019185810190898411156103d257600080fd5b86860192505b838310156104bc578251858111156103f05760008081fd5b86016060601f19828d0381018213156104095760008081fd5b6104116102b5565b61041c8b850161030d565b8152604061042b81860161030d565b828d01529284015192898411156104425760008081fd5b83850194508e603f86011261045957600093508384fd5b8b85015193508984111561046f5761046f61029f565b61047f8c84601f870116016102dd565b92508383528e818587010111156104965760008081fd5b6104a5848d8501838801610329565b8101919091528452505091860191908601906103d8565b9998505050505050505050565b634e487b7160e01b600052603260045260246000fd5b600060001982141561050157634e487b7160e01b600052601160045260246000fd5b5060010190565b6000825161051a818460208701610329565b9190910192915050565b6020815260008251806020840152610543816040850160208701610329565b601f01601f19169190910160400192915050565b61028d806105666000396000f3fe6080604052600080fd5b606061004b83836040518060400160405280601e81526020017f416464726573733a206c6f772d6c6576656c2063616c6c206661696c65640000815250610052565b9392505050565b60606100618484600085610069565b949350505050565b6060824710156100cf5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084015b60405180910390fd5b6001600160a01b0385163b6101265760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016100c6565b600080866001600160a01b031685876040516101429190610208565b60006040518083038185875af1925050503d806000811461017f576040519150601f19603f3d011682016040523d82523d6000602084013e610184565b606091505b509150915061019482828661019f565b979650505050505050565b606083156101ae57508161004b565b8251156101be5782518084602001fd5b8160405162461bcd60e51b81526004016100c69190610224565b60005b838110156101f35781810151838201526020016101db565b83811115610202576000848401525b50505050565b6000825161021a8184602087016101d8565b9190910192915050565b60208152600082518060208401526102438160408501602087016101d8565b601f01601f1916919091016040019291505056fea26469706673582212200b524eb8ceaafe6c603273ee859fddbc2d6f1b7860c3d853dcf6f129f9d9371364736f6c634300080c0033",
                rO = [{
                    inputs: [{
                        components: [{
                            internalType: "address",
                            name: "predictedAddress",
                            type: "address"
                        }, {
                            internalType: "address",
                            name: "to",
                            type: "address"
                        }, {
                            internalType: "bytes",
                            name: "data",
                            type: "bytes"
                        }],
                        internalType: "struct IDeployer.Transaction[]",
                        name: "transactions",
                        type: "tuple[]"
                    }],
                    stateMutability: "payable",
                    type: "constructor"
                }];
            async function rR(e, t) {
                let n = await t.getCode(e);
                return "0x" !== n && "0x0" !== n
            }
            async function rD(e) {
                try {
                    await e.sendTransaction("0xf8a58085174876e800830186a08080b853604580600e600039806000f350fe7fffffffffffffffafffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf31ba02222222222222222222222222222222222222222222222222222222222222222a02222222222222222222222222222222222222222222222222222222222222222")
                } catch (n) {
                    let e = n.toString().toLowerCase(),
                        t = JSON.stringify(n).toLowerCase();
                    if (rx(e) || rx(t)) return !0
                }
                return !1
            }

            function rP(e, t) {
                let n = T.joinSignature(rF),
                    a = function(e, t) {
                        let n = T.arrayify(S.keccak256(B.serialize(e)));
                        return {
                            signer: B.recoverAddress(n, t),
                            transaction: B.serialize(e, t)
                        }
                    }({
                        gasPrice: t.gasPrice ? t.gasPrice : 100 * 1e9,
                        gasLimit: t.gasLimit ? t.gasLimit : 1e5,
                        nonce: 0,
                        data: "0x604580600e600039806000f350fe7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf3",
                        chainId: e
                    }, n),
                    r = C.getContractAddress({
                        from: a.signer,
                        nonce: 0
                    });
                return { ...a,
                    deployment: r
                }
            }
            async function r_(e) {
                if (await rR(rT, e)) return rT;
                let t = await rD(e),
                    n = (await e.getNetwork()).chainId,
                    a = t ? n : 0;
                return (rz[n] ? rP(a, {
                    gasPrice: rz[n].gasPrice,
                    gasLimit: rz[n].gasLimit
                }) : rP(a, {})).deployment
            }
            let r$ = "0x60606040526040805190810160405280600d81526020017f57726170706564204574686572000000000000000000000000000000000000008152506000908051906020019061004f9291906100c8565b506040805190810160405280600481526020017f57455448000000000000000000000000000000000000000000000000000000008152506001908051906020019061009b9291906100c8565b506012600260006101000a81548160ff021916908360ff16021790555034156100c357600080fd5b61016d565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061010957805160ff1916838001178555610137565b82800160010185558215610137579182015b8281111561013657825182559160200191906001019061011b565b5b5090506101449190610148565b5090565b61016a91905b8082111561016657600081600090555060010161014e565b5090565b90565b610c348061017c6000396000f3006060604052600436106100af576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806306fdde03146100b9578063095ea7b31461014757806318160ddd146101a157806323b872dd146101ca5780632e1a7d4d14610243578063313ce5671461026657806370a082311461029557806395d89b41146102e2578063a9059cbb14610370578063d0e30db0146103ca578063dd62ed3e146103d4575b6100b7610440565b005b34156100c457600080fd5b6100cc6104dd565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561010c5780820151818401526020810190506100f1565b50505050905090810190601f1680156101395780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561015257600080fd5b610187600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190505061057b565b604051808215151515815260200191505060405180910390f35b34156101ac57600080fd5b6101b461066d565b6040518082815260200191505060405180910390f35b34156101d557600080fd5b610229600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190505061068c565b604051808215151515815260200191505060405180910390f35b341561024e57600080fd5b61026460048080359060200190919050506109d9565b005b341561027157600080fd5b610279610b05565b604051808260ff1660ff16815260200191505060405180910390f35b34156102a057600080fd5b6102cc600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610b18565b6040518082815260200191505060405180910390f35b34156102ed57600080fd5b6102f5610b30565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561033557808201518184015260208101905061031a565b50505050905090810190601f1680156103625780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561037b57600080fd5b6103b0600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091908035906020019091905050610bce565b604051808215151515815260200191505060405180910390f35b6103d2610440565b005b34156103df57600080fd5b61042a600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610be3565b6040518082815260200191505060405180910390f35b34600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055503373ffffffffffffffffffffffffffffffffffffffff167fe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c346040518082815260200191505060405180910390a2565b60008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156105735780601f1061054857610100808354040283529160200191610573565b820191906000526020600020905b81548152906001019060200180831161055657829003601f168201915b505050505081565b600081600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040518082815260200191505060405180910390a36001905092915050565b60003073ffffffffffffffffffffffffffffffffffffffff1631905090565b600081600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054101515156106dc57600080fd5b3373ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff16141580156107b457507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205414155b156108cf5781600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015151561084457600080fd5b81600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055505b81600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254039250508190555081600360008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a3600190509392505050565b80600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410151515610a2757600080fd5b80600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055503373ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f193505050501515610ab457600080fd5b3373ffffffffffffffffffffffffffffffffffffffff167f7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65826040518082815260200191505060405180910390a250565b600260009054906101000a900460ff1681565b60036020528060005260406000206000915090505481565b60018054600181600116156101000203166002900480601f016020809104026020016040519081016040528092919081815260200182805460018160011615610100020316600290048015610bc65780601f10610b9b57610100808354040283529160200191610bc6565b820191906000526020600020905b815481529060010190602001808311610ba957829003601f168201915b505050505081565b6000610bdb33848461068c565b905092915050565b60046020528160005260406000206020528060005260406000206000915091505054815600a165627a7a72305820deb4c2ccab3c2fdca32ab3f46728389c2fe2c165d5fafa07661e4e004f6c344a0029";

            function rN(e) {
                let t = e.startsWith("0x") ? e : `0x${e}`,
                    n = O.id(t),
                    a = `tw.${n}`;
                return O.id(a)
            }

            function rL(e, t, n) {
                let a = e.startsWith("0x") ? e : `0x${e}`,
                    r = n ? O.id(n) : rN(a);
                return R.pack(["bytes32", "bytes", "bytes"], [r, a, t])
            }

            function rI(e, t, n, a) {
                let r = e.startsWith("0x") ? e : `0x${e}`,
                    i = a ? O.id(a) : rN(r),
                    f = R.pack(["bytes", "bytes"], [r, t]),
                    s = R.pack(["bytes1", "address", "bytes32", "bytes32"], ["0xff", n, i, R.keccak256(["bytes"], [f])]),
                    o = R.keccak256(["bytes"], [s]);
                return `0x${o.slice(26)}`
            }
            let rM = ((b = {})[b.Mainnet = 1] = "Mainnet", b[b.Goerli = 5] = "Goerli", b[b.Polygon = 137] = "Polygon", b[b.Mumbai = 80001] = "Mumbai", b[b.Localhost = 1337] = "Localhost", b[b.Hardhat = 31337] = "Hardhat", b[b.Fantom = 250] = "Fantom", b[b.FantomTestnet = 4002] = "FantomTestnet", b[b.Avalanche = 43114] = "Avalanche", b[b.AvalancheFujiTestnet = 43113] = "AvalancheFujiTestnet", b[b.Optimism = 10] = "Optimism", b[b.OptimismGoerli = 420] = "OptimismGoerli", b[b.Arbitrum = 42161] = "Arbitrum", b[b.ArbitrumGoerli = 421613] = "ArbitrumGoerli", b[b.BinanceSmartChainMainnet = 56] = "BinanceSmartChainMainnet", b[b.BinanceSmartChainTestnet = 97] = "BinanceSmartChainTestnet", b),
                rW = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
                rj = {
                    [rM.Mainnet]: {
                        name: "Ether",
                        symbol: "ETH",
                        decimals: 18,
                        wrapped: {
                            address: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    [rM.Goerli]: {
                        name: "G\xf6rli Ether",
                        symbol: "GOR",
                        decimals: 18,
                        wrapped: {
                            address: "0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    11155111: {
                        name: "Sepolia Ether",
                        symbol: "SEP",
                        decimals: 18,
                        wrapped: {
                            address: "0x7b79995e5f793A07Bc00c21412e50Ecae098E7f9",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    [rM.Polygon]: {
                        name: "Matic",
                        symbol: "MATIC",
                        decimals: 18,
                        wrapped: {
                            address: "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270",
                            name: "Wrapped Matic",
                            symbol: "WMATIC"
                        }
                    },
                    [rM.Mumbai]: {
                        name: "Matic",
                        symbol: "MATIC",
                        decimals: 18,
                        wrapped: {
                            address: "0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889",
                            name: "Wrapped Matic",
                            symbol: "WMATIC"
                        }
                    },
                    [rM.Avalanche]: {
                        name: "Avalanche",
                        symbol: "AVAX",
                        decimals: 18,
                        wrapped: {
                            address: "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7",
                            name: "Wrapped AVAX",
                            symbol: "WAVAX"
                        }
                    },
                    [rM.AvalancheFujiTestnet]: {
                        name: "Avalanche",
                        symbol: "AVAX",
                        decimals: 18,
                        wrapped: {
                            address: "0xd00ae08403B9bbb9124bB305C09058E32C39A48c",
                            name: "Wrapped AVAX",
                            symbol: "WAVAX"
                        }
                    },
                    [rM.Fantom]: {
                        name: "Fantom",
                        symbol: "FTM",
                        decimals: 18,
                        wrapped: {
                            address: "0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83",
                            name: "Wrapped Fantom",
                            symbol: "WFTM"
                        }
                    },
                    [rM.FantomTestnet]: {
                        name: "Fantom",
                        symbol: "FTM",
                        decimals: 18,
                        wrapped: {
                            address: "0xf1277d1Ed8AD466beddF92ef448A132661956621",
                            name: "Wrapped Fantom",
                            symbol: "WFTM"
                        }
                    },
                    [rM.Arbitrum]: {
                        name: "Ether",
                        symbol: "ETH",
                        decimals: 18,
                        wrapped: {
                            address: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    [rM.ArbitrumGoerli]: {
                        name: "Arbitrum Goerli Ether",
                        symbol: "AGOR",
                        decimals: 18,
                        wrapped: {
                            address: "0xe39Ab88f8A4777030A534146A9Ca3B52bd5D43A3",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    [rM.Optimism]: {
                        name: "Ether",
                        symbol: "ETH",
                        decimals: 18,
                        wrapped: {
                            address: "0x4200000000000000000000000000000000000006",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    [rM.OptimismGoerli]: {
                        name: "Goerli Ether",
                        symbol: "ETH",
                        decimals: 18,
                        wrapped: {
                            address: "0x4200000000000000000000000000000000000006",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    [rM.BinanceSmartChainMainnet]: {
                        name: "Binance Chain Native Token",
                        symbol: "BNB",
                        decimals: 18,
                        wrapped: {
                            address: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
                            name: "Wrapped Binance Chain Token",
                            symbol: "WBNB"
                        }
                    },
                    [rM.BinanceSmartChainTestnet]: {
                        name: "Binance Chain Native Token",
                        symbol: "TBNB",
                        decimals: 18,
                        wrapped: {
                            address: "0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd",
                            name: "Wrapped Binance Chain Testnet Token",
                            symbol: "WBNB"
                        }
                    },
                    [rM.Hardhat]: {
                        name: "Ether",
                        symbol: "ETH",
                        decimals: 18,
                        wrapped: {
                            address: "0x5FbDB2315678afecb367f032d93F642f64180aa3",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    [rM.Localhost]: {
                        name: "Ether",
                        symbol: "ETH",
                        decimals: 18,
                        wrapped: {
                            address: "0x5FbDB2315678afecb367f032d93F642f64180aa3",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    84531: {
                        name: "Base Goerli Testnet",
                        symbol: "ETH",
                        decimals: 18,
                        wrapped: {
                            address: "0x4200000000000000000000000000000000000006",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    280: {
                        name: "zkSync Era Testnet",
                        symbol: "ETH",
                        decimals: 18,
                        wrapped: {
                            address: "0x5AEa5775959fBC2557Cc8789bC1bf90A239D9a91",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    }
                };

            function rU(e) {
                let t = nb.find(t => t.chainId === e);
                return t && t.nativeCurrency ? {
                    name: t.nativeCurrency.name,
                    symbol: t.nativeCurrency.symbol,
                    decimals: 18,
                    wrapped: {
                        address: z.d,
                        name: `Wrapped ${t.nativeCurrency.name}`,
                        symbol: `W${t.nativeCurrency.symbol}`
                    }
                } : rj[e] || {
                    name: "Ether",
                    symbol: "ETH",
                    decimals: 18,
                    wrapped: {
                        address: z.d,
                        name: "Wrapped Ether",
                        symbol: "WETH"
                    }
                }
            }
            let rH = {
                [rM.Mainnet]: "0x514910771AF9Ca656af840dff83E8264EcF986CA",
                [rM.Goerli]: "0x326C977E6efc84E512bB9C30f76E30c160eD06FB",
                [rM.BinanceSmartChainMainnet]: "0x404460C6A5EdE2D891e8297795264fDe62ADBB75",
                [rM.Polygon]: "0xb0897686c545045aFc77CF20eC7A532E3120E0F1",
                [rM.Mumbai]: "0x326C977E6efc84E512bB9C30f76E30c160eD06FB",
                [rM.Avalanche]: "0x5947BB275c521040051D82396192181b413227A3",
                [rM.AvalancheFujiTestnet]: "0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846",
                [rM.Fantom]: "0x6F43FF82CCA38001B6699a8AC47A2d0E66939407",
                [rM.FantomTestnet]: "0xfaFedb041c0DD4fA2Dc0d87a6B0979Ee6FA7af5F"
            };

            function rV(e) {
                for (let t of tX.parse(e || []))
                    if ("constructor" === t.type) return t.inputs || [];
                return []
            }
            let rG = {
                    deploymentPresets: {}
                },
                rK = {
                    [rM.Mainnet]: "0x0385603ab55642cb4dd5de3ae9e306809991804f",
                    [rM.Goerli]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
                    [rM.BinanceSmartChainMainnet]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
                    [rM.Polygon]: "0x28EdFcF0Be7E86b07493466e7631a213bDe8eEF2",
                    [rM.Mumbai]: "0x0a01E11887f727D1b1Cd81251eeEE9BEE4262D07",
                    [rM.Avalanche]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
                    [rM.Optimism]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
                    [rM.Arbitrum]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15"
                },
                rZ = "0x0000000000000000000000000000000000000000";
            async function rY(e, t, n, a, r, i, f) {
                let s = r && r.contractName,
                    o = r && r.version,
                    c = r && r.publisherAddress,
                    d = r && r.metadata;
                if ((0, M.Z)(s || d, "Require contract name or metadata"), s && rG.deploymentPresets[s]) return rG.deploymentPresets[s];
                if ("WETH9" === s) {
                    let n = rI(r$, [], a),
                        r = await rR(n, t),
                        i = "";
                    return r || (i = rL(r$, [])), {
                        name: s,
                        type: e,
                        transaction: {
                            predictedAddress: n,
                            to: a,
                            data: i
                        }
                    }
                }
                if (!d) {
                    (0, M.Z)(s, "Require contract name"), c || (c = nh);
                    let e = await ny(c, s, o, n, i, f);
                    d = (await np(e.metadataUri, n)).compilerMetadata
                }
                let l = await rq(d, t, n, a, r ? .constructorParams, i, f),
                    u = rI(d.bytecode, l, a),
                    m = await rR(u, t),
                    p = "";
                return m || (p = rL(d.bytecode, l)), {
                    name: s,
                    type: e,
                    transaction: {
                        predictedAddress: u,
                        to: a,
                        data: p
                    },
                    encodedArgs: l
                }
            }
            async function rq(e, t, n, a, r, i, f) {
                let s = rV(e.abi),
                    o = s.map(e => "tuple[]" === e.type || "tuple" === e.type ? D._R.from(e) : e.type),
                    c = await Promise.all(s.map(async s => {
                        if (r && r[s.name]) return r[s.name].type && (0, M.Z)(r[s.name].type === s.type, `Provided type ${r[s.name].type} doesn't match the actual type ${s.type} from Abi`), r[s.name].value;
                        if (s.name && s.name.includes("nativeTokenWrapper")) return await rJ(t, n, a, i, f);
                        if (s.name && s.name.includes("trustedForwarder")) {
                            if ("Pack" === e.name) return rZ;
                            let r = await rY("infra", t, n, a, {
                                contractName: "Forwarder"
                            }, i, f);
                            return rG.deploymentPresets.Forwarder || (rG.deploymentPresets.Forwarder = r), r.transaction.predictedAddress
                        }
                        if (s.name && s.name.includes("royaltyEngineAddress")) return rK[(await t.getNetwork()).chainId] || z.d;
                        if (s.name && s.name.includes("marketplaceV3Params")) {
                            let e = rK[(await t.getNetwork()).chainId] || z.d,
                                s = await rJ(t, n, a, i, f);
                            return {
                                extensions: r ? r._extensions.value : [],
                                royaltyEngineAddress: e,
                                nativeTokenWrapper: s
                            }
                        }
                        throw Error("Can't resolve constructor arguments")
                    }));
                return P.$.encode(o, c)
            }
            async function rJ(e, t, n, a, r) {
                let i = rU((await e.getNetwork()).chainId).wrapped.address;
                if (i === z.d) {
                    let f = await rY("infra", e, t, n, {
                        contractName: "WETH9"
                    }, a, r);
                    rG.deploymentPresets.WETH9 || (rG.deploymentPresets.WETH9 = f), i = f.transaction.predictedAddress
                }
                return i
            }
            async function rX(e, t, n, a, r) {
                return n && "" !== n || (n = await r_(e)), (await rY("infra", e, t, n, {
                    contractName: "ForwarderEOAOnly"
                }, a, r)).transaction.predictedAddress
            }
            async function rQ(e, t, n, a, r) {
                return n && "" !== n || (n = await r_(e)), (await rY("infra", e, t, n, {
                    contractName: "Forwarder"
                }, a, r)).transaction.predictedAddress
            }
            class r0 extends Error {
                constructor(e) {
                    super(e ? `Object with id ${e} NOT FOUND` : "NOT_FOUND")
                }
            }
            class r1 extends Error {
                constructor(e, t) {
                    super(`MISSING ROLE: ${e} does not have the '${t}' role`)
                }
            }
            class r6 extends Error {
                constructor(e) {
                    super(`DUPLICATE_LEAFS${e?` : ${e}`:""}`)
                }
            }
            class r5 extends Error {
                constructor(e) {
                    super(`Auction already started with existing bid${e?`, id: ${e}`:""}`)
                }
            }
            class r2 extends Error {
                constructor(e, t) {
                    super(`Could not find listing.${e?` marketplace address: ${e}`:""}${t?` listing id: ${t}`:""}`)
                }
            }
            class r8 extends Error {
                constructor(e, t, n, a) {
                    super(`Incorrect listing type. Are you sure you're using the right method?.${e?` marketplace address: ${e}`:""}${t?` listing id: ${t}`:""}${a?` expected type: ${a}`:""}${n?` actual type: ${n}`:""}`)
                }
            }
            class r3 extends Error {
                constructor(e, t) {
                    super(`Auction has not ended yet${e?`, id: ${e}`:""}${t?`, end time: ${t.toString()}`:""}`)
                }
            }
            class r9 extends Error {
                constructor(e) {
                    super(`This functionality is not available because the contract does not implement the '${e.name}' Extension. Learn how to unlock this functionality at https://portal.thirdweb.com/contracts/build/extensions `)
                }
            }
            class r4 extends Error {#
                e;#
                t;#
                n;
                constructor(e, t) {
                    let n = `


╔═══════════════════╗
║ TRANSACTION ERROR ║
╚═══════════════════╝

`;
                    if (n += `Reason: ${e.reason}


╔═════════════════════════╗
║ TRANSACTION INFORMATION ║
╚═════════════════════════╝
` + ie("from", e.from), e.to && (n += ie("to", e.contractName ? `${e.to} (${e.contractName})` : e.to)), n += ie("chain", `${e.network.name} (${e.network.chainId})`), e.rpcUrl) try {
                        let t = new URL(e.rpcUrl);
                        n += ie("rpc", t.hostname)
                    } catch (e) {}
                    if (e.hash && (n += ie("tx hash", e.hash)), e.value && e.value.gt(0) && (n += ie("value", `${_.formatEther(e.value)} ${rj[e.network.chainId]?.symbol||""}`)), n += ie("data", `${e.data}`), e.method && (n += ie("method", e.method)), e.sources) {
                        let t = e.sources.find(t => t.source.includes(e.reason));
                        if (t) {
                            let a = t.source.split("\n").map((e, t) => `${t+1}  ${e}`),
                                r = a.findIndex(t => t.includes(e.reason));
                            a[r] += "   <-- REVERT";
                            let i = a.slice(r - 8, r + 4);
                            n += `


╔══════════════════════╗
║ SOLIDITY STACK TRACE ║
╚══════════════════════╝

File: ${t.filename.replace("node_modules/","")}

` + i.join("\n")
                        }
                    }
                    super(n += `


╔═════════════════════╗
║ DEBUGGING RESOURCES ║
╚═════════════════════╝

Need helping debugging? Join our Discord: https://discord.gg/thirdweb

`), this.#e = e.reason, this.#t = e, this.#n = t
                }
                get reason() {
                    return this.#e
                }
                get raw() {
                    return this.#n
                }
                get info() {
                    return this.#t
                }
            }

            function r7(e) {
                if (e.reason && !e.reason.includes("cannot estimate gas")) return e.reason;
                if (e.error) return e.error;
                let t = e;
                return "object" == typeof e ? t = JSON.stringify(e) : "string" != typeof e && (t = e.toString()), it(/.*?"message":"([^"\\]*).*?/, t) || it(/.*?"reason":"([^"\\]*).*?/, t) || e.message || ""
            }

            function ie(e, t) {
                if ("" === t) return t;
                let n = Array(10 - e.length).fill(" ").join("");
                return t = t.includes("\n") ? "\n\n  " + t.split("\n").join(`
  `) : `${n}${t}`, `
${e}:${t}`
            }

            function it(e, t) {
                let n = t.match(e) || [],
                    a = "";
                return n ? .length > 0 && (a += n[1]), a
            }

            function ia(e, t) {
                return !!e && (e && e.toString().includes(t) || e && e.message && e.message.toString().includes(t) || e && e.error && e.error.toString().includes(t))
            }
            async function ir(e, t) {
                return await Promise.all(Object.entries(e.metadata.sources).map(async e => {
                    let [n, a] = e, r = a.urls, i = r ? r.find(e => e.includes("ipfs")) : void 0;
                    if (!i) return {
                        filename: n,
                        source: a.content || "Could not find source for this contract"
                    }; {
                        let e = i.split("ipfs/")[1],
                            a = new Promise((e, t) => setTimeout(() => t("timeout"), 3e3));
                        return {
                            filename: n,
                            source: await Promise.race([(await t.download(`ipfs://${e}`)).text(), a])
                        }
                    }
                }))
            }
            let ii = [{
                    name: "from",
                    type: "address"
                }, {
                    name: "to",
                    type: "address"
                }, {
                    name: "value",
                    type: "uint256"
                }, {
                    name: "gas",
                    type: "uint256"
                }, {
                    name: "nonce",
                    type: "uint256"
                }, {
                    name: "data",
                    type: "bytes"
                }],
                is = [{
                    name: "from",
                    type: "address"
                }, {
                    name: "to",
                    type: "address"
                }, {
                    name: "value",
                    type: "uint256"
                }, {
                    name: "gas",
                    type: "uint256"
                }, {
                    name: "nonce",
                    type: "uint256"
                }, {
                    name: "data",
                    type: "bytes"
                }, {
                    name: "chainid",
                    type: "uint256"
                }],
                io = [{
                    inputs: [{
                        internalType: "address",
                        name: "from",
                        type: "address"
                    }, {
                        internalType: "uint256",
                        name: "batchId",
                        type: "uint256"
                    }],
                    name: "getNonce",
                    outputs: [{
                        internalType: "uint256",
                        name: "",
                        type: "uint256"
                    }],
                    stateMutability: "view",
                    type: "function"
                }],
                ic = {},
                id = {};
            async function il(e, t, n) {
                let a = n.join("|"),
                    r = id[a],
                    i = Date.now() - r >= 2e3;
                if (!(a in ic) || i) {
                    let r = await e.functions[t](...n);
                    Array.isArray(r) && r.length > 0 ? ic[a] = v.O$.from(r[0]) : ic[a] = v.O$.from(r), id[a] = Date.now()
                }
                let f = ic[a];
                return ic[a] = v.O$.from(ic[a]).add(1), f
            }
            async function iu(e, t, n, a) {
                let r = e;
                e.originalSigner && (r = e.originalSigner);
                let i = r ? .provider;
                if (!i) throw Error("missing provider");
                let f = $.E.getPayload(t, n, a),
                    s = "",
                    o = (await r.getAddress()).toLowerCase();
                if (i ? .provider ? .isWalletConnect) s = await i.send("eth_signTypedData", [o, JSON.stringify(f)]);
                else try {
                    s = await r._signTypedData(t, n, a)
                } catch (e) {
                    if (e ? .message ? .includes("eth_signTypedData_v4")) s = await i.send("eth_signTypedData", [o, JSON.stringify(f)]);
                    else try {
                        await i.send("eth_signTypedData_v4", [o, JSON.stringify(f)])
                    } catch (e) {
                        throw e
                    }
                }
                return {
                    payload: f,
                    signature: T.joinSignature(T.splitSignature(s))
                }
            }
            let im = [{
                    inputs: [],
                    name: "name",
                    outputs: [{
                        internalType: "string",
                        name: "",
                        type: "string"
                    }],
                    stateMutability: "view",
                    type: "function"
                }],
                ip = [{
                    constant: !0,
                    inputs: [],
                    name: "DOMAIN_SEPARATOR",
                    outputs: [{
                        internalType: "bytes32",
                        name: "",
                        type: "bytes32"
                    }],
                    payable: !1,
                    stateMutability: "view",
                    type: "function"
                }, {
                    inputs: [],
                    name: "getDomainSeperator",
                    outputs: [{
                        internalType: "bytes32",
                        name: "",
                        type: "bytes32"
                    }],
                    stateMutability: "view",
                    type: "function"
                }],
                ib = [{
                    inputs: [{
                        internalType: "address",
                        name: "owner",
                        type: "address"
                    }],
                    name: "nonces",
                    outputs: [{
                        internalType: "uint256",
                        name: "",
                        type: "uint256"
                    }],
                    stateMutability: "view",
                    type: "function"
                }, {
                    inputs: [{
                        internalType: "address",
                        name: "user",
                        type: "address"
                    }],
                    name: "getNonce",
                    outputs: [{
                        internalType: "uint256",
                        name: "nonce",
                        type: "uint256"
                    }],
                    stateMutability: "view",
                    type: "function"
                }];
            async function ig(e, t) {
                let n = new x.CH(t, ib, e);
                try {
                    return await n.nonces(await e.getAddress())
                } catch (t) {
                    return await n.getNonce(await e.getAddress())
                }
            }
            async function ih(e, t) {
                let n = new x.CH(t, ip, e);
                try {
                    return await n.DOMAIN_SEPARATOR()
                } catch (e) {
                    try {
                        return await n.getDomainSeperator()
                    } catch (e) {
                        console.error("Error getting domain separator", e)
                    }
                }
            }
            async function iy(e, t) {
                return new x.CH(t, im, e).name()
            }
            async function iw(e, t) {
                let n = await ih(e, t.verifyingContract),
                    a = {
                        name: t.name,
                        version: t.version,
                        verifyingContract: t.verifyingContract,
                        salt: T.hexZeroPad(v.O$.from(t.chainId).toHexString(), 32)
                    };
                return $.E.hashDomain(a) === n ? a : t
            }
            async function iE(e, t, n, a, r, i, f) {
                let [s, o, c] = await Promise.all([iy(e, t), e.getChainId(), ig(e, t)]), d = await iw(e, {
                    name: s,
                    version: "1",
                    chainId: o,
                    verifyingContract: t
                }), l = {
                    owner: n,
                    spender: a,
                    value: r,
                    nonce: f = f || c.toString(),
                    deadline: i = i || N.Bz
                }, {
                    signature: u
                } = await iu(e, d, {
                    Permit: [{
                        name: "owner",
                        type: "address"
                    }, {
                        name: "spender",
                        type: "address"
                    }, {
                        name: "value",
                        type: "uint256"
                    }, {
                        name: "nonce",
                        type: "uint256"
                    }, {
                        name: "deadline",
                        type: "uint256"
                    }]
                }, l);
                return {
                    message: l,
                    signature: u
                }
            }
            let ik = "0x7c487845f98938Bb955B1D5AD069d9a30e4131fd",
                iA = "0x5DBC7B840baa9daBcBe9D2492E45D7244B54A2A0",
                iC = "0xc82BbE41f2cF04e3a8efA18F7032BDD7f6d98a81",
                iv = {
                    [rM.Mainnet]: {
                        openzeppelinForwarder: iC,
                        openzeppelinForwarderEOA: "0x76ce2CB1Ae48Fa067f4fb8c5f803111AE0B24BEA",
                        biconomyForwarder: "0x84a0856b038eaAd1cC7E297cF34A7e72685A8693",
                        twFactory: iA,
                        twRegistry: ik,
                        twBYOCRegistry: rZ
                    },
                    [rM.Goerli]: {
                        openzeppelinForwarder: "0x5001A14CA6163143316a7C614e30e6041033Ac20",
                        openzeppelinForwarderEOA: "0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2",
                        biconomyForwarder: "0xE041608922d06a4F26C0d4c27d8bCD01daf1f792",
                        twFactory: iA,
                        twRegistry: ik,
                        twBYOCRegistry: "0xB1Bd9d7942A250BA2Dce27DD601F2ED4211A60C4"
                    },
                    [rM.Polygon]: {
                        openzeppelinForwarder: iC,
                        openzeppelinForwarderEOA: "0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F",
                        biconomyForwarder: "0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8",
                        twFactory: iA,
                        twRegistry: ik,
                        twBYOCRegistry: "0x308473Be900F4185A56587dE54bDFF5E8f7a6AE7"
                    },
                    [rM.Mumbai]: {
                        openzeppelinForwarder: iC,
                        openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
                        biconomyForwarder: "0x9399BB24DBB5C4b782C70c2969F58716Ebbd6a3b",
                        twFactory: iA,
                        twRegistry: ik,
                        twBYOCRegistry: "0x3F17972CB27506eb4a6a3D59659e0B57a43fd16C"
                    },
                    [rM.Avalanche]: {
                        openzeppelinForwarder: iC,
                        openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
                        biconomyForwarder: "0x64CD353384109423a966dCd3Aa30D884C9b2E057",
                        twFactory: iA,
                        twRegistry: ik,
                        twBYOCRegistry: rZ
                    },
                    [rM.AvalancheFujiTestnet]: {
                        openzeppelinForwarder: iC,
                        openzeppelinForwarderEOA: "0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2",
                        biconomyForwarder: "0x6271Ca63D30507f2Dcbf99B52787032506D75BBF",
                        twFactory: iA,
                        twRegistry: ik,
                        twBYOCRegistry: "0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23"
                    },
                    [rM.Fantom]: {
                        openzeppelinForwarder: iC,
                        openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
                        biconomyForwarder: "0x64CD353384109423a966dCd3Aa30D884C9b2E057",
                        twFactory: "0x97EA0Fcc552D5A8Fb5e9101316AAd0D62Ea0876B",
                        twRegistry: ik,
                        twBYOCRegistry: rZ
                    },
                    [rM.FantomTestnet]: {
                        openzeppelinForwarder: iC,
                        openzeppelinForwarderEOA: "0x42D3048b595B6e1c28a588d70366CcC2AA4dB47b",
                        biconomyForwarder: "0x69FB8Dca8067A5D38703b9e8b39cf2D51473E4b4",
                        twFactory: iA,
                        twRegistry: ik,
                        twBYOCRegistry: "0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23"
                    },
                    [rM.Arbitrum]: {
                        openzeppelinForwarder: "0x4a8AC7f22DeD2CF923A51e4A1c67490bd8868add",
                        openzeppelinForwarderEOA: "0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F",
                        biconomyForwarder: "0xfe0fa3C06d03bDC7fb49c892BbB39113B534fB57",
                        twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
                        twRegistry: ik,
                        twBYOCRegistry: rZ
                    },
                    [rM.ArbitrumGoerli]: {
                        openzeppelinForwarder: "0x8cbc8B5d71702032904750A66AEfE8B603eBC538",
                        openzeppelinForwarderEOA: "0x119704314Ef304EaAAE4b3c7C9ABd59272A28310",
                        biconomyForwarder: rZ,
                        twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
                        twRegistry: ik,
                        twBYOCRegistry: rZ
                    },
                    [rM.Optimism]: {
                        openzeppelinForwarder: "0xd85da690EF288A6976DE0E85Fb2Aad512eBAfbf7",
                        openzeppelinForwarderEOA: "0x7e80648EB2071E26937F9D42A513ccf4815fc702",
                        biconomyForwarder: "0xefba8a2a82ec1fb1273806174f5e28fbb917cf95",
                        twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
                        twRegistry: ik,
                        twBYOCRegistry: rZ
                    },
                    [rM.OptimismGoerli]: {
                        openzeppelinForwarder: "0x8cbc8B5d71702032904750A66AEfE8B603eBC538",
                        openzeppelinForwarderEOA: "0x119704314Ef304EaAAE4b3c7C9ABd59272A28310",
                        biconomyForwarder: rZ,
                        twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
                        twRegistry: ik,
                        twBYOCRegistry: rZ
                    },
                    [rM.BinanceSmartChainMainnet]: {
                        openzeppelinForwarder: "0x7C4717039B89d5859c4Fbb85EDB19A6E2ce61171",
                        openzeppelinForwarderEOA: "0xE8dd2Ff0212F86d3197b4AfDC6dAC6ac47eb10aC",
                        biconomyForwarder: "0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8",
                        twBYOCRegistry: rZ,
                        twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
                        twRegistry: ik
                    },
                    [rM.BinanceSmartChainTestnet]: {
                        openzeppelinForwarder: "0x44bE9D54B9C8b5e57a3325E8Ec9154640e7c6955",
                        openzeppelinForwarderEOA: "0x7e80648EB2071E26937F9D42A513ccf4815fc702",
                        biconomyForwarder: "0x61456BF1715C1415730076BB79ae118E806E74d2",
                        twBYOCRegistry: rZ,
                        twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
                        twRegistry: ik
                    },
                    [rM.Hardhat]: {
                        openzeppelinForwarder: rZ,
                        openzeppelinForwarderEOA: rZ,
                        biconomyForwarder: rZ,
                        twFactory: rZ,
                        twRegistry: rZ,
                        twBYOCRegistry: rZ
                    },
                    [rM.Localhost]: {
                        openzeppelinForwarder: rZ,
                        openzeppelinForwarderEOA: rZ,
                        biconomyForwarder: rZ,
                        twFactory: rZ,
                        twRegistry: rZ,
                        twBYOCRegistry: rZ
                    }
                };

            function iz(e, t) {
                return e === rM.Hardhat || e === rM.Localhost ? "twFactory" === t ? e6("factoryAddress") : "twRegistry" === t ? e6("registryAddress") : rZ : iv[e] ? .[t]
            }
            let ix = ((g = {}).Transaction = "transaction", g.Signature = "signature", g),
                iF = L.z.object({
                    gasLimit: tR.optional(),
                    gasPrice: tR.optional(),
                    maxFeePerGas: tR.optional(),
                    maxPriorityFeePerGas: tR.optional(),
                    nonce: tR.optional(),
                    value: tR.optional(),
                    blockTag: L.z.union([L.z.string(), L.z.number()]).optional(),
                    from: tp.optional(),
                    type: L.z.number().optional()
                }).strict();
            class iT extends eQ.Z {
                constructor(e, t) {
                    super();
                    try {
                        this.options = e7.parse(t)
                    } catch (e) {
                        console.error("invalid sdk options object passed, falling back to default options", e), this.options = e7.parse({})
                    }
                    let [n, a] = tc(e, this.options);
                    this.network = e, this.signer = n, this.provider = a
                }
                updateSignerOrProvider(e) {
                    let [t, n] = tc(e, this.options);
                    this.network = e, this.signer = t, this.provider = n
                }
                isReadOnly() {
                    return !e2(this.signer)
                }
                getSigner() {
                    return this.signer
                }
                getProvider() {
                    return this.provider
                }
                getSignerOrProvider() {
                    return this.getSigner() || this.getProvider()
                }
            }
            class iS extends iT {
                isValidContract = !1;
                customOverrides = () => ({});
                constructor(e, t, n, a, r) {
                    super(e, a), this.abi = n, this.address = t, this.writeContract = new x.CH(t, n, this.getSignerOrProvider()), this.readContract = this.writeContract.connect(this.getProvider()), this.storage = r
                }
                updateSignerOrProvider(e) {
                    super.updateSignerOrProvider(e), this.writeContract = this.writeContract.connect(this.getSignerOrProvider()), this.readContract = this.writeContract.connect(this.getProvider())
                }
                updateAbi(e) {
                    this.writeContract = new x.CH(this.address, e, this.getSignerOrProvider()), this.readContract = this.writeContract.connect(this.getProvider()), this.abi = tX.parse(e)
                }
                async getChainID() {
                    let e = this.getProvider(),
                        {
                            chainId: t
                        } = await e.getNetwork();
                    return t
                }
                async getSignerAddress() {
                    let e = this.getSigner();
                    if (!e) throw Error("This action requires a connected wallet to sign the transaction. Please pass a valid signer to the SDK.");
                    return await e.getAddress()
                }
                callStatic() {
                    return this.writeContract.callStatic
                }
                async getCallOverrides() {
                    return {}
                }
                emitTransactionEvent(e, t) {
                    this.emit(ix.Transaction, {
                        status: e,
                        transactionHash: t
                    })
                }
                async multiCall(e) {
                    return this.sendTransaction("multicall", [e])
                }
                async estimateGas(e, t) {
                    return this.writeContract.estimateGas[e](...t)
                }
                withTransactionOverride(e) {
                    this.customOverrides = e
                }
                async read(e, t) {
                    let n = rm(tX.parse(this.abi)).filter(t => t.name === e);
                    if (!n.length) throw Error(`Function "${e.toString()}" not found in contract. Check your dashboard for the list of functions available`);
                    let a = n.find(n => n.name === e && n.inputs.length === t.length);
                    if (!a) throw Error(`Function "${e.toString()}" requires ${n[0].inputs.length} arguments, but ${t.length} were provided.
Expected function signature: ${n[0].signature}`);
                    let r = `${e.toString()}(${a.inputs.map(e=>e.type).join()})`,
                        i = r in this.readContract.functions ? r : e;
                    if ("view" === a.stateMutability || "pure" === a.stateMutability) return await this.readContract[i.toString()](...t);
                    throw Error("Cannot call a write function with read()")
                }
                async call(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
                        n = arguments.length > 2 ? arguments[2] : void 0,
                        a = n ? await iF.parseAsync(n) : void 0,
                        r = rm(tX.parse(this.abi)).filter(t => t.name === e);
                    if (!r.length) throw Error(`Function "${e}" not found in contract. Check your dashboard for the list of functions available`);
                    let i = r.find(n => n.name === e && n.inputs.length === t.length);
                    if (!i) throw Error(`Function "${e}" requires ${r[0].inputs.length} arguments, but ${t.length} were provided.
Expected function signature: ${r[0].signature}`);
                    let f = `${e}(${i.inputs.map(e=>e.type).join()})`,
                        s = f in this.readContract.functions ? f : e;
                    return "view" === i.stateMutability || "pure" === i.stateMutability ? a ? this.readContract[s](...t, a) : this.readContract[s](...t) : {
                        receipt: await this.sendTransaction(s, t, a)
                    }
                }
                async sendTransaction(e, t, n) {
                    if (n || (n = await this.getCallOverrides()), n = { ...n,
                            ...this.customOverrides()
                        }, this.customOverrides = () => ({}), this.options ? .gasless && ("openzeppelin" in this.options.gasless || "biconomy" in this.options.gasless || "engine" in this.options.gasless)) {
                        if ("multicall" === e && Array.isArray(t[0]) && t[0].length > 0) {
                            let e = await this.getSignerAddress();
                            t[0] = t[0].map(t => R.pack(["bytes", "address"], [t, e]))
                        }
                        let a = this.getProvider(),
                            r = await this.sendGaslessTransaction(e, t, n);
                        this.emitTransactionEvent("submitted", r);
                        let i = await a.waitForTransaction(r);
                        return this.emitTransactionEvent("completed", r), i
                    } {
                        let a;
                        if (!this.isValidContract) {
                            let e = await this.getProvider().getCode(this.address);
                            if (this.isValidContract = "0x" !== e, !this.isValidContract) throw Error("The address you're trying to send a transaction to is not a smart contract. Make sure you are on the correct network and the contract address is correct")
                        }
                        let r = await this.sendTransactionByFunction(e, t, n);
                        this.emitTransactionEvent("submitted", r.hash);
                        try {
                            a = await r.wait()
                        } catch (a) {
                            try {
                                await this.writeContract.callStatic[e](...t, ...n.value ? [{
                                    value: n.value
                                }] : [])
                            } catch (a) {
                                throw await this.formatError(a, e, t, n)
                            }
                            throw await this.formatError(a, e, t, n)
                        }
                        return this.emitTransactionEvent("completed", r.hash), a
                    }
                }
                async sendTransactionByFunction(e, t, n) {
                    let a = this.writeContract.functions[e];
                    if (!a) throw Error(`invalid function: "${e.toString()}"`);
                    if (!n.gasLimit) try {
                        n.gasLimit = await this.writeContract.estimateGas[e](...t, n)
                    } catch (a) {
                        try {
                            await this.writeContract.callStatic[e](...t, ...n.value ? [{
                                value: n.value
                            }] : [])
                        } catch (a) {
                            throw await this.formatError(a, e, t, n)
                        }
                    }
                    try {
                        return await a(...t, n)
                    } catch (a) {
                        throw await this.formatError(a, e, t, n)
                    }
                }
                async formatError(e, t, n, a) {
                    let r, i;
                    let f = this.getProvider(),
                        s = await f.getNetwork(),
                        o = await (a.from || this.getSignerAddress()),
                        c = this.address,
                        d = this.readContract.interface.encodeFunctionData(t, n),
                        l = v.O$.from(a.value || 0),
                        u = f.connection ? .url,
                        m = this.readContract.interface.getFunction(t),
                        p = n.map(e => JSON.stringify(e).length <= 80 ? JSON.stringify(e) : JSON.stringify(e, void 0, 2)),
                        b = p.join(", ").length <= 80 ? p.join(", ") : "\n" + p.map(e => "  " + e.split("\n").join("\n  ")).join(",\n") + "\n",
                        g = `${m.name}(${b})`,
                        h = e.transactionHash || e.transaction ? .hash || e.receipt ? .transactionHash,
                        y = r7(e);
                    try {
                        let e = await ry(this.address, this.getProvider(), this.storage, this.options);
                        e.name && (i = e.name), e.metadata.sources && (r = await ir(e, this.storage))
                    } catch (e) {}
                    return new r4({
                        reason: y,
                        from: o,
                        to: c,
                        method: g,
                        data: d,
                        network: s,
                        rpcUrl: u,
                        value: l,
                        hash: h,
                        contractName: i,
                        sources: r
                    }, e)
                }
                async sendGaslessTransaction(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
                        n = arguments.length > 2 ? arguments[2] : void 0,
                        a = this.getSigner();
                    (0, M.Z)(a, "Cannot execute gasless transaction without valid signer");
                    let r = await this.getChainID(),
                        i = await this.getSignerAddress(),
                        f = this.writeContract.address,
                        s = n ? .value || 0;
                    if (v.O$.from(s).gt(0)) throw Error("Cannot send native token value with gasless transaction");
                    let o = this.writeContract.interface.encodeFunctionData(e, t),
                        c = v.O$.from(0);
                    try {
                        c = (await this.readContract.estimateGas[e](...t)).mul(2)
                    } catch (e) {}
                    c.lt(1e5) && (c = v.O$.from(5e5)), n.gasLimit && v.O$.from(n.gasLimit).gt(c) && (c = v.O$.from(n.gasLimit));
                    let d = {
                        from: i,
                        to: f,
                        data: o,
                        chainId: r,
                        gasLimit: c,
                        functionName: e.toString(),
                        functionArgs: t,
                        callOverrides: n
                    };
                    return await this.defaultGaslessSendFunction(d)
                }
                async signTypedData(e, t, n, a) {
                    this.emit(ix.Signature, {
                        status: "submitted",
                        message: a,
                        signature: ""
                    });
                    let {
                        signature: r
                    } = await iu(e, t, n, a);
                    return this.emit(ix.Signature, {
                        status: "completed",
                        message: a,
                        signature: r
                    }), r
                }
                parseLogs(e, t) {
                    if (!t || 0 === t.length) return [];
                    let n = this.writeContract.interface.getEventTopic(e);
                    return t.filter(e => e.topics.indexOf(n) >= 0).map(e => this.writeContract.interface.parseLog(e))
                }
                async defaultGaslessSendFunction(e) {
                    return this.options.gasless && "biconomy" in this.options.gasless ? this.biconomySendFunction(e) : this.options.gasless && "openzeppelin" in this.options.gasless ? this.defenderSendFunction(e) : this.engineSendFunction(e)
                }
                async engineSendFunction(e) {
                    (0, M.Z)(this.options.gasless && "engine" in this.options.gasless, "calling engine gasless transaction without engine config in the SDK options");
                    let t = await this.enginePrepareRequest(e),
                        n = await fetch(this.options.gasless.engine.relayerUrl, { ...t,
                            headers: {
                                "Content-Type": "application/json"
                            }
                        }),
                        a = await n.json();
                    if (a.error) throw Error(a.error ? .message || JSON.stringify(a.error));
                    let r = a.result.queueId,
                        i = this.options.gasless.engine.relayerUrl.split("/relayer/")[0],
                        f = Date.now();
                    for (;;) {
                        let e = await fetch(`${i}/transaction/status/${r}`),
                            t = await e.json();
                        if (t.result.transactionHash) return t.result.transactionHash;
                        if (Date.now() - f > 3e4) throw Error("timeout");
                        await new Promise(e => setTimeout(e, 2e3))
                    }
                }
                async enginePrepareRequest(e) {
                    let t = this.getSigner(),
                        a = this.getProvider(),
                        r = this.storage;
                    (0, M.Z)(t, "signer is not set");
                    try {
                        let {
                            abi: n
                        } = await ry(e.to, a, r), i = (await a.getNetwork()).chainId, f = new iS(t, e.to, n, {}, r);
                        if (n.find(e => "executeMetaTransaction" === e.name)) {
                            let n = {
                                    name: await f.call("name", []),
                                    version: "1",
                                    salt: "0x" + i.toString(16).padStart(64, "0"),
                                    verifyingContract: e.to
                                },
                                a = {
                                    nonce: await f.call("getNonce", [e.from]),
                                    from: e.from,
                                    functionSignature: e.data
                                },
                                {
                                    signature: r
                                } = await iu(t, n, {
                                    MetaTransaction: [{
                                        name: "nonce",
                                        type: "uint256"
                                    }, {
                                        name: "from",
                                        type: "address"
                                    }, {
                                        name: "functionSignature",
                                        type: "bytes"
                                    }]
                                }, a);
                            return {
                                method: "POST",
                                body: JSON.stringify({
                                    type: "execute-meta-transaction",
                                    request: {
                                        from: e.from,
                                        to: e.to,
                                        data: e.data
                                    },
                                    signature: r
                                })
                            }
                        }
                    } catch {}
                    if ("approve" === e.functionName && 2 === e.functionArgs.length) {
                        let n = e.functionArgs[0],
                            a = e.functionArgs[1],
                            {
                                message: r,
                                signature: i
                            } = await iE(t, e.to, e.from, n, a);
                        return {
                            method: "POST",
                            body: JSON.stringify({
                                type: "permit",
                                request: {
                                    to: e.to,
                                    owner: r.owner,
                                    spender: r.spender,
                                    value: v.O$.from(r.value).toString(),
                                    nonce: v.O$.from(r.nonce).toString(),
                                    deadline: v.O$.from(r.deadline).toString()
                                },
                                signature: i
                            })
                        }
                    } {
                        let i = iv[e.chainId] ? .openzeppelinForwarder || await rQ(a, r),
                            f = (await n.e(61303).then(n.t.bind(n, 61303, 19))).default,
                            s = new x.CH(i, f, a),
                            o = await il(s, "getNonce", [e.from]),
                            c = {
                                name: "GSNv2 Forwarder",
                                version: "0.0.1",
                                chainId: e.chainId,
                                verifyingContract: i
                            },
                            d = {
                                from: e.from,
                                to: e.to,
                                value: v.O$.from(0).toString(),
                                gas: v.O$.from(e.gasLimit).toString(),
                                nonce: v.O$.from(o).toString(),
                                data: e.data
                            },
                            {
                                signature: l
                            } = await iu(t, c, {
                                ForwardRequest: ii
                            }, d);
                        return {
                            method: "POST",
                            body: JSON.stringify({
                                type: "forward",
                                request: d,
                                signature: l,
                                forwarderAddress: i
                            })
                        }
                    }
                }
                async biconomySendFunction(e) {
                    (0, M.Z)(this.options.gasless && "biconomy" in this.options.gasless, "calling biconomySendFunction without biconomy");
                    let t = this.getSigner(),
                        n = this.getProvider();
                    (0, M.Z)(t && n, "signer and provider must be set");
                    let a = new x.CH(iz(e.chainId, "biconomyForwarder"), io, n),
                        r = await il(a, "getNonce", [e.from, 0]),
                        i = {
                            from: e.from,
                            to: e.to,
                            token: z.d,
                            txGas: e.gasLimit.toNumber(),
                            tokenGasPrice: "0",
                            batchId: 0,
                            batchNonce: r.toNumber(),
                            deadline: Math.floor(Date.now() / 1e3 + (this.options ? .gasless && "biconomy" in this.options.gasless && this.options.gasless.biconomy ? .deadlineSeconds || 3600)),
                            data: e.data
                        },
                        f = T.arrayify(R.keccak256(["address", "address", "address", "uint256", "uint256", "uint256", "uint256", "uint256", "bytes32"], [i.from, i.to, i.token, i.txGas, i.tokenGasPrice, i.batchId, i.batchNonce, i.deadline, S.keccak256(i.data)]));
                    this.emit(ix.Signature, {
                        status: "submitted",
                        message: f,
                        signature: ""
                    });
                    let s = await t.signMessage(f);
                    this.emit(ix.Signature, {
                        status: "completed",
                        message: f,
                        signature: s
                    });
                    let o = await fetch("https://api.biconomy.io/api/v2/meta-tx/native", {
                        method: "POST",
                        body: JSON.stringify({
                            from: e.from,
                            apiId: this.options.gasless.biconomy.apiId,
                            params: [i, s],
                            to: e.to,
                            gasLimit: e.gasLimit.toHexString()
                        }),
                        headers: {
                            "x-api-key": this.options.gasless.biconomy.apiKey,
                            "Content-Type": "application/json;charset=utf-8"
                        }
                    });
                    if (o.ok) {
                        let e = await o.json();
                        if (!e.txHash) throw Error(`relay transaction failed: ${e.log}`);
                        return e.txHash
                    }
                    throw Error(`relay transaction failed with status: ${o.status} (${o.statusText})`)
                }
                async defenderSendFunction(e) {
                    let t, a, r, i;
                    (0, M.Z)(this.options.gasless && "openzeppelin" in this.options.gasless, "calling openzeppelin gasless transaction without openzeppelin config in the SDK options");
                    let f = this.getSigner(),
                        s = this.getProvider();
                    (0, M.Z)(f, "provider is not set"), (0, M.Z)(s, "provider is not set");
                    let o = (await n.e(61303).then(n.t.bind(n, 61303, 19))).default,
                        c = this.options.gasless.openzeppelin.relayerForwarderAddress || (this.options.gasless.openzeppelin.useEOAForwarder ? iv[e.chainId] ? .openzeppelinForwarderEOA || await rX(this.getProvider(), this.storage, "", this.options.clientId, this.options.secretKey) : iv[e.chainId] ? .openzeppelinForwarder || await rQ(this.getProvider(), this.storage, "", this.options.clientId, this.options.secretKey)),
                        d = new x.CH(c, o, s),
                        l = await il(d, "getNonce", [e.from]);
                    if (this.options.gasless.experimentalChainlessSupport ? (t = {
                            name: "GSNv2 Forwarder",
                            version: "0.0.1",
                            verifyingContract: c
                        }, a = {
                            ForwardRequest: is
                        }, r = {
                            from: e.from,
                            to: e.to,
                            value: v.O$.from(0).toString(),
                            gas: v.O$.from(e.gasLimit).toString(),
                            nonce: v.O$.from(l).toString(),
                            data: e.data,
                            chainid: v.O$.from(e.chainId).toString()
                        }) : (t = {
                            name: this.options.gasless.openzeppelin.domainName,
                            version: this.options.gasless.openzeppelin.domainVersion,
                            chainId: e.chainId,
                            verifyingContract: c
                        }, a = {
                            ForwardRequest: ii
                        }, r = {
                            from: e.from,
                            to: e.to,
                            value: v.O$.from(0).toString(),
                            gas: v.O$.from(e.gasLimit).toString(),
                            nonce: v.O$.from(l).toString(),
                            data: e.data
                        }), this.emit(ix.Signature, {
                            status: "submitted",
                            message: r,
                            signature: ""
                        }), "approve" === e.functionName && 2 === e.functionArgs.length) {
                        let t = e.functionArgs[0],
                            n = e.functionArgs[1],
                            {
                                message: a,
                                signature: s
                            } = await iE(f, this.writeContract.address, e.from, t, n),
                            {
                                r: o,
                                s: c,
                                v: d
                            } = T.splitSignature(s);
                        r = {
                            to: this.address,
                            owner: a.owner,
                            spender: a.spender,
                            value: v.O$.from(a.value).toString(),
                            nonce: v.O$.from(a.nonce).toString(),
                            deadline: v.O$.from(a.deadline).toString(),
                            r: o,
                            s: c,
                            v: d
                        }, i = s
                    } else {
                        let {
                            signature: e
                        } = await iu(f, t, a, r);
                        i = e
                    }
                    let u = "forward";
                    r ? .owner && (u = "permit");
                    let m = JSON.stringify({
                        request: r,
                        signature: i,
                        forwarderAddress: c,
                        type: u
                    });
                    this.emit(ix.Signature, {
                        status: "completed",
                        message: r,
                        signature: i
                    });
                    let p = await fetch(this.options.gasless.openzeppelin.relayerUrl, {
                        method: "POST",
                        body: m
                    });
                    if (p.ok) {
                        let e = await p.json();
                        if (!e.result) throw Error(`Relay transaction failed: ${e.message}`);
                        return JSON.parse(e.result).txHash
                    }
                    throw Error(`relay transaction failed with status: ${p.status} (${p.statusText})`)
                }
            }

            function iB(e, t) {
                return function e(t, n) {
                    let a = Object.keys(t);
                    if (!a.includes(n)) {
                        let r = !1;
                        for (let i of a)
                            if (r = e(t[i].features, n)) break;
                        return r
                    }
                    return t[n].enabled
                }(rp(e), t)
            }

            function iO(e, t) {
                return iB(e, t)
            }
            async function iR(e, t, n) {
                return (await Promise.all(e.map(e => ry(e, t, n).catch(t => (console.error(`Failed to fetch plug-in for ${e}`, t), {
                    abi: []
                }))))).map(e => e.abi)
            }
            async function iD(e, t, n, a, r) {
                let i = [];
                try {
                    var f, s, o, c, d, l;
                    let u = (f = tX.parse(t), s = "PluginRouter", iB(f, s)),
                        m = (o = tX.parse(t), c = "DynamicContract", iB(o, c)),
                        p = (d = tX.parse(t), l = "Fallback", iB(d, l));
                    if (m) {
                        let t = new iS(n, e, aq, a, r),
                            f = (await t.call("getAllExtensions")).map(e => e.metadata.implementation);
                        i = await iR(f, n, r)
                    } else if (u) {
                        let t = new iS(n, e, aY, a, r),
                            f = (await t.call("getAllPlugins")).map(e => e.pluginAddress),
                            s = Array.from(new Set(f));
                        i = await iR(s, n, r)
                    } else if (p) {
                        let t = new x.CH(e, ["function facets() external view returns (tuple(address,bytes4[])[])"], n),
                            a = (await t.facets()).map(e => e[0]);
                        i = await iR(a, n, r)
                    }
                } catch (e) {}
                return i.length > 0 ? at([...i], t) : t
            }
            let iP = {
                    admin: "",
                    transfer: "TRANSFER_ROLE",
                    minter: "MINTER_ROLE",
                    pauser: "PAUSER_ROLE",
                    lister: "LISTER_ROLE",
                    asset: "ASSET_ROLE",
                    unwrap: "UNWRAP_ROLE",
                    factory: "FACTORY_ROLE",
                    signer: "SIGNER_ROLE",
                    metadata: "METADATA_ROLE",
                    revoke: "REVOKE_ROLE",
                    migration: "MIGRATION_ROLE"
                },
                i_ = Object.keys(iP);

            function i$(e) {
                return "admin" === e ? T.hexZeroPad([0], 32) : O.id(iP[e])
            }
            let iN = tP.merge(t$).merge(tW).merge(tM),
                iL = t_.merge(t$).merge(tW).merge(tM),
                iI = {
                    deploy: iN.merge(tL).merge(tN).merge(tI),
                    output: iL,
                    input: iN
                },
                iM = tP.merge(tW).merge(tM),
                iW = t_.merge(tW).merge(tM),
                ij = {
                    deploy: iM.merge(tL).merge(tN).merge(tI),
                    output: iW,
                    input: iM
                },
                iU = tP.merge(t$).merge(tW).merge(tM),
                iH = t_.merge(t$).merge(tW).merge(tM),
                iV = {
                    deploy: iU.merge(tL).merge(tN).merge(tI),
                    output: iH,
                    input: iU
                },
                iG = {
                    deploy: tP.merge(tL).merge(tI),
                    output: t_,
                    input: tP
                },
                iK = tP.merge(t$).merge(tM),
                iZ = t_.merge(t$).merge(tM),
                iY = {
                    deploy: iK.merge(tI),
                    output: iZ,
                    input: iK
                },
                iq = tP.merge(t$).merge(tM),
                iJ = t_.merge(t$).merge(tM),
                iX = {
                    deploy: iq.merge(tL).merge(tI),
                    output: iJ,
                    input: iq
                },
                iQ = L.z.object({
                    address: tp,
                    sharesBps: tA.gt(0, "Shares must be greater than 0")
                }),
                i0 = iQ.extend({
                    address: tp,
                    sharesBps: tA
                }),
                i1 = tP.extend({
                    recipients: L.z.array(iQ).default([]).superRefine((e, t) => {
                        let n = {},
                            a = 0;
                        for (let r = 0; r < e.length; r++) {
                            let i = e[r];
                            n[i.address] && t.addIssue({
                                code: L.z.ZodIssueCode.custom,
                                message: "Duplicate address.",
                                path: [r, "address"]
                            }), n[i.address] = !0, (a += i.sharesBps) > 1e4 && t.addIssue({
                                code: L.z.ZodIssueCode.custom,
                                message: "Total shares cannot go over 100%.",
                                path: [r, "sharesBps"]
                            })
                        }
                        1e4 !== a && t.addIssue({
                            code: L.z.ZodIssueCode.custom,
                            message: `Total shares need to add up to 100%. Total shares are currently ${a/100}%`,
                            path: []
                        })
                    })
                }),
                i6 = t_.extend({
                    recipients: L.z.array(i0)
                }),
                i5 = {
                    deploy: i1.merge(i1).merge(tI),
                    output: i6,
                    input: i1
                },
                i2 = tP.merge(t$).merge(tM),
                i8 = t_.merge(t$).merge(tM),
                i3 = {
                    deploy: i2.merge(tL).merge(tN).merge(tI),
                    output: i8,
                    input: i2
                },
                i9 = tP.merge(tM),
                i4 = t_.merge(tM),
                i7 = {
                    deploy: i9.merge(tL).merge(tN).merge(tI),
                    output: i4,
                    input: i9
                },
                fe = tP.merge(t$).merge(tM),
                ft = t_.merge(t$).merge(tM),
                fn = {
                    deploy: fe.merge(tL).merge(tN).merge(tI),
                    output: ft,
                    input: fe
                },
                fa = L.z.object({
                    voting_delay_in_blocks: L.z.number().min(0).default(0),
                    voting_period_in_blocks: L.z.number().min(1).default(1),
                    voting_token_address: tp,
                    voting_quorum_fraction: tC.default(0),
                    proposal_token_threshold: tR.default(1)
                }),
                fr = fa.extend({
                    proposal_token_threshold: tO
                }),
                fi = tP.merge(fa),
                ff = t_.merge(fr),
                fs = {
                    deploy: fi.merge(tI),
                    output: ff,
                    input: fi
                },
                fo = ["admin"],
                fc = ["admin", "minter", "transfer", "metadata"],
                fd = ["admin", "lister", "asset"],
                fl = ["admin", "minter", "asset", "transfer"],
                fu = ["admin", "transfer"],
                fm = ["admin", "transfer", "minter", "unwrap", "asset"],
                fp = "vote",
                fb = "token",
                fg = "edition-drop",
                fh = "edition",
                fy = "marketplace",
                fw = "marketplace-v3",
                fE = "multiwrap",
                fk = "nft-collection",
                fA = "nft-drop",
                fC = "pack",
                fv = "signature-drop",
                fz = "split",
                fx = "token-drop",
                fF = {
                    name: "DropERC1155",
                    contractType: fg,
                    schema: iI,
                    roles: fc,
                    initialize: async function() {
                        for (var e = arguments.length, t = Array(e), a = 0; a < e; a++) t[a] = arguments[a];
                        let [r, i, f, s] = t, [, o] = tc(r, s), [c, d, l] = await Promise.all([fF.getAbi(i, o, f), Promise.all([n.e(83659), n.e(52837), n.e(1841), n.e(32675), n.e(49388)]).then(n.bind(n, 49388)), o.getNetwork()]);
                        return new d.EditionDrop(r, i, f, s, c, l.chainId)
                    },
                    getAbi: async (e, t, a) => {
                        let r = await rk(e, t, a);
                        if (r) return r;
                        let i = await fM(e, t);
                        return !i || i.version > 2 ? (await n.e(30794).then(n.t.bind(n, 30794, 19))).default : (await n.e(12919).then(n.t.bind(n, 12919, 19))).default
                    }
                },
                fT = {
                    name: "TokenERC1155",
                    contractType: fh,
                    schema: i3,
                    roles: fc,
                    initialize: async function() {
                        for (var e = arguments.length, t = Array(e), a = 0; a < e; a++) t[a] = arguments[a];
                        let [r, i, f, s] = t, [, o] = tc(r, s), [c, d, l] = await Promise.all([fT.getAbi(i, o, f), Promise.all([n.e(83659), n.e(52837), n.e(1841), n.e(32675), n.e(86818)]).then(n.bind(n, 86818)), o.getNetwork()]);
                        return new d.Edition(r, i, f, s, c, l.chainId)
                    },
                    getAbi: async (e, t, a) => await rk(e, t, a) || (await n.e(38469).then(n.t.bind(n, 38469, 19))).default
                },
                fS = {
                    name: "Marketplace",
                    contractType: fy,
                    schema: iG,
                    roles: fd,
                    initialize: async function() {
                        for (var e = arguments.length, t = Array(e), a = 0; a < e; a++) t[a] = arguments[a];
                        let [r, i, f, s] = t, [, o] = tc(r, s), [c, d, l] = await Promise.all([fS.getAbi(i, o, f), Promise.all([n.e(83659), n.e(54529)]).then(n.bind(n, 54529)), o.getNetwork()]);
                        return new d.Marketplace(r, i, f, s, c, l.chainId)
                    },
                    getAbi: async (e, t, a) => await rk(e, t, a) || (await n.e(38838).then(n.t.bind(n, 38838, 19))).default
                },
                fB = {
                    name: "MarketplaceV3",
                    contractType: fw,
                    schema: iG,
                    roles: fd,
                    initialize: async function() {
                        for (var e = arguments.length, t = Array(e), a = 0; a < e; a++) t[a] = arguments[a];
                        let [r, i, f, s] = t, [, o] = tc(r, s), [c, d, l] = await Promise.all([fB.getAbi(i, o, f, s), Promise.all([n.e(83659), n.e(83716), n.e(77256)]).then(n.bind(n, 97867)), o.getNetwork()]);
                        return new d.MarketplaceV3(r, i, f, s, c, l.chainId)
                    },
                    getAbi: async (e, t, a, r) => {
                        let i = (await t.getNetwork()).chainId;
                        if (280 === i || 324 === i) {
                            let e = (await ny(nh, "MarketplaceV3", "latest", a, r ? .clientId, r ? .secretKey)).metadataUri;
                            return await rA(e, a)
                        }
                        let f = await rk(e, t, a);
                        if (f) return await iD(e, f, t, {}, a);
                        let s = (await n.e(86079).then(n.t.bind(n, 86079, 19))).default;
                        return await iD(e, tX.parse(s || []), t, {}, a)
                    }
                },
                fO = {
                    name: "Multiwrap",
                    contractType: fE,
                    schema: iY,
                    roles: fm,
                    initialize: async function() {
                        for (var e = arguments.length, t = Array(e), a = 0; a < e; a++) t[a] = arguments[a];
                        let [r, i, f, s] = t, [, o] = tc(r, s), [c, d, l] = await Promise.all([fO.getAbi(i, o, f), Promise.all([n.e(83659), n.e(52837), n.e(24826), n.e(1841), n.e(33244), n.e(76989)]).then(n.bind(n, 76989)), o.getNetwork()]);
                        return new d.Multiwrap(r, i, f, s, c, l.chainId)
                    },
                    getAbi: async (e, t, a) => await rk(e, t, a) || (await n.e(18133).then(n.t.bind(n, 18133, 19))).default
                },
                fR = {
                    name: "TokenERC721",
                    contractType: fk,
                    schema: fn,
                    roles: fc,
                    initialize: async function() {
                        for (var e = arguments.length, t = Array(e), a = 0; a < e; a++) t[a] = arguments[a];
                        let [r, i, f, s] = t, [, o] = tc(r, s), [c, d, l] = await Promise.all([fR.getAbi(i, o, f), Promise.all([n.e(83659), n.e(52837), n.e(24826), n.e(1841), n.e(33244), n.e(64901)]).then(n.bind(n, 64901)), o.getNetwork()]);
                        return new d.NFTCollection(r, i, f, s, c, l.chainId)
                    },
                    getAbi: async (e, t, a) => await rk(e, t, a) || (await n.e(27505).then(n.t.bind(n, 27505, 19))).default
                },
                fD = {
                    name: "DropERC721",
                    contractType: fA,
                    schema: iV,
                    roles: fc,
                    initialize: async function() {
                        for (var e = arguments.length, t = Array(e), a = 0; a < e; a++) t[a] = arguments[a];
                        let [r, i, f, s] = t, [, o] = tc(r, s), [c, d, l] = await Promise.all([fD.getAbi(i, o, f), Promise.all([n.e(83659), n.e(52837), n.e(24826), n.e(1841), n.e(33244), n.e(47991)]).then(n.bind(n, 47991)), o.getNetwork()]);
                        return new d.NFTDrop(r, i, f, s, c, l.chainId)
                    },
                    getAbi: async (e, t, a) => {
                        let r = await rk(e, t, a);
                        if (r) return r;
                        let i = await fM(e, t);
                        return !i || i.version > 3 ? (await n.e(14380).then(n.t.bind(n, 14380, 19))).default : (await n.e(54867).then(n.t.bind(n, 54867, 19))).default
                    }
                },
                fP = {
                    name: "Pack",
                    contractType: fC,
                    schema: iX,
                    roles: fl,
                    initialize: async function() {
                        for (var e = arguments.length, t = Array(e), a = 0; a < e; a++) t[a] = arguments[a];
                        let [r, i, f, s] = t, [, o] = tc(r, s), [c, d, l] = await Promise.all([fP.getAbi(i, o, f), Promise.all([n.e(83659), n.e(52837), n.e(24826), n.e(1841), n.e(32675), n.e(95920), n.e(82786)]).then(n.bind(n, 82786)), o.getNetwork()]);
                        return new d.Pack(r, i, f, s, c, l.chainId)
                    },
                    getAbi: async (e, t, a) => await rk(e, t, a) || tX.parse((await n.e(16482).then(n.t.bind(n, 16482, 19))).default || [])
                },
                f_ = {
                    name: "SignatureDrop",
                    contractType: fv,
                    schema: iV,
                    roles: fc,
                    initialize: async function() {
                        for (var e = arguments.length, t = Array(e), a = 0; a < e; a++) t[a] = arguments[a];
                        let [r, i, f, s] = t, [, o] = tc(r, s), [c, d, l] = await Promise.all([f_.getAbi(i, o, f), Promise.all([n.e(83659), n.e(52837), n.e(24826), n.e(1841), n.e(33244), n.e(96457)]).then(n.bind(n, 96457)), o.getNetwork()]);
                        return new d.SignatureDrop(r, i, f, s, c, l.chainId)
                    },
                    getAbi: async (e, t, a) => {
                        let r = await rk(e, t, a);
                        if (r) return r;
                        let i = await fM(e, t);
                        return !i || i.version > 4 ? (await n.e(42184).then(n.t.bind(n, 42184, 19))).default : (await n.e(32717).then(n.t.bind(n, 32717, 19))).default
                    }
                },
                f$ = {
                    name: "Split",
                    contractType: fz,
                    schema: i5,
                    roles: fo,
                    initialize: async function() {
                        for (var e = arguments.length, t = Array(e), a = 0; a < e; a++) t[a] = arguments[a];
                        let [r, i, f, s] = t, [, o] = tc(r, s), [c, d, l] = await Promise.all([f$.getAbi(i, o, f), Promise.all([n.e(83659), n.e(48266)]).then(n.bind(n, 48266)), o.getNetwork()]);
                        return new d.Split(r, i, f, s, c, l.chainId)
                    },
                    getAbi: async (e, t, a) => await rk(e, t, a) || (await n.e(54338).then(n.t.bind(n, 54338, 19))).default
                },
                fN = {
                    name: "DropERC20",
                    contractType: fx,
                    schema: ij,
                    roles: fu,
                    initialize: async function() {
                        for (var e = arguments.length, t = Array(e), a = 0; a < e; a++) t[a] = arguments[a];
                        let [r, i, f, s] = t, [, o] = tc(r, s), [c, d, l] = await Promise.all([fN.getAbi(i, o, f), Promise.all([n.e(83659), n.e(52837), n.e(24826), n.e(95920), n.e(25848)]).then(n.bind(n, 25848)), o.getNetwork()]);
                        return new d.TokenDrop(r, i, f, s, c, l.chainId)
                    },
                    getAbi: async (e, t, a) => {
                        let r = await rk(e, t, a);
                        if (r) return r;
                        let i = await fM(e, t);
                        return !i || i.version > 2 ? (await n.e(4279).then(n.t.bind(n, 4279, 19))).default : (await n.e(70562).then(n.t.bind(n, 70562, 19))).default
                    }
                },
                fL = {
                    name: "TokenERC20",
                    contractType: fb,
                    schema: i7,
                    roles: fc,
                    initialize: async function() {
                        for (var e = arguments.length, t = Array(e), a = 0; a < e; a++) t[a] = arguments[a];
                        let [r, i, f, s] = t, [, o] = tc(r, s), [c, d, l] = await Promise.all([fL.getAbi(i, o, f), Promise.all([n.e(83659), n.e(52837), n.e(24826), n.e(95920), n.e(21637)]).then(n.bind(n, 21637)), o.getNetwork()]);
                        return new d.Token(r, i, f, s, c, l.chainId)
                    },
                    getAbi: async (e, t, a) => await rk(e, t, a) || (await n.e(22687).then(n.t.bind(n, 22687, 19))).default
                },
                fI = {
                    name: "VoteERC20",
                    contractType: fp,
                    schema: fs,
                    roles: [],
                    initialize: async function() {
                        for (var e = arguments.length, t = Array(e), a = 0; a < e; a++) t[a] = arguments[a];
                        let [r, i, f, s] = t, [, o] = tc(r, s), [c, d, l] = await Promise.all([fI.getAbi(i, o, f), n.e(80575).then(n.bind(n, 80575)), o.getNetwork()]);
                        return new d.Vote(r, i, f, s, c, l.chainId)
                    },
                    getAbi: async (e, t, a) => await rk(e, t, a) || (await n.e(75311).then(n.t.bind(n, 75311, 19))).default
                };
            async function fM(e, t) {
                try {
                    return await nw(e, t)
                } catch (e) {
                    return
                }
            }
            let fW = {
                    [fg]: fF,
                    [fh]: fT,
                    [fy]: fS,
                    [fw]: fB,
                    [fE]: fO,
                    [fk]: fR,
                    [fA]: fD,
                    [fC]: fP,
                    [fv]: f_,
                    [fz]: f$,
                    [fx]: fN,
                    [fb]: fL,
                    [fp]: fI
                },
                fj = {
                    [fg]: "ipfs://QmNm3wRzpKYWo1SRtJfgfxtvudp5p2nXD6EttcsQJHwTmk",
                    [fh]: "",
                    [fy]: "ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/marketplace.html",
                    [fw]: "ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/marketplace-v3.html",
                    [fE]: "",
                    [fk]: "",
                    [fA]: "ipfs://QmZptmVipc6SGFbKAyXcxGgohzTwYRXZ9LauRX5ite1xDK",
                    [fC]: "",
                    [fv]: "ipfs://QmZptmVipc6SGFbKAyXcxGgohzTwYRXZ9LauRX5ite1xDK",
                    [fz]: "",
                    [fx]: "ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/erc20.html",
                    [fb]: "",
                    [fp]: ""
                },
                fU = {
                    name: "SmartContract",
                    contractType: "custom",
                    schema: {},
                    roles: i_
                },
                fH = { ...fW,
                    [fU.contractType]: fU
                };

            function fV(e) {
                return Object.values(fH).find(t => t.name === e) ? .contractType || "custom"
            }

            function fG(e) {
                return Object.values(fH).find(t => t.contractType === e) ? .name
            }
        }
    }
]);